{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v240-05-09-2025","title":"v2.4.0 (05-09-2025)","text":"<p>This update introduces a new built-in method to use region &amp; section polygons  built on the MeshKernel package, switches to the uv package and project manager and increases test coverage. </p>"},{"location":"CHANGELOG/#new-features","title":"New features","text":"<ul> <li>new built-in method to use region- and section polygons, enabled by default, see documentation for more information</li> <li>missing key in configuration now prints a warning</li> <li>new configuration parameters \"defaultsection\" and \"defaultregion\"</li> <li>configuration parameter \"classificationmethod\" no longer exists</li> </ul>"},{"location":"CHANGELOG/#breaking-changes","title":"Breaking changes","text":"<ul> <li>old \"DeltaShell\" classification with undocumented \"_BATHY.nc\" no longer works</li> <li>Region polygon now requires \"region\" property as well as \"name\" property.</li> <li>Section polygon now requires the \"name\" property as well as the \"section\" property</li> </ul>"},{"location":"CHANGELOG/#maintenance","title":"Maintenance","text":"<ul> <li>increased test coverage</li> <li>removed archived tests</li> </ul>"},{"location":"CHANGELOG/#v233-24-09-2024","title":"v2.3.3 (24-09-2024)","text":""},{"location":"CHANGELOG/#new-features_1","title":"New features","text":"<ul> <li>added additional statistics: last3, max3 (#92)</li> <li>all statistics are now written to csv file (#92)</li> </ul>"},{"location":"CHANGELOG/#bugs-fixed","title":"Bugs fixed","text":"<ul> <li>fm2prof interpreting missing value (-999) as water level (#89 )</li> <li>fixed branch exception issue that failed if user provided no rules in <code>utils.GenerateCrossSectionLocationFile</code></li> </ul>"},{"location":"CHANGELOG/#maintenance_1","title":"Maintenance","text":"<ul> <li>switched from black &amp; isort to Ruff for linting and code formatting</li> <li>removed unused code</li> <li>added extra tests</li> </ul>"},{"location":"CHANGELOG/#v232-07-05-2024","title":"v2.3.2 (07-05-2024)","text":"<p>This release focuses on improving the <code>fm2prof.utils</code> tooling</p>"},{"location":"CHANGELOG/#new-functionality","title":"New functionality","text":"<ul> <li><code>utils.Compare1D2D</code> has new option to output a <code>last25</code> and <code>max13</code> longitudinal view, and to combine the output of several simulations into a single figure (#65). The docs have been updated with a notebook to showcase this new functionality. See User Manual -&gt; Utilities</li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>added notebooks to documentation that describe the use of some utilities</li> </ul>"},{"location":"CHANGELOG/#changes","title":"Changes","text":"<ul> <li>added new <code>sito_2024</code> <code>PlotStyle</code> that is now default for <code>Compare1D2D</code> (#66)</li> </ul>"},{"location":"CHANGELOG/#deprecations","title":"Deprecations","text":"<ul> <li><code>Compare1D2D.figure_longitudinal_time</code> is now deprecated in favour of <code>Compare1D2D.figure_longitudinal</code> with <code>stat=\"time\"</code> parameter</li> </ul>"},{"location":"CHANGELOG/#v231-24-04-2024","title":"v2.3.1 (24-04-2024)","text":"<p>Bug fixes - Fixed a bug that threw an exception if user did not specify a stop time when using <code>utils.Compare1D2D</code> (#78) - Fixed bug (#81) that prevented executable from being build because of missing favico</p> <p>Documentation - added python snippets to quickstart tutorial</p>"},{"location":"CHANGELOG/#v230-19-04-2024","title":"v2.3.0 (19-04-2024)","text":""},{"location":"CHANGELOG/#new-functionality_1","title":"New functionality","text":"<ul> <li>Configuration file now has a new <code>debug</code> section with debug specific parameters. This section includes two parameters previously in the general <code>parameters</code> section (<code>ExportMapFiles</code> and <code>CssSelection</code>) and the new <code>ExportCSSData</code>. </li> <li>new debug option <code>ExportCSSData</code> that when enabled output data to analyse cross-section generation. </li> <li>new option <code>ConveyanceDetectionMethod</code> to toggle between the previous way to detect storage (0) and a the new one (1, default). </li> </ul>"},{"location":"CHANGELOG/#documentation_1","title":"Documentation","text":"<ul> <li>documentation now includes a notebook specifying how output from <code>ExportCSSData</code> option can be used to analyse flow data</li> <li>docstrings of cross-section class updated to describe flow/storage separation methodology</li> <li>several chapters ported over from sphinx</li> </ul>"},{"location":"CHANGELOG/#bug-fixes-chores","title":"bug fixes &amp; chores","text":"<ul> <li>added dedicated tests for cross-section class</li> <li>test coverage is now reported in Sonarcloud</li> <li>fixed bug that caused error while writing log</li> </ul>"},{"location":"CHANGELOG/#bug-fixes-chores_1","title":"bug fixes &amp; chores","text":"<ul> <li>fixed bug in <code>utils</code> that threw an error when using matplotlib 3.7 or higher</li> <li>removed unused code blocks</li> <li>updated type hinting and code documentation of <code>CrossSection.py</code></li> </ul>"},{"location":"CHANGELOG/#v228-2023-10-03","title":"v2.2.8 (2023-10-03)","text":"<p>This version update FM2PROF to Python 3.10 or higher. It removes unused dependencies and updates the package system <code>poetry</code> to version 1.8.2. Due to this switch, the commitizen workflow is currently not used, and the documentation system switch from sphinx to mkdocs. </p> <p>This is the first version to be published to PyPi, which means that FM2PROF can now be installed using pip</p> <p><code>pip install fm2prof</code></p> <p>Known issues:</p> <ul> <li>The executable is not available for this version. </li> </ul>"},{"location":"CHANGELOG/#v227-2023-10-03","title":"v2.2.7 (2023-10-03)","text":"<p>This version adds the parameter stoptime to utils.Compare1D2D and makes both starttime and stoptime parameters optional. With these parameters users can crop the section of the results over which statistics will be computed and figures made.</p>"},{"location":"CHANGELOG/#v226-2023-10-01","title":"v2.2.6 (2023-10-01)","text":"<ul> <li>Fixed an issue where irregular station names like <code>MA_67.00Z</code> caused a sorting error in <code>utils.Compare1D2D</code></li> </ul>"},{"location":"CHANGELOG/#v225-2023-07-28","title":"v2.2.5 (2023-07-28)","text":"<ul> <li>FM2PROF now validates the \"SkipMaps\" parameter and throws error if its value is larger than the available number of maps</li> <li>Fixed bug that threw exception if roughness tables could not be produced during finalization step</li> <li>Fixed bug that prevented BranchRules file to be read if multiple empty lines existed at the end of the file</li> <li>Fixed bug where <code>utils.Compare1D2D</code> would throw exception if input netCDF files did not exist, but csv files did. </li> <li>Fixed bug in <code>utils.Compare1D2D</code> where execution failed if a QH relationship could not be produced</li> <li>Statistics are no longer computed on initialization of <code>utils.Compare1D2D</code>. Instead, they are not computed when requested during evaluation. </li> </ul>"},{"location":"CHANGELOG/#v224-2023-07-05","title":"v2.2.4 (2023-07-05)","text":"<ul> <li>Implemented 'onlyFirst' and 'onlyLast' rules for BranchRules file</li> </ul>"},{"location":"CHANGELOG/#v223-2022-12-21","title":"v2.2.3 (2022-12-21)","text":"<ul> <li>Implemented functionality to compare two 1D models for bed level change, Summer dike change and width change</li> </ul>"},{"location":"CHANGELOG/#v222-2022-08-26","title":"v2.2.2 (2022-08-26)","text":""},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>wrong method output type</li> <li>catching wrong exception</li> <li>exception in utils</li> </ul>"},{"location":"CHANGELOG/#v221-2022-08-24","title":"v2.2.1 (2022-08-24)","text":""},{"location":"CHANGELOG/#v220-2022-07-13","title":"v2.2.0 (2022-07-13)","text":""},{"location":"CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>log style now the same as stream, added support for tqdm</li> <li>added cross-section progress to log</li> <li>revised logger style (#34)</li> <li>first figure does not use correct style</li> <li>added 10 cm tolerance to section width correction</li> <li>main section width check</li> <li>output path compare1d2d discharge figure</li> <li>issue 33</li> </ul>"},{"location":"CHANGELOG/#v212-2022-07-05","title":"v2.1.2 (2022-07-05)","text":""},{"location":"CHANGELOG/#v211-2022-07-04","title":"v2.1.1 (2022-07-04)","text":""},{"location":"CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>missing index.rst</li> </ul>"},{"location":"CHANGELOG/#v210-2022-07-04","title":"v2.1.0 (2022-07-04)","text":""},{"location":"CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>macos/linux posixpath fail fix</li> <li>isolated set_locale and wrapped in try/except</li> <li>possibly fix posix path error with trailing whitespace</li> <li>run with ini suffix fix (#29)</li> <li>docs now only build on master</li> </ul>"},{"location":"CHANGELOG/#feat","title":"Feat","text":"<ul> <li>expanded cli</li> <li>groundwork for expansion of cli (#31, #30)</li> <li>overwrite option for output, single output folder (#31)</li> <li>added new tools to utils</li> </ul>"},{"location":"CHANGELOG/#v200-2022-06-28","title":"v2.0.0 (2022-06-28)","text":""},{"location":"CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>IniFile: fixed bug introduced by switching to pathlib</li> <li>output path now relative to config file</li> </ul>"},{"location":"CHANGELOG/#v153-2022-05-27","title":"v1.5.3 (2022-05-27)","text":""},{"location":"CHANGELOG/#fix_5","title":"Fix","text":"<ul> <li>adding cm accuracy to section width check (#23)</li> </ul>"},{"location":"CHANGELOG/#v152-2022-05-27","title":"v1.5.2 (2022-05-27)","text":""},{"location":"CHANGELOG/#fix_6","title":"Fix","text":"<ul> <li>adding cm accuracy to section width check (#23)</li> <li>main section width check</li> <li>fixed bug introduced by earlier fix :p</li> <li>files now relative to config file (#24)</li> </ul>"},{"location":"CHANGELOG/#v151-2022-05-26","title":"v1.5.1 (2022-05-26)","text":""},{"location":"CHANGELOG/#fix_7","title":"Fix","text":"<ul> <li>CrossSection.py: add main section width requirement (#23)</li> </ul>"},{"location":"CHANGELOG/#v150-2022-05-26","title":"v1.5.0 (2022-05-26)","text":""},{"location":"CHANGELOG/#fix_8","title":"Fix","text":"<ul> <li>CrossSection.py: add main section width requirement (#23)</li> <li>sc bug</li> </ul>"},{"location":"CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>cli: new cli with poetry script hook &amp; python -m</li> </ul>"},{"location":"CHANGELOG/#v144-2022-05-03","title":"v1.4.4 (2022-05-03)","text":""},{"location":"CHANGELOG/#fix_9","title":"Fix","text":"<ul> <li>update black to 22.3 (#16)</li> </ul>"},{"location":"CHANGELOG/#v143-2021-11-29","title":"v1.4.3 (2021-11-29)","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"markdown/api/","title":"API","text":"<p>FM2PROF Runner Module.</p> <p>This module provides the main execution engine for FM2PROF, a tool for converting 2D dflowFM model results to 1D cross-sections for hydraulic modelling.</p> <p>FM2PROF (dflowFM to Profile) extracts cross-sectional data from 2D hydrodynamic model outputs and generates 1D model inputs. The main workflow includes:</p> <ol> <li>Initialisation: Load configuration files and validate input data   -. Data Import: Read dflowfm map files and cross-section location files   -. Classification: Assign 2D model points to regions and cross-sections</li> <li>Generation: Create cross-section geometries and roughness tables</li> <li>Finalisation: Write output files in various formats (D-Flow 1D, SOBEK 3, etc.)</li> </ol> <p>Classes:</p> Name Description <code>InitializationError</code> <p>Custom exception for initialisation failures.</p> <code>Fm2ProfRunner</code> <p>Main class that orchestrates the FM2PROF workflow.</p> <code>Project</code> <p>Python API wrapper for programmatic access to FM2PROF functionality.</p> <p>The Project class is auto-imported when using the fm2prof package.</p> Example <p>Basic usage through the Project API:</p> <p>from fm2prof import Project project = Project('config.ini') project.run()</p> <p>Programmatic configuration:</p> <p>project = Project() project.set_input_file('2DMapOutput', 'model_map.nc') project.set_input_file('CrossSectionLocationFile', 'crosssections.csv') project.set_output_directory('./output') project.run()</p> Note <p>This module requires FlowFM map files (NetCDF format) and cross-section location files as input. The output includes 1D model geometry and roughness data suitable for various hydraulic modelling software.</p> License <p>GPL-3.0-or-later AND LGPL-3.0-or-later</p> <p>Region and Section Polygon File Module.</p> <p>This module provides functionality for handling polygon files used in FM2PROF for spatial classification of 2D model data into regions and sections.</p> <p>The module supports GeoJSON format polygon files and provides efficient spatial indexing and point-in-polygon classification algorithms. It handles two main types of polygon files:</p> <ol> <li>Region Polygons: Define geographical regions for grouping cross-sections</li> <li>Section Polygons: Define hydraulic sections (main channel, floodplains)</li> </ol> Key Features <ul> <li>GeoJSON file parsing and validation</li> <li>Spatial indexing using MeshKernel for efficient point classification</li> <li>Overlap detection and validation</li> </ul> <p>Classes:</p> Name Description <code>Polygon</code> <p>Named tuple representing a polygon with geometry and properties.</p> <code>PolygonFile</code> <p>Base class for polygon file handling with classification methods.</p> <code>RegionPolygonFile</code> <p>Specialised class for region polygon files.</p> <code>SectionPolygonFile</code> <p>Specialised class for section polygon files with hydraulic validation.</p> Note <p>Polygon files must be in GeoJSON format with specific property requirements: - Region polygons: require 'name' and 'id' properties - Section polygons: require 'name' and 'section' properties ('main', 'floodplain1', 'floodplain2')</p> <p>Base classes and data containers.</p> <p>Contains functions used for the emulation/reduction of 2D models to 1D models for Delft3D FM (D-Hydro).</p>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner","title":"<code>Fm2ProfRunner(ini_file_path='')</code>","text":"<p>               Bases: <code>FM2ProfBase</code></p> <p>Main class that executes all functionality.</p> <p>Initialize the project.</p> <pre><code>ini_file_path (Path | str): path to configuration file.\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def __init__(self, ini_file_path: Path | str = \"\") -&gt; None:\n    \"\"\"Initialize the project.\n\n    Args:\n    ----\n        ini_file_path (Path | str): path to configuration file.\n\n    \"\"\"\n    self.fm_model_data: FmModelData = None\n    self._output_files: OutputFiles = OutputFiles()\n\n    self.set_logger(self.create_logger())\n\n    ini_file_path = Path(ini_file_path)\n\n    self.start_new_log_task(\"Loading configuration file\")\n    try:\n        self.load_configuration(ini_file_path)\n    except (ConfigurationFileError, FileNotFoundError) as e:\n        self.set_logger_message(f\"Exiting {e}\", \"error\")\n        return\n\n    if not self.get_inifile().has_output_directory:\n        self.set_logger_message(\n            \"Output directory must be set in configuration file\",\n            \"error\",\n        )\n        return\n\n    # Add a log file\n    self.set_logfile(\n        output_dir=self.get_inifile().get_output_directory(),\n        filename=\"fm2prof.log\",\n    )\n\n    self.finish_log_task()\n    # print header to log\n    self._print_header()\n\n    # Print configuration to log\n    self.set_logger_message(self.get_inifile().print_configuration(), header=True)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.create_logger","title":"<code>create_logger()</code>  <code>staticmethod</code>","text":"<p>Create logger instance.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>@staticmethod\ndef create_logger() -&gt; Logger:\n    \"\"\"Create logger instance.\"\"\"\n    # Create logger\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n\n    # create formatter\n    logger.__logformatter = ElapsedFormatter()  # noqa: SLF001\n    logger._Filelogformatter = ElapsedFileFormatter()  # noqa: SLF001\n\n    # create console handler\n    if TqdmLoggingHandler not in map(type, logger.handlers):\n        ch = TqdmLoggingHandler()\n        ch.setLevel(logging.DEBUG)\n        ch.setFormatter(logger.__logformatter)  # noqa: SLF001\n        logger.addHandler(ch)\n\n    return logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.finish_log_task","title":"<code>finish_log_task()</code>","text":"<p>Use this method to finish task.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def finish_log_task(self) -&gt; None:\n    \"\"\"Use this method to finish task.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().finish_task()\n    self.set_logger_message()\n    self.pbar = None\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.get_filelogformatter","title":"<code>get_filelogformatter()</code>","text":"<p>Return  file log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_filelogformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return  file log formatter.\"\"\"\n    return self.get_logger()._Filelogformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.get_inifile","title":"<code>get_inifile()</code>","text":"<p>Get the inifile object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_inifile(self) -&gt; IniFile:\n    \"\"\"Get the inifile object.\"\"\"\n    return self.__iniFile\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.get_logformatter","title":"<code>get_logformatter()</code>","text":"<p>Return log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return log formatter.\"\"\"\n    return self.get_logger().__logformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.get_logger","title":"<code>get_logger()</code>","text":"<p>Use this method to return logger object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logger(self) -&gt; Logger:\n    \"\"\"Use this method to return logger object.\"\"\"\n    return self.__logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.load_configuration","title":"<code>load_configuration(ini_file_path)</code>","text":"<p>Use this method to load a configuration file from path.</p> <p>If no path is given, the default configuration is used.</p> <pre><code>ini_file_path (Path | str): path to configuration file\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def load_configuration(self, ini_file_path: Path) -&gt; None:\n    \"\"\"Use this method to load a configuration file from path.\n\n    If no path is given, the default configuration is used.\n\n    Args:\n    ----\n        ini_file_path (Path | str): path to configuration file\n\n    \"\"\"\n    if not ini_file_path.is_file():\n        self.set_logger_message(\"No ini file path given, using default configuration\", \"warning\")\n        ini_file_object = IniFile(logger=self.get_logger())\n    else:\n        ini_file_object = IniFile(ini_file_path, logger=self.get_logger())\n    self.set_inifile(ini_file_object)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.run","title":"<code>run(*, overwrite=False)</code>","text":"<p>Execute FM2PROF routines.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>if True, overwrites existing output. If False, exits if output detected.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if run was successful, False if errors occurred.</p> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def run(self, *, overwrite: bool = False) -&gt; bool:\n    \"\"\"Execute FM2PROF routines.\n\n    Args:\n        overwrite (bool): if True, overwrites existing output. If False, exits if output detected.\n\n    Returns:\n        bool: True if run was successful, False if errors occurred.\n    \"\"\"\n    if self.get_inifile() is None:\n        self.set_logger_message(\n            \"No ini file was specified: the run cannot go further.\",\n            \"Warning\",\n        )\n        return False\n\n    # Check for already existing output\n    if self._output_exists() and not overwrite:\n        self.set_logger_message(\n            \"Output already exists. Use overwrite option if you want to re-run the program\",\n            \"warning\",\n        )\n        return False\n\n    # Run\n    success = self._run_inifile()\n\n    if not success:\n        self.set_logger_message(\"Program finished with errors\", \"warning\")\n    else:\n        self.set_logger_message(\"Program finished\", \"info\")\n\n    return success\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.set_inifile","title":"<code>set_inifile(inifile=None)</code>","text":"<p>Use this method to set configuration file object.</p> <p>For loading from file, use <code>load_inifile</code> instead</p> <pre><code>inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_inifile(self, inifile: IniFile = None) -&gt; None:\n    \"\"\"Use this method to set configuration file object.\n\n    For loading from file, use ``load_inifile`` instead\n\n    Args:\n    ----\n        inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n\n    \"\"\"\n    self.__iniFile = inifile\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.set_logfile","title":"<code>set_logfile(output_dir, filename='fm2prof.log')</code>","text":"<p>Set log file.</p> <pre><code>output_dir (str): _description_\nfilename (str, optional): _description_. Defaults to \"fm2prof.log\".\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logfile(self, output_dir: str | Path, filename: str = \"fm2prof.log\") -&gt; None:\n    \"\"\"Set log file.\n\n    Args:\n    ----\n        output_dir (str): _description_\n        filename (str, optional): _description_. Defaults to \"fm2prof.log\".\n\n    \"\"\"\n    # create file handler\n    if not output_dir:\n        err_msg = \"output_dir is required.\"\n        raise ValueError(err_msg)\n    fh = logging.FileHandler(Path(output_dir).joinpath(filename), encoding=\"utf-8\")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(self.get_logger()._Filelogformatter)  # noqa: SLF001\n    self.__logger.addHandler(fh)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.set_logger","title":"<code>set_logger(logger)</code>","text":"<p>Use to set logger.</p> <pre><code>logger (Logger): Logger instance\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger(self, logger: Logger) -&gt; None:\n    \"\"\"Use to set logger.\n\n    Args:\n    ----\n        logger (Logger): Logger instance\n\n    \"\"\"\n    if not isinstance(logger, Logger):\n        err_msg = \"logger should be instance of Logger class\"\n        raise TypeError(err_msg)\n    self.__logger = logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.set_logger_message","title":"<code>set_logger_message(err_mssg='', level='info', *, header=False)</code>","text":"<p>Set message to logger if this is set.</p> <pre><code>err_mssg (str, optional): Error message to log. Defaults to \"\".\nlevel (str, optional): Log level. Defaults to \"info\".\nheader (bool, optional): Set error message as header. Defaults to False.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger_message(\n    self,\n    err_mssg: str = \"\",\n    level: str = \"info\",\n    *,\n    header: bool = False,\n) -&gt; None:\n    \"\"\"Set message to logger if this is set.\n\n    Args:\n    ----\n        err_mssg (str, optional): Error message to log. Defaults to \"\".\n        level (str, optional): Log level. Defaults to \"info\".\n        header (bool, optional): Set error message as header. Defaults to False.\n\n    \"\"\"\n    if not self.__logger:\n        return\n\n    if header:\n        self.get_logformatter().set_intro(True)\n        self.get_logger()._Filelogformatter.set_intro(True)  # noqa: SLF001\n    else:\n        self.get_logformatter().set_intro(False)\n        self.get_logger()._Filelogformatter.set_intro(False)  # noqa: SLF001\n\n    if level.lower() not in [\"info\", \"debug\", \"warning\", \"error\", \"critical\"]:\n        err_msg = f\"{level.lower()} is not valid logging level.\"\n        raise ValueError(err_msg)\n\n    if level.lower() == \"info\":\n        self.__logger.info(err_mssg)\n    elif level.lower() == \"debug\":\n        self.__logger.debug(err_mssg)\n    elif level.lower() == \"warning\":\n        self.__logger.warning(err_mssg)\n    elif level.lower() == \"error\":\n        self.__logger.error(err_mssg)\n    elif level.lower() in [\"succes\", \"critical\"]:\n        self.__logger.critical(err_mssg)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Fm2ProfRunner.start_new_log_task","title":"<code>start_new_log_task(task_name='NOT DEFINED', pbar=None)</code>","text":"<p>Use this method to start a new task. Will reset the internal clock.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def start_new_log_task(\n    self,\n    task_name: str = \"NOT DEFINED\",\n    pbar: tqdm.tqdm = None,\n) -&gt; None:\n    \"\"\"Use this method to start a new task. Will reset the internal clock.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().start_new_iteration(pbar=pbar)\n    self.get_filelogformatter().start_new_iteration(pbar=pbar)\n    self.set_logger_message(f\"Starting new task: {task_name}\")\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.InitializationError","title":"<code>InitializationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for initialization errors.</p>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project","title":"<code>Project(ini_file_path='')</code>","text":"<p>               Bases: <code>Fm2ProfRunner</code></p> <p>Provides the python API for running FM2PROF.</p> <p>Instantiate by providing the path to a configuration file</p> <p>Project('/path/to/config.ini')</p> <p>Initialize the project.</p> <pre><code>ini_file_path (Path | str): path to configuration file.\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def __init__(self, ini_file_path: Path | str = \"\") -&gt; None:\n    \"\"\"Initialize the project.\n\n    Args:\n    ----\n        ini_file_path (Path | str): path to configuration file.\n\n    \"\"\"\n    self.fm_model_data: FmModelData = None\n    self._output_files: OutputFiles = OutputFiles()\n\n    self.set_logger(self.create_logger())\n\n    ini_file_path = Path(ini_file_path)\n\n    self.start_new_log_task(\"Loading configuration file\")\n    try:\n        self.load_configuration(ini_file_path)\n    except (ConfigurationFileError, FileNotFoundError) as e:\n        self.set_logger_message(f\"Exiting {e}\", \"error\")\n        return\n\n    if not self.get_inifile().has_output_directory:\n        self.set_logger_message(\n            \"Output directory must be set in configuration file\",\n            \"error\",\n        )\n        return\n\n    # Add a log file\n    self.set_logfile(\n        output_dir=self.get_inifile().get_output_directory(),\n        filename=\"fm2prof.log\",\n    )\n\n    self.finish_log_task()\n    # print header to log\n    self._print_header()\n\n    # Print configuration to log\n    self.set_logger_message(self.get_inifile().print_configuration(), header=True)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.output_files","title":"<code>output_files: Generator[Path, None, None]</code>  <code>property</code>","text":"<p>Get a generator object with the output files.</p> <pre><code>Generator[Path, None, None]: generator of output files.\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.create_logger","title":"<code>create_logger()</code>  <code>staticmethod</code>","text":"<p>Create logger instance.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>@staticmethod\ndef create_logger() -&gt; Logger:\n    \"\"\"Create logger instance.\"\"\"\n    # Create logger\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n\n    # create formatter\n    logger.__logformatter = ElapsedFormatter()  # noqa: SLF001\n    logger._Filelogformatter = ElapsedFileFormatter()  # noqa: SLF001\n\n    # create console handler\n    if TqdmLoggingHandler not in map(type, logger.handlers):\n        ch = TqdmLoggingHandler()\n        ch.setLevel(logging.DEBUG)\n        ch.setFormatter(logger.__logformatter)  # noqa: SLF001\n        logger.addHandler(ch)\n\n    return logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.finish_log_task","title":"<code>finish_log_task()</code>","text":"<p>Use this method to finish task.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def finish_log_task(self) -&gt; None:\n    \"\"\"Use this method to finish task.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().finish_task()\n    self.set_logger_message()\n    self.pbar = None\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.get_filelogformatter","title":"<code>get_filelogformatter()</code>","text":"<p>Return  file log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_filelogformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return  file log formatter.\"\"\"\n    return self.get_logger()._Filelogformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.get_inifile","title":"<code>get_inifile()</code>","text":"<p>Get the inifile object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_inifile(self) -&gt; IniFile:\n    \"\"\"Get the inifile object.\"\"\"\n    return self.__iniFile\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.get_input_file","title":"<code>get_input_file(name)</code>","text":"<p>Use this method to retrieve the path to an input file.</p> <pre><code>name (str): case-insensitive key of the input file (e.g.'2dmapoutput')\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def get_input_file(self, name: str) -&gt; str:\n    \"\"\"Use this method to retrieve the path to an input file.\n\n    Args:\n    ----\n        name (str): case-insensitive key of the input file (e.g.'2dmapoutput')\n\n    \"\"\"\n    return self.get_inifile().get_input_file(name)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.get_logformatter","title":"<code>get_logformatter()</code>","text":"<p>Return log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return log formatter.\"\"\"\n    return self.get_logger().__logformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.get_logger","title":"<code>get_logger()</code>","text":"<p>Use this method to return logger object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logger(self) -&gt; Logger:\n    \"\"\"Use this method to return logger object.\"\"\"\n    return self.__logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.get_output_directory","title":"<code>get_output_directory()</code>","text":"<p>Return the current output directory.</p> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def get_output_directory(self) -&gt; Path:\n    \"\"\"Return the current output directory.\"\"\"\n    return self.get_inifile().get_output_directory()\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.get_parameter","title":"<code>get_parameter(name)</code>","text":"<p>Use this method to get the value of a parameter.</p> <pre><code>name (str): name of the parameter (case insensitive)\n</code></pre> <pre><code>(str | float): The current value of the parameter\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def get_parameter(self, name: str) -&gt; str | float:\n    \"\"\"Use this method to get the value of a parameter.\n\n    Args:\n    ----\n        name (str): name of the parameter (case insensitive)\n\n    Returns:\n    -------\n        (str | float): The current value of the parameter\n\n    \"\"\"\n    return self.get_inifile().get_parameter(name)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.load_configuration","title":"<code>load_configuration(ini_file_path)</code>","text":"<p>Use this method to load a configuration file from path.</p> <p>If no path is given, the default configuration is used.</p> <pre><code>ini_file_path (Path | str): path to configuration file\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def load_configuration(self, ini_file_path: Path) -&gt; None:\n    \"\"\"Use this method to load a configuration file from path.\n\n    If no path is given, the default configuration is used.\n\n    Args:\n    ----\n        ini_file_path (Path | str): path to configuration file\n\n    \"\"\"\n    if not ini_file_path.is_file():\n        self.set_logger_message(\"No ini file path given, using default configuration\", \"warning\")\n        ini_file_object = IniFile(logger=self.get_logger())\n    else:\n        ini_file_object = IniFile(ini_file_path, logger=self.get_logger())\n    self.set_inifile(ini_file_object)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.print_configuration","title":"<code>print_configuration()</code>","text":"<p>Use this method to obtain string representation of the configuration.</p> <p>Use this string to write to file, e.g.:</p> <pre><code>&gt;&gt; with open('EmptyProject.ini', 'w') as f:\n&gt;&gt;     f.write(project.print_configuration())\n</code></pre> <pre><code>(str): string representation of the configuration\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def print_configuration(self) -&gt; str:\n    \"\"\"Use this method to obtain string representation of the configuration.\n\n    Use this string to write to file, e.g.:\n\n        &gt;&gt; with open('EmptyProject.ini', 'w') as f:\n        &gt;&gt;     f.write(project.print_configuration())\n\n    Returns:\n    -------\n        (str): string representation of the configuration\n\n    \"\"\"\n    return self.get_inifile().print_configuration()\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.run","title":"<code>run(*, overwrite=False)</code>","text":"<p>Execute FM2PROF routines.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>if True, overwrites existing output. If False, exits if output detected.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if run was successful, False if errors occurred.</p> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def run(self, *, overwrite: bool = False) -&gt; bool:\n    \"\"\"Execute FM2PROF routines.\n\n    Args:\n        overwrite (bool): if True, overwrites existing output. If False, exits if output detected.\n\n    Returns:\n        bool: True if run was successful, False if errors occurred.\n    \"\"\"\n    if self.get_inifile() is None:\n        self.set_logger_message(\n            \"No ini file was specified: the run cannot go further.\",\n            \"Warning\",\n        )\n        return False\n\n    # Check for already existing output\n    if self._output_exists() and not overwrite:\n        self.set_logger_message(\n            \"Output already exists. Use overwrite option if you want to re-run the program\",\n            \"warning\",\n        )\n        return False\n\n    # Run\n    success = self._run_inifile()\n\n    if not success:\n        self.set_logger_message(\"Program finished with errors\", \"warning\")\n    else:\n        self.set_logger_message(\"Program finished\", \"info\")\n\n    return success\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.set_inifile","title":"<code>set_inifile(inifile=None)</code>","text":"<p>Use this method to set configuration file object.</p> <p>For loading from file, use <code>load_inifile</code> instead</p> <pre><code>inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_inifile(self, inifile: IniFile = None) -&gt; None:\n    \"\"\"Use this method to set configuration file object.\n\n    For loading from file, use ``load_inifile`` instead\n\n    Args:\n    ----\n        inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n\n    \"\"\"\n    self.__iniFile = inifile\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.set_input_file","title":"<code>set_input_file(name, value)</code>","text":"<p>Use this method to set the path to an input file.</p> <pre><code>name: name of the input file in the configuration (case insensitive).\n\nvalue: path to the inputfile\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def set_input_file(self, name: str, value: str | float) -&gt; None:\n    \"\"\"Use this method to set the path to an input file.\n\n    Args:\n    ----\n        name: name of the input file in the configuration (case insensitive).\n\n        value: path to the inputfile\n\n    \"\"\"\n    return self.get_inifile().set_input_file(name, value)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.set_logfile","title":"<code>set_logfile(output_dir, filename='fm2prof.log')</code>","text":"<p>Set log file.</p> <pre><code>output_dir (str): _description_\nfilename (str, optional): _description_. Defaults to \"fm2prof.log\".\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logfile(self, output_dir: str | Path, filename: str = \"fm2prof.log\") -&gt; None:\n    \"\"\"Set log file.\n\n    Args:\n    ----\n        output_dir (str): _description_\n        filename (str, optional): _description_. Defaults to \"fm2prof.log\".\n\n    \"\"\"\n    # create file handler\n    if not output_dir:\n        err_msg = \"output_dir is required.\"\n        raise ValueError(err_msg)\n    fh = logging.FileHandler(Path(output_dir).joinpath(filename), encoding=\"utf-8\")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(self.get_logger()._Filelogformatter)  # noqa: SLF001\n    self.__logger.addHandler(fh)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.set_logger","title":"<code>set_logger(logger)</code>","text":"<p>Use to set logger.</p> <pre><code>logger (Logger): Logger instance\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger(self, logger: Logger) -&gt; None:\n    \"\"\"Use to set logger.\n\n    Args:\n    ----\n        logger (Logger): Logger instance\n\n    \"\"\"\n    if not isinstance(logger, Logger):\n        err_msg = \"logger should be instance of Logger class\"\n        raise TypeError(err_msg)\n    self.__logger = logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.set_logger_message","title":"<code>set_logger_message(err_mssg='', level='info', *, header=False)</code>","text":"<p>Set message to logger if this is set.</p> <pre><code>err_mssg (str, optional): Error message to log. Defaults to \"\".\nlevel (str, optional): Log level. Defaults to \"info\".\nheader (bool, optional): Set error message as header. Defaults to False.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger_message(\n    self,\n    err_mssg: str = \"\",\n    level: str = \"info\",\n    *,\n    header: bool = False,\n) -&gt; None:\n    \"\"\"Set message to logger if this is set.\n\n    Args:\n    ----\n        err_mssg (str, optional): Error message to log. Defaults to \"\".\n        level (str, optional): Log level. Defaults to \"info\".\n        header (bool, optional): Set error message as header. Defaults to False.\n\n    \"\"\"\n    if not self.__logger:\n        return\n\n    if header:\n        self.get_logformatter().set_intro(True)\n        self.get_logger()._Filelogformatter.set_intro(True)  # noqa: SLF001\n    else:\n        self.get_logformatter().set_intro(False)\n        self.get_logger()._Filelogformatter.set_intro(False)  # noqa: SLF001\n\n    if level.lower() not in [\"info\", \"debug\", \"warning\", \"error\", \"critical\"]:\n        err_msg = f\"{level.lower()} is not valid logging level.\"\n        raise ValueError(err_msg)\n\n    if level.lower() == \"info\":\n        self.__logger.info(err_mssg)\n    elif level.lower() == \"debug\":\n        self.__logger.debug(err_mssg)\n    elif level.lower() == \"warning\":\n        self.__logger.warning(err_mssg)\n    elif level.lower() == \"error\":\n        self.__logger.error(err_mssg)\n    elif level.lower() in [\"succes\", \"critical\"]:\n        self.__logger.critical(err_mssg)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.set_output_directory","title":"<code>set_output_directory(path)</code>","text":"<p>Use this method to set the output directory.</p> <p>.. warning::     calling this function will also create the output directory,     if it does not already exists!</p> <pre><code>path (path | str): path to the output path\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def set_output_directory(self, path: str | Path) -&gt; None:\n    \"\"\"Use this method to set the output directory.\n\n    .. warning::\n        calling this function will also create the output directory,\n        if it does not already exists!\n\n    Args:\n    ----\n        path (path | str): path to the output path\n\n    \"\"\"\n    self.get_inifile().set_output_directory(path)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.set_parameter","title":"<code>set_parameter(name, value)</code>","text":"<p>Use this method to set the value of a parameter.</p> <pre><code>name (str): name of the parameter (case insensitive).\n\nvalue (str | float): value of the parameter.\nAn error will be given if the value has the wrong type (e.g. string if int was expected).\n</code></pre> Source code in <code>fm2prof\\fm2prof_runner.py</code> <pre><code>def set_parameter(self, name: str, value: str | float) -&gt; None:\n    \"\"\"Use this method to set the value of a parameter.\n\n    Args:\n    ----\n        name (str): name of the parameter (case insensitive).\n\n        value (str | float): value of the parameter.\n        An error will be given if the value has the wrong type (e.g. string if int was expected).\n\n    \"\"\"\n    self.get_inifile().set_parameter(name, value)\n</code></pre>"},{"location":"markdown/api/#fm2prof.fm2prof_runner.Project.start_new_log_task","title":"<code>start_new_log_task(task_name='NOT DEFINED', pbar=None)</code>","text":"<p>Use this method to start a new task. Will reset the internal clock.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def start_new_log_task(\n    self,\n    task_name: str = \"NOT DEFINED\",\n    pbar: tqdm.tqdm = None,\n) -&gt; None:\n    \"\"\"Use this method to start a new task. Will reset the internal clock.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().start_new_iteration(pbar=pbar)\n    self.get_filelogformatter().start_new_iteration(pbar=pbar)\n    self.set_logger_message(f\"Starting new task: {task_name}\")\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.GridPointsInPolygonResults","title":"<code>GridPointsInPolygonResults</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Named tuple for grid points in polygon results.</p>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon","title":"<code>MultiPolygon(logger)</code>","text":"<p>               Bases: <code>FM2ProfBase</code></p> <p>MultiPolygon file class.</p> <p>This class handles MultiPolygon files used in FM2PROF for spatial classification of 2D model data into regions and sections. It supports GeoJSON format polygon files and provides methods for reading, validating, and classifying points within the polygons.</p> <p>We use a base MultiPolygon class to leverage MeshKernel and Shapely functionality within a common framework. E.g. <code>MultiPolygon.as_meshkernel()</code> outputs a MeshKernel GeometryList object that can be used for spatial classification, while <code>MultiPolygon.as_shapely()</code> outputs a list of Shapely Polygon objects for geometric operations.</p> <p>Not all geojson geometry types are supported:</p> <ul> <li>Only 'Polygon' and 'MultiPolygon' are supported.</li> <li>Polygons with holes are not supported.</li> <li>MultiPolygons with multiple polygons are not supported.</li> <li>Properties must contain a 'name' key-word.</li> <li>Properties must be unique, otherwise overlap checking will produce bugs.</li> <li>SectionPolygon properties must contain a 'section' key-word.</li> <li>RegionPolygon properties must contain a 'region' key-word.</li> </ul> <p>Instantiate a MultiPolygon object.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def __init__(self, logger: Logger) -&gt; None:\n    \"\"\"Instantiate a MultiPolygon object.\"\"\"\n    self.set_logger(logger)\n    self._polygons = []\n    self.undefined = \"undefined\"\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.polygons","title":"<code>polygons: list[Polygon]</code>  <code>property</code> <code>writable</code>","text":"<p>Polygons.</p>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.as_meshkernel","title":"<code>as_meshkernel()</code>","text":"<p>Convert polygons to MeshKernel GeometryList.</p> Note <p>MeshKernel GeometryList supports multiple polygons, separated by some int (default -999). However, to keep track of polygon properties (e.g. name), we create a list of single polygon GeometryList objects.</p> <p>Returns:</p> Name Type Description <code>GeometryList</code> <code>list[GeometryList]</code> <p>MeshKernel GeometryList object containing all polygons.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def as_meshkernel(self) -&gt; list[GeometryList]:\n    \"\"\"Convert polygons to MeshKernel GeometryList.\n\n    Note:\n        MeshKernel GeometryList supports multiple polygons,\n        separated by some int (default -999). However,\n        to keep track of polygon properties (e.g. name),\n        we create a list of single polygon GeometryList objects.\n\n    Returns:\n        GeometryList: MeshKernel GeometryList object containing all polygons.\n    \"\"\"\n    if not self.polygons:\n        err_msg = \"No polygons defined\"\n        raise ValueError(err_msg)\n\n    return [GeometryList(x_coordinates=polygon.x, y_coordinates=polygon.y) for polygon in self.polygons]\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.as_shapely","title":"<code>as_shapely()</code>","text":"<p>Convert polygons to list of Shapely Polygon objects.</p> <p>Returns:</p> Type Description <code>list[Polygon]</code> <p>list[shapely.geometry.Polygon]: List of Shapely Polygon objects.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def as_shapely(self) -&gt; list[shapely.geometry.Polygon]:\n    \"\"\"Convert polygons to list of Shapely Polygon objects.\n\n    Returns:\n        list[shapely.geometry.Polygon]: List of Shapely Polygon objects.\n    \"\"\"\n    if not self.polygons:\n        err_msg = \"No polygons defined\"\n        raise ValueError(err_msg)\n\n    return [shapely.Polygon(polygon.coordinates) for polygon in self.polygons]\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.check_overlap","title":"<code>check_overlap()</code>","text":"<p>Check if polygons overlap and log a warning if they do.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def check_overlap(self) -&gt; None:\n    \"\"\"Check if polygons overlap and log a warning if they do.\"\"\"\n    for i, poly1 in enumerate(self.as_shapely()):\n        for j, poly2 in enumerate(self.as_shapely()):\n            if i == j:\n                # polygon will obviously overlap with itself\n                continue\n            if poly1.intersects(poly2):\n                self.set_logger_message(\n                   f\"{self.polygons[i].properties.get('name')} overlaps {self.polygons[j].properties.get('name')}.\",\n                   level=\"warning\",\n                )\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.create_logger","title":"<code>create_logger()</code>  <code>staticmethod</code>","text":"<p>Create logger instance.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>@staticmethod\ndef create_logger() -&gt; Logger:\n    \"\"\"Create logger instance.\"\"\"\n    # Create logger\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n\n    # create formatter\n    logger.__logformatter = ElapsedFormatter()  # noqa: SLF001\n    logger._Filelogformatter = ElapsedFileFormatter()  # noqa: SLF001\n\n    # create console handler\n    if TqdmLoggingHandler not in map(type, logger.handlers):\n        ch = TqdmLoggingHandler()\n        ch.setLevel(logging.DEBUG)\n        ch.setFormatter(logger.__logformatter)  # noqa: SLF001\n        logger.addHandler(ch)\n\n    return logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.finish_log_task","title":"<code>finish_log_task()</code>","text":"<p>Use this method to finish task.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def finish_log_task(self) -&gt; None:\n    \"\"\"Use this method to finish task.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().finish_task()\n    self.set_logger_message()\n    self.pbar = None\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.from_file","title":"<code>from_file(file_path)</code>","text":"<p>Read data from geojson file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>path to geojson file</p> required Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def from_file(self, file_path: Path | str) -&gt; None:\n    \"\"\"Read data from geojson file.\n\n    Args:\n        file_path (Path | str): path to geojson file\n    \"\"\"\n    self._validate_extension(file_path)\n\n    if Path(file_path).exists() is False:\n        err_msg = \"Polygon file does not exist\"\n        raise FileNotFoundError(err_msg)\n\n    with Path(file_path).open(\"r\") as geojson_file:\n        try:\n            geojson_data = json.load(geojson_file).get(\"features\")\n        except json.JSONDecodeError as e:\n            err_msg = f\"Error decoding JSON from {file_path}: {e}\"\n            raise PolygonError(err_msg) from e\n\n    if not geojson_data:\n        err_msg = \"Polygon file has no features\"\n        raise PolygonError(err_msg)\n\n    self.polygons = self._polygons_from_geojson_data(geojson_data)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.get_filelogformatter","title":"<code>get_filelogformatter()</code>","text":"<p>Return  file log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_filelogformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return  file log formatter.\"\"\"\n    return self.get_logger()._Filelogformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.get_gridpoints_in_polygon","title":"<code>get_gridpoints_in_polygon(res_file, *, property_name, force_cache_invalidation=False)</code>","text":"<p>Method to get faces and edges in region.</p> <p>This method performs caching of the in-polygon classification results to avoid recalculating if the region file has not changed. The cache is invalidated if the region file is modified or if <code>force_cache_invalidation</code> is set to <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>res_file</code> <code>str | Path</code> <p>path to result (map) netcdf file.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification.</p> required <code>force_cache_invalidation</code> <code>bool</code> <p>Force cache invalidation even if region file has not changed.</p> <code>False</code> <p>Returns:</p> Type Description <code>GridPointsInPolygonResults</code> <p>GridPointsInPolygonResults</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def get_gridpoints_in_polygon(self,\n    res_file: str | Path,\n    *,\n    property_name: Literal[\"region\", \"section\"],\n    force_cache_invalidation: bool = False) -&gt; GridPointsInPolygonResults:\n    \"\"\"Method to get faces and edges in region.\n\n    This method performs caching of the in-polygon classification results\n    to avoid recalculating if the region file has not changed. The cache\n    is invalidated if the region file is modified or if `force_cache_invalidation`\n    is set to `True`.\n\n    Args:\n        res_file (str | Path): path to result (map) netcdf file.\n        property_name (Literal[\"region\", \"section\"]): Property to use for classification.\n        force_cache_invalidation (bool): Force cache invalidation even if region file has not changed.\n\n    Returns:\n        GridPointsInPolygonResults\n    \"\"\"\n    # get metadata of file path to determine if the in-polygon classification needs\n    # to be rerun\n    meta = {\"last_modified\": res_file.stat().st_mtime,\n            \"file_size\": res_file.stat().st_size}\n\n    # check if cache file exists and is valid\n    cache_file = Path(res_file).with_suffix(f\".{property_name}_cache.json\")\n    if cache_file.exists() and not force_cache_invalidation:\n        # read cache file\n        self.set_logger_message(\"Found cached regions, reading...\", level=\"info\")\n        meta_cache, faces_in_polygon, edges_in_polygon = self._load_cache(cache_file)\n        if meta == meta_cache:\n            self.set_logger_message(\"Using cached regions\", level=\"info\")\n            return GridPointsInPolygonResults(faces_in_polygon=faces_in_polygon, edges_in_polygon=edges_in_polygon)\n        self.set_logger_message(\"Cached regions are stale\", level=\"warning\")\n        faces_in_polygon = self.meshkernel_inpolygon(res_file, dtype=\"face\", property_name=property_name)\n        edges_in_polygon = self.meshkernel_inpolygon(res_file, dtype=\"edge\", property_name=property_name)\n        self._write_cache(cache_file, meta, faces_in_polygon, edges_in_polygon)\n    elif cache_file.exists() and force_cache_invalidation:\n        self.set_logger_message(\"Forcing recalculating region cache\", level=\"info\")\n        cache_file.unlink()\n        faces_in_polygon = self.meshkernel_inpolygon(res_file, dtype=\"face\", property_name=property_name)\n        edges_in_polygon = self.meshkernel_inpolygon(res_file, dtype=\"edge\", property_name=property_name)\n        self._write_cache(cache_file, meta, faces_in_polygon, edges_in_polygon)\n    elif not cache_file.exists():\n        faces_in_polygon = self.meshkernel_inpolygon(res_file, dtype=\"face\", property_name=property_name)\n        edges_in_polygon = self.meshkernel_inpolygon(res_file, dtype=\"edge\", property_name=property_name)\n        self._write_cache(cache_file, meta, faces_in_polygon, edges_in_polygon)\n\n    return GridPointsInPolygonResults(faces_in_polygon=faces_in_polygon, edges_in_polygon=edges_in_polygon)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.get_inifile","title":"<code>get_inifile()</code>","text":"<p>Get the inifile object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_inifile(self) -&gt; IniFile:\n    \"\"\"Get the inifile object.\"\"\"\n    return self.__iniFile\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.get_logformatter","title":"<code>get_logformatter()</code>","text":"<p>Return log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return log formatter.\"\"\"\n    return self.get_logger().__logformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.get_logger","title":"<code>get_logger()</code>","text":"<p>Use this method to return logger object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logger(self) -&gt; Logger:\n    \"\"\"Use this method to return logger object.\"\"\"\n    return self.__logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.get_points_in_polygon","title":"<code>get_points_in_polygon(points, property_name)</code>","text":"<p>Method to determine in which polygon input points are.</p> Warning <p>This method is not applicable for large number of points. Only use for small number of points (e.g. cross-section locations).</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Array of shape (n_points, 2) containing x,y coordinates of points to classify.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of polygon names in which the points are located. If a point is not located        in any polygon, it is classified as 'undefined'.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def get_points_in_polygon(self, points: np.ndarray, property_name: Literal[\"region\", \"section\"]) -&gt; list[str]:\n    \"\"\"Method to determine in which polygon input points are.\n\n    Warning:\n        This method is not applicable for large number of points.\n        Only use for small number of points (e.g. cross-section locations).\n\n    Args:\n        points (np.ndarray): Array of shape (n_points, 2) containing x,y coordinates of points to classify.\n        property_name (Literal['region', 'section']): Property to use for classification.\n\n    Returns:\n        list[str]: List of polygon names in which the points are located. If a point is not located\n                   in any polygon, it is classified as 'undefined'.\n    \"\"\"\n    # Convert to shapely point\n    points = [shapely.Point(xy) for xy in points]\n    points_regions = [self.undefined] * len(points)\n\n    # Assign point to region\n    for i, point in enumerate(points):\n        for j, polygon in enumerate(self.as_shapely()):\n            if point.within(polygon):\n                points_regions[i] = self.polygons[j].properties.get(property_name)\n                break\n\n    return points_regions\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.meshkernel_inpolygon","title":"<code>meshkernel_inpolygon(res_file, dtype, property_name)</code>","text":"<p>Get grid points in polygon.</p> <p>Parameters:</p> Name Type Description Default <code>res_file</code> <code>str | Path</code> <p>Path to result (map) netcdf file.</p> required <code>dtype</code> <code>Literal['face', 'edge', 'node']</code> <p>Type of grid points to retrieve.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>pd.DataFrame | dict: DataFrame or dictionary containing grid points in polygon.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def meshkernel_inpolygon(self,\n    res_file: str | Path,  # path to result (map) netcdf file\n    dtype: Literal[\"face\", \"edge\", \"node\"],\n    property_name: Literal[\"region\", \"section\"],\n    ) -&gt; list[str]:\n    \"\"\"Get grid points in polygon.\n\n    Args:\n        res_file (str | Path): Path to result (map) netcdf file.\n        dtype (Literal[\"face\", \"edge\", \"node\"]): Type of grid points to retrieve.\n        property_name (Literal[\"region\", \"section\"]): Property to use for classification.\n\n    Returns:\n        pd.DataFrame | dict: DataFrame or dictionary containing grid points in polygon.\n    \"\"\"\n    # Step 1\n    # Construct Meshkernel grid\n    mk = MeshKernel(projection=ProjectionType.CARTESIAN)\n    mesh2d_input = mk.mesh2d_get()\n\n    fmdata = FMDataImporter(res_file)\n    mesh2d_input.node_x = fmdata.get_variable(\"mesh2d_node_x\")\n    mesh2d_input.node_y = fmdata.get_variable(\"mesh2d_node_y\")\n    mesh2d_input.edge_nodes = fmdata.get_variable(\"mesh2d_edge_nodes\").flatten() - 1\n\n    mk.mesh2d_set(mesh2d_input)\n\n    # Step 2: perform point-in-polygon classification\n    nodes_in_polygon: list[str] = [self.undefined] * len(mesh2d_input.node_x)  # default to undefined\n\n    for i, mk_polygon in enumerate(self.as_meshkernel()):\n        self.set_logger_message(\n            f\"  | Classifying {dtype}s in polygon {self.polygons[i].properties.get('name')} \"\n            f\"({i+1}/{len(self.polygons)})\",\n            level=\"info\")\n        indices: list[float] = mk.mesh2d_get_nodes_in_polygons(mk_polygon, inside=True).tolist()\n        for j in indices:\n            nodes_in_polygon[j] = self.polygons[i].properties.get(property_name)\n\n    # Step 3: map to faces or edges if needed\n    if dtype == \"node\":\n        output = nodes_in_polygon\n    elif dtype == \"face\":\n        face_map: np.ndarray = fmdata.get_variable(\"mesh2d_face_nodes\").T[0] -1\n        node_to_face: list[str] = [self.undefined] * len(face_map)\n        for face_index, map_index in enumerate(face_map.tolist()):\n            node_to_face[int(face_index)] = nodes_in_polygon[int(map_index)]\n        output = node_to_face\n    elif dtype == \"edge\":\n        # only internal edges!\n        internal_edges = fmdata.get_variable(\"mesh2d_edge_type\")[:] == 1\n        edge_map: np.ndarray = fmdata.get_variable(\"mesh2d_edge_nodes\").T[0] -1\n        edge_map = edge_map[internal_edges]\n        node_to_edge: list[str] = [self.undefined] * len(edge_map)\n        for edge_index, map_index in enumerate(edge_map.tolist()):\n            node_to_edge[int(edge_index)] = nodes_in_polygon[int(map_index)]\n        output = node_to_edge\n\n    return output\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.set_inifile","title":"<code>set_inifile(inifile=None)</code>","text":"<p>Use this method to set configuration file object.</p> <p>For loading from file, use <code>load_inifile</code> instead</p> <pre><code>inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_inifile(self, inifile: IniFile = None) -&gt; None:\n    \"\"\"Use this method to set configuration file object.\n\n    For loading from file, use ``load_inifile`` instead\n\n    Args:\n    ----\n        inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n\n    \"\"\"\n    self.__iniFile = inifile\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.set_logfile","title":"<code>set_logfile(output_dir, filename='fm2prof.log')</code>","text":"<p>Set log file.</p> <pre><code>output_dir (str): _description_\nfilename (str, optional): _description_. Defaults to \"fm2prof.log\".\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logfile(self, output_dir: str | Path, filename: str = \"fm2prof.log\") -&gt; None:\n    \"\"\"Set log file.\n\n    Args:\n    ----\n        output_dir (str): _description_\n        filename (str, optional): _description_. Defaults to \"fm2prof.log\".\n\n    \"\"\"\n    # create file handler\n    if not output_dir:\n        err_msg = \"output_dir is required.\"\n        raise ValueError(err_msg)\n    fh = logging.FileHandler(Path(output_dir).joinpath(filename), encoding=\"utf-8\")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(self.get_logger()._Filelogformatter)  # noqa: SLF001\n    self.__logger.addHandler(fh)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.set_logger","title":"<code>set_logger(logger)</code>","text":"<p>Use to set logger.</p> <pre><code>logger (Logger): Logger instance\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger(self, logger: Logger) -&gt; None:\n    \"\"\"Use to set logger.\n\n    Args:\n    ----\n        logger (Logger): Logger instance\n\n    \"\"\"\n    if not isinstance(logger, Logger):\n        err_msg = \"logger should be instance of Logger class\"\n        raise TypeError(err_msg)\n    self.__logger = logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.set_logger_message","title":"<code>set_logger_message(err_mssg='', level='info', *, header=False)</code>","text":"<p>Set message to logger if this is set.</p> <pre><code>err_mssg (str, optional): Error message to log. Defaults to \"\".\nlevel (str, optional): Log level. Defaults to \"info\".\nheader (bool, optional): Set error message as header. Defaults to False.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger_message(\n    self,\n    err_mssg: str = \"\",\n    level: str = \"info\",\n    *,\n    header: bool = False,\n) -&gt; None:\n    \"\"\"Set message to logger if this is set.\n\n    Args:\n    ----\n        err_mssg (str, optional): Error message to log. Defaults to \"\".\n        level (str, optional): Log level. Defaults to \"info\".\n        header (bool, optional): Set error message as header. Defaults to False.\n\n    \"\"\"\n    if not self.__logger:\n        return\n\n    if header:\n        self.get_logformatter().set_intro(True)\n        self.get_logger()._Filelogformatter.set_intro(True)  # noqa: SLF001\n    else:\n        self.get_logformatter().set_intro(False)\n        self.get_logger()._Filelogformatter.set_intro(False)  # noqa: SLF001\n\n    if level.lower() not in [\"info\", \"debug\", \"warning\", \"error\", \"critical\"]:\n        err_msg = f\"{level.lower()} is not valid logging level.\"\n        raise ValueError(err_msg)\n\n    if level.lower() == \"info\":\n        self.__logger.info(err_mssg)\n    elif level.lower() == \"debug\":\n        self.__logger.debug(err_mssg)\n    elif level.lower() == \"warning\":\n        self.__logger.warning(err_mssg)\n    elif level.lower() == \"error\":\n        self.__logger.error(err_mssg)\n    elif level.lower() in [\"succes\", \"critical\"]:\n        self.__logger.critical(err_mssg)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.MultiPolygon.start_new_log_task","title":"<code>start_new_log_task(task_name='NOT DEFINED', pbar=None)</code>","text":"<p>Use this method to start a new task. Will reset the internal clock.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def start_new_log_task(\n    self,\n    task_name: str = \"NOT DEFINED\",\n    pbar: tqdm.tqdm = None,\n) -&gt; None:\n    \"\"\"Use this method to start a new task. Will reset the internal clock.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().start_new_iteration(pbar=pbar)\n    self.get_filelogformatter().start_new_iteration(pbar=pbar)\n    self.set_logger_message(f\"Starting new task: {task_name}\")\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.Polygon","title":"<code>Polygon(coordinates, properties)</code>","text":"<p>Polygon class.</p> <p>This class represents a single polygon with its geometry and properties. It is used by the MultiPolygon class to store individual polygons.</p> <p>Attributes:</p> Name Type Description <code>coordinates</code> <code>list[list[float]]</code> <p>List of [x, y] coordinates defining the polygon.</p> <code>properties</code> <code>dict</code> <p>Dictionary of properties associated with the polygon.</p> <p>Instantiate a Polygon object.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>list[list[float]]</code> <p>List of [x, y] coordinates defining the polygon.</p> required <code>properties</code> <code>dict</code> <p>Dictionary of properties associated with the polygon.</p> required Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def __init__(self, coordinates: list[list[float]], properties: dict) -&gt; None:\n    \"\"\"Instantiate a Polygon object.\n\n    Args:\n        coordinates (list[list[float]]): List of [x, y] coordinates defining the polygon.\n        properties (dict): Dictionary of properties associated with the polygon.\n    \"\"\"\n    self.coordinates = coordinates\n    self.properties = properties\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.Polygon.x","title":"<code>x: list[float]</code>  <code>property</code>","text":"<p>X coordinates of the polygon.</p>"},{"location":"markdown/api/#fm2prof.polygon_file.Polygon.y","title":"<code>y: list[float]</code>  <code>property</code>","text":"<p>Y coordinates of the polygon.</p>"},{"location":"markdown/api/#fm2prof.polygon_file.PolygonError","title":"<code>PolygonError(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for polygon errors.</p> <p>Initialize PolygonError with a message.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize PolygonError with a message.\"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon","title":"<code>RegionPolygon(region_file_path, logger, default_value='undefined')</code>","text":"<p>               Bases: <code>MultiPolygon</code></p> <p>RegionPolygonFile class.</p> <p>Instantiate a RegionPolygonFile object.</p> <p>Parameters:</p> Name Type Description Default <code>region_file_path</code> <code>str | Path</code> <p>path to region polygon file.</p> required <code>logger</code> <code>Logger</code> <p>logger</p> required <code>default_value</code> <code>str</code> <p>default region name to use in cells not covered by a region polygon</p> <code>'undefined'</code> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def __init__(self, region_file_path: str | Path, logger: Logger, default_value: str=\"undefined\") -&gt; None:\n    \"\"\"Instantiate a RegionPolygonFile object.\n\n    Args:\n        region_file_path (str | Path): path to region polygon file.\n        logger (Logger): logger\n        default_value (str): default region name to use in cells not covered by a region polygon\n    \"\"\"\n    super().__init__(logger)\n    try:\n        self.from_file(region_file_path)\n    except TypeError as e:\n        err_msg = f\"Potentially invalid geojson file: {e}\"\n        self.set_logger_message(err_msg, level=\"error\")\n        raise PolygonError(err_msg) from e\n\n    self.undefined = default_value\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.polygons","title":"<code>polygons: list[Polygon]</code>  <code>property</code> <code>writable</code>","text":"<p>Polygons.</p>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.regions","title":"<code>regions: list[Polygon]</code>  <code>property</code>","text":"<p>Region polygons.</p>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.as_meshkernel","title":"<code>as_meshkernel()</code>","text":"<p>Convert polygons to MeshKernel GeometryList.</p> Note <p>MeshKernel GeometryList supports multiple polygons, separated by some int (default -999). However, to keep track of polygon properties (e.g. name), we create a list of single polygon GeometryList objects.</p> <p>Returns:</p> Name Type Description <code>GeometryList</code> <code>list[GeometryList]</code> <p>MeshKernel GeometryList object containing all polygons.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def as_meshkernel(self) -&gt; list[GeometryList]:\n    \"\"\"Convert polygons to MeshKernel GeometryList.\n\n    Note:\n        MeshKernel GeometryList supports multiple polygons,\n        separated by some int (default -999). However,\n        to keep track of polygon properties (e.g. name),\n        we create a list of single polygon GeometryList objects.\n\n    Returns:\n        GeometryList: MeshKernel GeometryList object containing all polygons.\n    \"\"\"\n    if not self.polygons:\n        err_msg = \"No polygons defined\"\n        raise ValueError(err_msg)\n\n    return [GeometryList(x_coordinates=polygon.x, y_coordinates=polygon.y) for polygon in self.polygons]\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.as_shapely","title":"<code>as_shapely()</code>","text":"<p>Convert polygons to list of Shapely Polygon objects.</p> <p>Returns:</p> Type Description <code>list[Polygon]</code> <p>list[shapely.geometry.Polygon]: List of Shapely Polygon objects.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def as_shapely(self) -&gt; list[shapely.geometry.Polygon]:\n    \"\"\"Convert polygons to list of Shapely Polygon objects.\n\n    Returns:\n        list[shapely.geometry.Polygon]: List of Shapely Polygon objects.\n    \"\"\"\n    if not self.polygons:\n        err_msg = \"No polygons defined\"\n        raise ValueError(err_msg)\n\n    return [shapely.Polygon(polygon.coordinates) for polygon in self.polygons]\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.check_overlap","title":"<code>check_overlap()</code>","text":"<p>Check if polygons overlap and log a warning if they do.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def check_overlap(self) -&gt; None:\n    \"\"\"Check if polygons overlap and log a warning if they do.\"\"\"\n    for i, poly1 in enumerate(self.as_shapely()):\n        for j, poly2 in enumerate(self.as_shapely()):\n            if i == j:\n                # polygon will obviously overlap with itself\n                continue\n            if poly1.intersects(poly2):\n                self.set_logger_message(\n                   f\"{self.polygons[i].properties.get('name')} overlaps {self.polygons[j].properties.get('name')}.\",\n                   level=\"warning\",\n                )\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.create_logger","title":"<code>create_logger()</code>  <code>staticmethod</code>","text":"<p>Create logger instance.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>@staticmethod\ndef create_logger() -&gt; Logger:\n    \"\"\"Create logger instance.\"\"\"\n    # Create logger\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n\n    # create formatter\n    logger.__logformatter = ElapsedFormatter()  # noqa: SLF001\n    logger._Filelogformatter = ElapsedFileFormatter()  # noqa: SLF001\n\n    # create console handler\n    if TqdmLoggingHandler not in map(type, logger.handlers):\n        ch = TqdmLoggingHandler()\n        ch.setLevel(logging.DEBUG)\n        ch.setFormatter(logger.__logformatter)  # noqa: SLF001\n        logger.addHandler(ch)\n\n    return logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.finish_log_task","title":"<code>finish_log_task()</code>","text":"<p>Use this method to finish task.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def finish_log_task(self) -&gt; None:\n    \"\"\"Use this method to finish task.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().finish_task()\n    self.set_logger_message()\n    self.pbar = None\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.from_file","title":"<code>from_file(file_path)</code>","text":"<p>Read geojson file and performs validation.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>region file path</p> required Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def from_file(self, file_path: Path | str) -&gt; None:\n    \"\"\"Read geojson file and performs validation.\n\n    Args:\n        file_path (Path | str): region file path\n\n    \"\"\"\n    super().from_file(file_path)\n    self._validate_regions()\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.get_filelogformatter","title":"<code>get_filelogformatter()</code>","text":"<p>Return  file log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_filelogformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return  file log formatter.\"\"\"\n    return self.get_logger()._Filelogformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.get_gridpoints_in_polygon","title":"<code>get_gridpoints_in_polygon(res_file, *, property_name='region', force_cache_invalidation=False)</code>","text":"<p>Method to get faces and edges in region.</p> <p>This method performs caching of the in-polygon classification results to avoid recalculating if the region file has not changed. The cache is invalidated if the region file is modified or if <code>force_cache_invalidation</code> is set to <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>res_file</code> <code>str | Path</code> <p>path to result (map) netcdf file.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification. Defaults to region</p> <code>'region'</code> <code>force_cache_invalidation</code> <code>bool</code> <p>Force cache invalidation even if region file has not changed.</p> <code>False</code> <p>Returns:</p> Type Description <code>GridPointsInPolygonResults</code> <p>GridPointsInPolygonResults</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def get_gridpoints_in_polygon(self,\n    res_file: str | Path,\n    *,\n    property_name: Literal[\"region\", \"section\"]=\"region\",\n    force_cache_invalidation:bool=False) -&gt; GridPointsInPolygonResults:\n    \"\"\"Method to get faces and edges in region.\n\n    This method performs caching of the in-polygon classification results\n    to avoid recalculating if the region file has not changed. The cache\n    is invalidated if the region file is modified or if `force_cache_invalidation`\n    is set to `True`.\n\n    Args:\n        res_file (str | Path): path to result (map) netcdf file.\n        property_name (Literal[\"region\", \"section\"]): Property to use for classification. Defaults to region\n        force_cache_invalidation (bool): Force cache invalidation even if region file has not changed.\n\n    Returns:\n        GridPointsInPolygonResults\n    \"\"\"\n    return super().get_gridpoints_in_polygon(res_file,\n                                          property_name=property_name,\n                                          force_cache_invalidation=force_cache_invalidation)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.get_inifile","title":"<code>get_inifile()</code>","text":"<p>Get the inifile object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_inifile(self) -&gt; IniFile:\n    \"\"\"Get the inifile object.\"\"\"\n    return self.__iniFile\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.get_logformatter","title":"<code>get_logformatter()</code>","text":"<p>Return log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return log formatter.\"\"\"\n    return self.get_logger().__logformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.get_logger","title":"<code>get_logger()</code>","text":"<p>Use this method to return logger object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logger(self) -&gt; Logger:\n    \"\"\"Use this method to return logger object.\"\"\"\n    return self.__logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.get_points_in_polygon","title":"<code>get_points_in_polygon(points, property_name)</code>","text":"<p>Method to determine in which polygon input points are.</p> Warning <p>This method is not applicable for large number of points. Only use for small number of points (e.g. cross-section locations).</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Array of shape (n_points, 2) containing x,y coordinates of points to classify.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of polygon names in which the points are located. If a point is not located        in any polygon, it is classified as 'undefined'.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def get_points_in_polygon(self, points: np.ndarray, property_name: Literal[\"region\", \"section\"]) -&gt; list[str]:\n    \"\"\"Method to determine in which polygon input points are.\n\n    Warning:\n        This method is not applicable for large number of points.\n        Only use for small number of points (e.g. cross-section locations).\n\n    Args:\n        points (np.ndarray): Array of shape (n_points, 2) containing x,y coordinates of points to classify.\n        property_name (Literal['region', 'section']): Property to use for classification.\n\n    Returns:\n        list[str]: List of polygon names in which the points are located. If a point is not located\n                   in any polygon, it is classified as 'undefined'.\n    \"\"\"\n    # Convert to shapely point\n    points = [shapely.Point(xy) for xy in points]\n    points_regions = [self.undefined] * len(points)\n\n    # Assign point to region\n    for i, point in enumerate(points):\n        for j, polygon in enumerate(self.as_shapely()):\n            if point.within(polygon):\n                points_regions[i] = self.polygons[j].properties.get(property_name)\n                break\n\n    return points_regions\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.meshkernel_inpolygon","title":"<code>meshkernel_inpolygon(res_file, dtype, property_name)</code>","text":"<p>Get grid points in polygon.</p> <p>Parameters:</p> Name Type Description Default <code>res_file</code> <code>str | Path</code> <p>Path to result (map) netcdf file.</p> required <code>dtype</code> <code>Literal['face', 'edge', 'node']</code> <p>Type of grid points to retrieve.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>pd.DataFrame | dict: DataFrame or dictionary containing grid points in polygon.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def meshkernel_inpolygon(self,\n    res_file: str | Path,  # path to result (map) netcdf file\n    dtype: Literal[\"face\", \"edge\", \"node\"],\n    property_name: Literal[\"region\", \"section\"],\n    ) -&gt; list[str]:\n    \"\"\"Get grid points in polygon.\n\n    Args:\n        res_file (str | Path): Path to result (map) netcdf file.\n        dtype (Literal[\"face\", \"edge\", \"node\"]): Type of grid points to retrieve.\n        property_name (Literal[\"region\", \"section\"]): Property to use for classification.\n\n    Returns:\n        pd.DataFrame | dict: DataFrame or dictionary containing grid points in polygon.\n    \"\"\"\n    # Step 1\n    # Construct Meshkernel grid\n    mk = MeshKernel(projection=ProjectionType.CARTESIAN)\n    mesh2d_input = mk.mesh2d_get()\n\n    fmdata = FMDataImporter(res_file)\n    mesh2d_input.node_x = fmdata.get_variable(\"mesh2d_node_x\")\n    mesh2d_input.node_y = fmdata.get_variable(\"mesh2d_node_y\")\n    mesh2d_input.edge_nodes = fmdata.get_variable(\"mesh2d_edge_nodes\").flatten() - 1\n\n    mk.mesh2d_set(mesh2d_input)\n\n    # Step 2: perform point-in-polygon classification\n    nodes_in_polygon: list[str] = [self.undefined] * len(mesh2d_input.node_x)  # default to undefined\n\n    for i, mk_polygon in enumerate(self.as_meshkernel()):\n        self.set_logger_message(\n            f\"  | Classifying {dtype}s in polygon {self.polygons[i].properties.get('name')} \"\n            f\"({i+1}/{len(self.polygons)})\",\n            level=\"info\")\n        indices: list[float] = mk.mesh2d_get_nodes_in_polygons(mk_polygon, inside=True).tolist()\n        for j in indices:\n            nodes_in_polygon[j] = self.polygons[i].properties.get(property_name)\n\n    # Step 3: map to faces or edges if needed\n    if dtype == \"node\":\n        output = nodes_in_polygon\n    elif dtype == \"face\":\n        face_map: np.ndarray = fmdata.get_variable(\"mesh2d_face_nodes\").T[0] -1\n        node_to_face: list[str] = [self.undefined] * len(face_map)\n        for face_index, map_index in enumerate(face_map.tolist()):\n            node_to_face[int(face_index)] = nodes_in_polygon[int(map_index)]\n        output = node_to_face\n    elif dtype == \"edge\":\n        # only internal edges!\n        internal_edges = fmdata.get_variable(\"mesh2d_edge_type\")[:] == 1\n        edge_map: np.ndarray = fmdata.get_variable(\"mesh2d_edge_nodes\").T[0] -1\n        edge_map = edge_map[internal_edges]\n        node_to_edge: list[str] = [self.undefined] * len(edge_map)\n        for edge_index, map_index in enumerate(edge_map.tolist()):\n            node_to_edge[int(edge_index)] = nodes_in_polygon[int(map_index)]\n        output = node_to_edge\n\n    return output\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.set_inifile","title":"<code>set_inifile(inifile=None)</code>","text":"<p>Use this method to set configuration file object.</p> <p>For loading from file, use <code>load_inifile</code> instead</p> <pre><code>inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_inifile(self, inifile: IniFile = None) -&gt; None:\n    \"\"\"Use this method to set configuration file object.\n\n    For loading from file, use ``load_inifile`` instead\n\n    Args:\n    ----\n        inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n\n    \"\"\"\n    self.__iniFile = inifile\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.set_logfile","title":"<code>set_logfile(output_dir, filename='fm2prof.log')</code>","text":"<p>Set log file.</p> <pre><code>output_dir (str): _description_\nfilename (str, optional): _description_. Defaults to \"fm2prof.log\".\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logfile(self, output_dir: str | Path, filename: str = \"fm2prof.log\") -&gt; None:\n    \"\"\"Set log file.\n\n    Args:\n    ----\n        output_dir (str): _description_\n        filename (str, optional): _description_. Defaults to \"fm2prof.log\".\n\n    \"\"\"\n    # create file handler\n    if not output_dir:\n        err_msg = \"output_dir is required.\"\n        raise ValueError(err_msg)\n    fh = logging.FileHandler(Path(output_dir).joinpath(filename), encoding=\"utf-8\")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(self.get_logger()._Filelogformatter)  # noqa: SLF001\n    self.__logger.addHandler(fh)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.set_logger","title":"<code>set_logger(logger)</code>","text":"<p>Use to set logger.</p> <pre><code>logger (Logger): Logger instance\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger(self, logger: Logger) -&gt; None:\n    \"\"\"Use to set logger.\n\n    Args:\n    ----\n        logger (Logger): Logger instance\n\n    \"\"\"\n    if not isinstance(logger, Logger):\n        err_msg = \"logger should be instance of Logger class\"\n        raise TypeError(err_msg)\n    self.__logger = logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.set_logger_message","title":"<code>set_logger_message(err_mssg='', level='info', *, header=False)</code>","text":"<p>Set message to logger if this is set.</p> <pre><code>err_mssg (str, optional): Error message to log. Defaults to \"\".\nlevel (str, optional): Log level. Defaults to \"info\".\nheader (bool, optional): Set error message as header. Defaults to False.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger_message(\n    self,\n    err_mssg: str = \"\",\n    level: str = \"info\",\n    *,\n    header: bool = False,\n) -&gt; None:\n    \"\"\"Set message to logger if this is set.\n\n    Args:\n    ----\n        err_mssg (str, optional): Error message to log. Defaults to \"\".\n        level (str, optional): Log level. Defaults to \"info\".\n        header (bool, optional): Set error message as header. Defaults to False.\n\n    \"\"\"\n    if not self.__logger:\n        return\n\n    if header:\n        self.get_logformatter().set_intro(True)\n        self.get_logger()._Filelogformatter.set_intro(True)  # noqa: SLF001\n    else:\n        self.get_logformatter().set_intro(False)\n        self.get_logger()._Filelogformatter.set_intro(False)  # noqa: SLF001\n\n    if level.lower() not in [\"info\", \"debug\", \"warning\", \"error\", \"critical\"]:\n        err_msg = f\"{level.lower()} is not valid logging level.\"\n        raise ValueError(err_msg)\n\n    if level.lower() == \"info\":\n        self.__logger.info(err_mssg)\n    elif level.lower() == \"debug\":\n        self.__logger.debug(err_mssg)\n    elif level.lower() == \"warning\":\n        self.__logger.warning(err_mssg)\n    elif level.lower() == \"error\":\n        self.__logger.error(err_mssg)\n    elif level.lower() in [\"succes\", \"critical\"]:\n        self.__logger.critical(err_mssg)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.RegionPolygon.start_new_log_task","title":"<code>start_new_log_task(task_name='NOT DEFINED', pbar=None)</code>","text":"<p>Use this method to start a new task. Will reset the internal clock.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def start_new_log_task(\n    self,\n    task_name: str = \"NOT DEFINED\",\n    pbar: tqdm.tqdm = None,\n) -&gt; None:\n    \"\"\"Use this method to start a new task. Will reset the internal clock.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().start_new_iteration(pbar=pbar)\n    self.get_filelogformatter().start_new_iteration(pbar=pbar)\n    self.set_logger_message(f\"Starting new task: {task_name}\")\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon","title":"<code>SectionPolygon(section_file_path, logger, default_value='floodplain1')</code>","text":"<p>               Bases: <code>MultiPolygon</code></p> <p>SectionPolygonFile class.</p> <p>Instantiate a SectionPolygonFile object.</p> <p>Parameters:</p> Name Type Description Default <code>section_file_path</code> <code>str | Path</code> <p>path to section polygon file.</p> required <code>logger</code> <code>Logger</code> <p>logger</p> required <code>default_value</code> <code>str</code> <p>default section name to use in cells not covered by a section polygon.</p> <code>'floodplain1'</code> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def __init__(self, section_file_path: str | Path, logger: Logger, default_value: str=\"floodplain1\") -&gt; None:\n    \"\"\"Instantiate a SectionPolygonFile object.\n\n    Args:\n        section_file_path (str | Path): path to section polygon file.\n        logger (Logger): logger\n        default_value (str): default section name to use in cells not covered by a section polygon.\n\n    \"\"\"\n    super().__init__(logger)\n    self.from_file(section_file_path)\n    self.undefined = default_value\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.polygons","title":"<code>polygons: list[Polygon]</code>  <code>property</code> <code>writable</code>","text":"<p>Polygons.</p>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.sections","title":"<code>sections: list[Polygon]</code>  <code>property</code>","text":"<p>Section polygons.</p>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.as_meshkernel","title":"<code>as_meshkernel()</code>","text":"<p>Convert polygons to MeshKernel GeometryList.</p> Note <p>MeshKernel GeometryList supports multiple polygons, separated by some int (default -999). However, to keep track of polygon properties (e.g. name), we create a list of single polygon GeometryList objects.</p> <p>Returns:</p> Name Type Description <code>GeometryList</code> <code>list[GeometryList]</code> <p>MeshKernel GeometryList object containing all polygons.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def as_meshkernel(self) -&gt; list[GeometryList]:\n    \"\"\"Convert polygons to MeshKernel GeometryList.\n\n    Note:\n        MeshKernel GeometryList supports multiple polygons,\n        separated by some int (default -999). However,\n        to keep track of polygon properties (e.g. name),\n        we create a list of single polygon GeometryList objects.\n\n    Returns:\n        GeometryList: MeshKernel GeometryList object containing all polygons.\n    \"\"\"\n    if not self.polygons:\n        err_msg = \"No polygons defined\"\n        raise ValueError(err_msg)\n\n    return [GeometryList(x_coordinates=polygon.x, y_coordinates=polygon.y) for polygon in self.polygons]\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.as_shapely","title":"<code>as_shapely()</code>","text":"<p>Convert polygons to list of Shapely Polygon objects.</p> <p>Returns:</p> Type Description <code>list[Polygon]</code> <p>list[shapely.geometry.Polygon]: List of Shapely Polygon objects.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def as_shapely(self) -&gt; list[shapely.geometry.Polygon]:\n    \"\"\"Convert polygons to list of Shapely Polygon objects.\n\n    Returns:\n        list[shapely.geometry.Polygon]: List of Shapely Polygon objects.\n    \"\"\"\n    if not self.polygons:\n        err_msg = \"No polygons defined\"\n        raise ValueError(err_msg)\n\n    return [shapely.Polygon(polygon.coordinates) for polygon in self.polygons]\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.check_overlap","title":"<code>check_overlap()</code>","text":"<p>Check if polygons overlap and log a warning if they do.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def check_overlap(self) -&gt; None:\n    \"\"\"Check if polygons overlap and log a warning if they do.\"\"\"\n    for i, poly1 in enumerate(self.as_shapely()):\n        for j, poly2 in enumerate(self.as_shapely()):\n            if i == j:\n                # polygon will obviously overlap with itself\n                continue\n            if poly1.intersects(poly2):\n                self.set_logger_message(\n                   f\"{self.polygons[i].properties.get('name')} overlaps {self.polygons[j].properties.get('name')}.\",\n                   level=\"warning\",\n                )\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.create_logger","title":"<code>create_logger()</code>  <code>staticmethod</code>","text":"<p>Create logger instance.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>@staticmethod\ndef create_logger() -&gt; Logger:\n    \"\"\"Create logger instance.\"\"\"\n    # Create logger\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n\n    # create formatter\n    logger.__logformatter = ElapsedFormatter()  # noqa: SLF001\n    logger._Filelogformatter = ElapsedFileFormatter()  # noqa: SLF001\n\n    # create console handler\n    if TqdmLoggingHandler not in map(type, logger.handlers):\n        ch = TqdmLoggingHandler()\n        ch.setLevel(logging.DEBUG)\n        ch.setFormatter(logger.__logformatter)  # noqa: SLF001\n        logger.addHandler(ch)\n\n    return logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.finish_log_task","title":"<code>finish_log_task()</code>","text":"<p>Use this method to finish task.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def finish_log_task(self) -&gt; None:\n    \"\"\"Use this method to finish task.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().finish_task()\n    self.set_logger_message()\n    self.pbar = None\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.from_file","title":"<code>from_file(file_path)</code>","text":"<p>Read section polygon file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>path to section polygon file.</p> required Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def from_file(self, file_path: str | Path) -&gt; None:\n    \"\"\"Read section polygon file.\n\n    Args:\n        file_path (str | Path): path to section polygon file.\n\n    \"\"\"\n    super().from_file(file_path)\n    self._validate_sections()\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.get_filelogformatter","title":"<code>get_filelogformatter()</code>","text":"<p>Return  file log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_filelogformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return  file log formatter.\"\"\"\n    return self.get_logger()._Filelogformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.get_gridpoints_in_polygon","title":"<code>get_gridpoints_in_polygon(res_file, *, property_name='section', force_cache_invalidation=False)</code>","text":"<p>Method to get faces and edges in section.</p> <p>This method performs caching of the in-polygon classification results to avoid recalculating if the section file has not changed. The cache is invalidated if the section file is modified or if <code>force_cache_invalidation</code> is set to <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>res_file</code> <code>str | Path</code> <p>path to result (map) netcdf file.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification. Defaults to section</p> <code>'section'</code> <code>force_cache_invalidation</code> <code>bool</code> <p>Force cache invalidation even if section file has not changed.</p> <code>False</code> <p>Returns:</p> Type Description <code>GridPointsInPolygonResults</code> <p>GridPointsInPolygonResults</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def get_gridpoints_in_polygon(self,\n    res_file: str | Path,\n    *,\n    property_name: Literal[\"region\", \"section\"]=\"section\",\n    force_cache_invalidation:bool=False) -&gt; GridPointsInPolygonResults:\n    \"\"\"Method to get faces and edges in section.\n\n    This method performs caching of the in-polygon classification results\n    to avoid recalculating if the section file has not changed. The cache\n    is invalidated if the section file is modified or if `force_cache_invalidation`\n    is set to `True`.\n\n    Args:\n        res_file (str | Path): path to result (map) netcdf file.\n        property_name (Literal[\"region\", \"section\"]): Property to use for classification. Defaults to section\n        force_cache_invalidation (bool): Force cache invalidation even if section file has not changed.\n\n    Returns:\n        GridPointsInPolygonResults\n    \"\"\"\n    return super().get_gridpoints_in_polygon(res_file,\n                                          property_name=property_name,\n                                          force_cache_invalidation=force_cache_invalidation)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.get_inifile","title":"<code>get_inifile()</code>","text":"<p>Get the inifile object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_inifile(self) -&gt; IniFile:\n    \"\"\"Get the inifile object.\"\"\"\n    return self.__iniFile\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.get_logformatter","title":"<code>get_logformatter()</code>","text":"<p>Return log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return log formatter.\"\"\"\n    return self.get_logger().__logformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.get_logger","title":"<code>get_logger()</code>","text":"<p>Use this method to return logger object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logger(self) -&gt; Logger:\n    \"\"\"Use this method to return logger object.\"\"\"\n    return self.__logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.get_points_in_polygon","title":"<code>get_points_in_polygon(points, property_name)</code>","text":"<p>Method to determine in which polygon input points are.</p> Warning <p>This method is not applicable for large number of points. Only use for small number of points (e.g. cross-section locations).</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Array of shape (n_points, 2) containing x,y coordinates of points to classify.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of polygon names in which the points are located. If a point is not located        in any polygon, it is classified as 'undefined'.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def get_points_in_polygon(self, points: np.ndarray, property_name: Literal[\"region\", \"section\"]) -&gt; list[str]:\n    \"\"\"Method to determine in which polygon input points are.\n\n    Warning:\n        This method is not applicable for large number of points.\n        Only use for small number of points (e.g. cross-section locations).\n\n    Args:\n        points (np.ndarray): Array of shape (n_points, 2) containing x,y coordinates of points to classify.\n        property_name (Literal['region', 'section']): Property to use for classification.\n\n    Returns:\n        list[str]: List of polygon names in which the points are located. If a point is not located\n                   in any polygon, it is classified as 'undefined'.\n    \"\"\"\n    # Convert to shapely point\n    points = [shapely.Point(xy) for xy in points]\n    points_regions = [self.undefined] * len(points)\n\n    # Assign point to region\n    for i, point in enumerate(points):\n        for j, polygon in enumerate(self.as_shapely()):\n            if point.within(polygon):\n                points_regions[i] = self.polygons[j].properties.get(property_name)\n                break\n\n    return points_regions\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.meshkernel_inpolygon","title":"<code>meshkernel_inpolygon(res_file, dtype, property_name)</code>","text":"<p>Get grid points in polygon.</p> <p>Parameters:</p> Name Type Description Default <code>res_file</code> <code>str | Path</code> <p>Path to result (map) netcdf file.</p> required <code>dtype</code> <code>Literal['face', 'edge', 'node']</code> <p>Type of grid points to retrieve.</p> required <code>property_name</code> <code>Literal['region', 'section']</code> <p>Property to use for classification.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>pd.DataFrame | dict: DataFrame or dictionary containing grid points in polygon.</p> Source code in <code>fm2prof\\polygon_file.py</code> <pre><code>def meshkernel_inpolygon(self,\n    res_file: str | Path,  # path to result (map) netcdf file\n    dtype: Literal[\"face\", \"edge\", \"node\"],\n    property_name: Literal[\"region\", \"section\"],\n    ) -&gt; list[str]:\n    \"\"\"Get grid points in polygon.\n\n    Args:\n        res_file (str | Path): Path to result (map) netcdf file.\n        dtype (Literal[\"face\", \"edge\", \"node\"]): Type of grid points to retrieve.\n        property_name (Literal[\"region\", \"section\"]): Property to use for classification.\n\n    Returns:\n        pd.DataFrame | dict: DataFrame or dictionary containing grid points in polygon.\n    \"\"\"\n    # Step 1\n    # Construct Meshkernel grid\n    mk = MeshKernel(projection=ProjectionType.CARTESIAN)\n    mesh2d_input = mk.mesh2d_get()\n\n    fmdata = FMDataImporter(res_file)\n    mesh2d_input.node_x = fmdata.get_variable(\"mesh2d_node_x\")\n    mesh2d_input.node_y = fmdata.get_variable(\"mesh2d_node_y\")\n    mesh2d_input.edge_nodes = fmdata.get_variable(\"mesh2d_edge_nodes\").flatten() - 1\n\n    mk.mesh2d_set(mesh2d_input)\n\n    # Step 2: perform point-in-polygon classification\n    nodes_in_polygon: list[str] = [self.undefined] * len(mesh2d_input.node_x)  # default to undefined\n\n    for i, mk_polygon in enumerate(self.as_meshkernel()):\n        self.set_logger_message(\n            f\"  | Classifying {dtype}s in polygon {self.polygons[i].properties.get('name')} \"\n            f\"({i+1}/{len(self.polygons)})\",\n            level=\"info\")\n        indices: list[float] = mk.mesh2d_get_nodes_in_polygons(mk_polygon, inside=True).tolist()\n        for j in indices:\n            nodes_in_polygon[j] = self.polygons[i].properties.get(property_name)\n\n    # Step 3: map to faces or edges if needed\n    if dtype == \"node\":\n        output = nodes_in_polygon\n    elif dtype == \"face\":\n        face_map: np.ndarray = fmdata.get_variable(\"mesh2d_face_nodes\").T[0] -1\n        node_to_face: list[str] = [self.undefined] * len(face_map)\n        for face_index, map_index in enumerate(face_map.tolist()):\n            node_to_face[int(face_index)] = nodes_in_polygon[int(map_index)]\n        output = node_to_face\n    elif dtype == \"edge\":\n        # only internal edges!\n        internal_edges = fmdata.get_variable(\"mesh2d_edge_type\")[:] == 1\n        edge_map: np.ndarray = fmdata.get_variable(\"mesh2d_edge_nodes\").T[0] -1\n        edge_map = edge_map[internal_edges]\n        node_to_edge: list[str] = [self.undefined] * len(edge_map)\n        for edge_index, map_index in enumerate(edge_map.tolist()):\n            node_to_edge[int(edge_index)] = nodes_in_polygon[int(map_index)]\n        output = node_to_edge\n\n    return output\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.set_inifile","title":"<code>set_inifile(inifile=None)</code>","text":"<p>Use this method to set configuration file object.</p> <p>For loading from file, use <code>load_inifile</code> instead</p> <pre><code>inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_inifile(self, inifile: IniFile = None) -&gt; None:\n    \"\"\"Use this method to set configuration file object.\n\n    For loading from file, use ``load_inifile`` instead\n\n    Args:\n    ----\n        inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n\n    \"\"\"\n    self.__iniFile = inifile\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.set_logfile","title":"<code>set_logfile(output_dir, filename='fm2prof.log')</code>","text":"<p>Set log file.</p> <pre><code>output_dir (str): _description_\nfilename (str, optional): _description_. Defaults to \"fm2prof.log\".\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logfile(self, output_dir: str | Path, filename: str = \"fm2prof.log\") -&gt; None:\n    \"\"\"Set log file.\n\n    Args:\n    ----\n        output_dir (str): _description_\n        filename (str, optional): _description_. Defaults to \"fm2prof.log\".\n\n    \"\"\"\n    # create file handler\n    if not output_dir:\n        err_msg = \"output_dir is required.\"\n        raise ValueError(err_msg)\n    fh = logging.FileHandler(Path(output_dir).joinpath(filename), encoding=\"utf-8\")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(self.get_logger()._Filelogformatter)  # noqa: SLF001\n    self.__logger.addHandler(fh)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.set_logger","title":"<code>set_logger(logger)</code>","text":"<p>Use to set logger.</p> <pre><code>logger (Logger): Logger instance\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger(self, logger: Logger) -&gt; None:\n    \"\"\"Use to set logger.\n\n    Args:\n    ----\n        logger (Logger): Logger instance\n\n    \"\"\"\n    if not isinstance(logger, Logger):\n        err_msg = \"logger should be instance of Logger class\"\n        raise TypeError(err_msg)\n    self.__logger = logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.set_logger_message","title":"<code>set_logger_message(err_mssg='', level='info', *, header=False)</code>","text":"<p>Set message to logger if this is set.</p> <pre><code>err_mssg (str, optional): Error message to log. Defaults to \"\".\nlevel (str, optional): Log level. Defaults to \"info\".\nheader (bool, optional): Set error message as header. Defaults to False.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger_message(\n    self,\n    err_mssg: str = \"\",\n    level: str = \"info\",\n    *,\n    header: bool = False,\n) -&gt; None:\n    \"\"\"Set message to logger if this is set.\n\n    Args:\n    ----\n        err_mssg (str, optional): Error message to log. Defaults to \"\".\n        level (str, optional): Log level. Defaults to \"info\".\n        header (bool, optional): Set error message as header. Defaults to False.\n\n    \"\"\"\n    if not self.__logger:\n        return\n\n    if header:\n        self.get_logformatter().set_intro(True)\n        self.get_logger()._Filelogformatter.set_intro(True)  # noqa: SLF001\n    else:\n        self.get_logformatter().set_intro(False)\n        self.get_logger()._Filelogformatter.set_intro(False)  # noqa: SLF001\n\n    if level.lower() not in [\"info\", \"debug\", \"warning\", \"error\", \"critical\"]:\n        err_msg = f\"{level.lower()} is not valid logging level.\"\n        raise ValueError(err_msg)\n\n    if level.lower() == \"info\":\n        self.__logger.info(err_mssg)\n    elif level.lower() == \"debug\":\n        self.__logger.debug(err_mssg)\n    elif level.lower() == \"warning\":\n        self.__logger.warning(err_mssg)\n    elif level.lower() == \"error\":\n        self.__logger.error(err_mssg)\n    elif level.lower() in [\"succes\", \"critical\"]:\n        self.__logger.critical(err_mssg)\n</code></pre>"},{"location":"markdown/api/#fm2prof.polygon_file.SectionPolygon.start_new_log_task","title":"<code>start_new_log_task(task_name='NOT DEFINED', pbar=None)</code>","text":"<p>Use this method to start a new task. Will reset the internal clock.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def start_new_log_task(\n    self,\n    task_name: str = \"NOT DEFINED\",\n    pbar: tqdm.tqdm = None,\n) -&gt; None:\n    \"\"\"Use this method to start a new task. Will reset the internal clock.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().start_new_iteration(pbar=pbar)\n    self.get_filelogformatter().start_new_iteration(pbar=pbar)\n    self.set_logger_message(f\"Starting new task: {task_name}\")\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter","title":"<code>ElapsedFileFormatter()</code>","text":"<p>               Bases: <code>ElapsedFormatter</code></p> <p>Elapsed file formatter class.</p> <p>Instantiate an ElapsedFileFormatter object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate an ElapsedFileFormatter object.\"\"\"\n    super().__init__()\n    self._resetStyle = \"\"\n    self._colors = {\n        \"INFO\": [\"\", \"\"],\n        \"DEBUG\": [\"\", \"\"],\n        \"WARNING\": [\"\", \"\"],\n        \"ERROR\": [\"\", \"\"],\n        \"RESET\": \"\",\n    }\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter.pbar","title":"<code>pbar: None | tqdm.tqdm | tqdm.std.tqdm</code>  <code>property</code> <code>writable</code>","text":"<p>Progress bar.</p>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter.finish_task","title":"<code>finish_task()</code>","text":"<p>Finish task.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def finish_task(self) -&gt; None:\n    \"\"\"Finish task.\"\"\"\n    self.__new_iteration = -1\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter.format","title":"<code>format(record)</code>","text":"<p>Format log record.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def format(self, record: LogRecord) -&gt; str:\n    \"\"\"Format log record.\"\"\"\n    if self._intro:\n        return self.__format_intro(record)\n    if self.__new_iteration &gt; 0:\n        return self.__format_header(record)\n    if self.__new_iteration == -1:\n        return self.__format_footer(record)\n    return self.__format_message(record)\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter.get_elapsed_time","title":"<code>get_elapsed_time()</code>","text":"<p>Get elapsed time in seconds.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_elapsed_time(self) -&gt; float:\n    \"\"\"Get elapsed time in seconds.\"\"\"\n    current_time = datetime.now()\n    elapsed_time = current_time - self.start_time\n    return elapsed_time.total_seconds()\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter.new_task","title":"<code>new_task()</code>","text":"<p>Reset ElapsedTimeFormatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def new_task(self) -&gt; None:\n    \"\"\"Reset ElapsedTimeFormatter.\"\"\"\n    self.__new_iteration = 1\n    self.__reset()\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter.set_intro","title":"<code>set_intro(flag=True)</code>","text":"<p>Indicate intro section for formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_intro(self, flag: bool = True) -&gt; None:  # noqa: FBT001, FBT002\n    \"\"\"Indicate intro section for formatter.\"\"\"\n    self._intro = flag\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter.set_number_of_iterations","title":"<code>set_number_of_iterations(n)</code>","text":"<p>Set numbber of iterations.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_number_of_iterations(self, n: int) -&gt; None:\n    \"\"\"Set numbber of iterations.\"\"\"\n    if n &lt; 1:\n        err_msg = \"Total number of iterations should be higher than zero\"\n        raise ValueError(err_msg)\n    self.number_of_iterations = n\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFileFormatter.start_new_iteration","title":"<code>start_new_iteration(pbar=None)</code>","text":"<p>Start a new iteration with a progress bar.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def start_new_iteration(self, pbar: tqdm.tqdm | None = None) -&gt; None:\n    \"\"\"Start a new iteration with a progress bar.\"\"\"\n    self.current_iteration += 1\n    self.new_task()\n    self.pbar = pbar\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter","title":"<code>ElapsedFormatter()</code>","text":"<p>ElapsedFormatter class.</p> <p>Instantiate an ElapsedFormatter object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate an ElapsedFormatter object.\"\"\"\n    self.start_time = time()\n    self.number_of_iterations: int = 1\n    self.current_iteration: int = 0\n    self._pbar: tqdm.tqdm = None\n    self._resetStyle = Style.RESET_ALL\n    self._colors = {\n        \"INFO\": [Back.BLUE, Fore.BLUE],\n        \"DEBUG\": [Back.CYAN, Fore.CYAN],\n        \"WARNING\": [Back.YELLOW + Fore.BLACK, Fore.YELLOW],\n        \"ERROR\": [Back.RED, Fore.RED],\n        \"CRITICAL\": [Back.GREEN, Fore.GREEN],\n    }\n\n    colorama.init()\n\n    # saves amount of errors / warnings\n    self._loglibrary: dict = {\"ERROR\": 0, \"WARNING\": 0}\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter.pbar","title":"<code>pbar: None | tqdm.tqdm | tqdm.std.tqdm</code>  <code>property</code> <code>writable</code>","text":"<p>Progress bar.</p>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter.finish_task","title":"<code>finish_task()</code>","text":"<p>Finish task.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def finish_task(self) -&gt; None:\n    \"\"\"Finish task.\"\"\"\n    self.__new_iteration = -1\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter.format","title":"<code>format(record)</code>","text":"<p>Format log record.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def format(self, record: LogRecord) -&gt; str:\n    \"\"\"Format log record.\"\"\"\n    if self._intro:\n        return self.__format_intro(record)\n    if self.__new_iteration &gt; 0:\n        return self.__format_header(record)\n    if self.__new_iteration == -1:\n        return self.__format_footer(record)\n    return self.__format_message(record)\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter.get_elapsed_time","title":"<code>get_elapsed_time()</code>","text":"<p>Get elapsed time in seconds.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_elapsed_time(self) -&gt; float:\n    \"\"\"Get elapsed time in seconds.\"\"\"\n    current_time = datetime.now()\n    elapsed_time = current_time - self.start_time\n    return elapsed_time.total_seconds()\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter.new_task","title":"<code>new_task()</code>","text":"<p>Reset ElapsedTimeFormatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def new_task(self) -&gt; None:\n    \"\"\"Reset ElapsedTimeFormatter.\"\"\"\n    self.__new_iteration = 1\n    self.__reset()\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter.set_intro","title":"<code>set_intro(flag=True)</code>","text":"<p>Indicate intro section for formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_intro(self, flag: bool = True) -&gt; None:  # noqa: FBT001, FBT002\n    \"\"\"Indicate intro section for formatter.\"\"\"\n    self._intro = flag\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter.set_number_of_iterations","title":"<code>set_number_of_iterations(n)</code>","text":"<p>Set numbber of iterations.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_number_of_iterations(self, n: int) -&gt; None:\n    \"\"\"Set numbber of iterations.\"\"\"\n    if n &lt; 1:\n        err_msg = \"Total number of iterations should be higher than zero\"\n        raise ValueError(err_msg)\n    self.number_of_iterations = n\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.ElapsedFormatter.start_new_iteration","title":"<code>start_new_iteration(pbar=None)</code>","text":"<p>Start a new iteration with a progress bar.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def start_new_iteration(self, pbar: tqdm.tqdm | None = None) -&gt; None:\n    \"\"\"Start a new iteration with a progress bar.\"\"\"\n    self.current_iteration += 1\n    self.new_task()\n    self.pbar = pbar\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase","title":"<code>FM2ProfBase(logger=None, inifile=None)</code>","text":"<p>Base class for FM2PROF types.</p> <p>Implements methods for logging, project specific parameters</p> <p>Instatiate a FM2ProfBase object.</p> <pre><code>logger (Logger | None, optional): Logger . Defaults to None.\ninifile (IniFile | None, optional): IniFile instance. Defaults to None.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def __init__(self, logger: Logger | None = None, inifile: IniFile | None = None) -&gt; None:\n    \"\"\"Instatiate a FM2ProfBase object.\n\n    Args:\n    ----\n        logger (Logger | None, optional): Logger . Defaults to None.\n        inifile (IniFile | None, optional): IniFile instance. Defaults to None.\n\n    \"\"\"\n    if logger:\n        self.set_logger(logger)\n    if inifile:\n        self.set_inifile(inifile)\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.create_logger","title":"<code>create_logger()</code>  <code>staticmethod</code>","text":"<p>Create logger instance.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>@staticmethod\ndef create_logger() -&gt; Logger:\n    \"\"\"Create logger instance.\"\"\"\n    # Create logger\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.DEBUG)\n\n    # create formatter\n    logger.__logformatter = ElapsedFormatter()  # noqa: SLF001\n    logger._Filelogformatter = ElapsedFileFormatter()  # noqa: SLF001\n\n    # create console handler\n    if TqdmLoggingHandler not in map(type, logger.handlers):\n        ch = TqdmLoggingHandler()\n        ch.setLevel(logging.DEBUG)\n        ch.setFormatter(logger.__logformatter)  # noqa: SLF001\n        logger.addHandler(ch)\n\n    return logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.finish_log_task","title":"<code>finish_log_task()</code>","text":"<p>Use this method to finish task.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def finish_log_task(self) -&gt; None:\n    \"\"\"Use this method to finish task.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().finish_task()\n    self.set_logger_message()\n    self.pbar = None\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.get_filelogformatter","title":"<code>get_filelogformatter()</code>","text":"<p>Return  file log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_filelogformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return  file log formatter.\"\"\"\n    return self.get_logger()._Filelogformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.get_inifile","title":"<code>get_inifile()</code>","text":"<p>Get the inifile object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_inifile(self) -&gt; IniFile:\n    \"\"\"Get the inifile object.\"\"\"\n    return self.__iniFile\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.get_logformatter","title":"<code>get_logformatter()</code>","text":"<p>Return log formatter.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logformatter(self) -&gt; ElapsedFormatter:\n    \"\"\"Return log formatter.\"\"\"\n    return self.get_logger().__logformatter  # noqa: SLF001\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.get_logger","title":"<code>get_logger()</code>","text":"<p>Use this method to return logger object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def get_logger(self) -&gt; Logger:\n    \"\"\"Use this method to return logger object.\"\"\"\n    return self.__logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.set_inifile","title":"<code>set_inifile(inifile=None)</code>","text":"<p>Use this method to set configuration file object.</p> <p>For loading from file, use <code>load_inifile</code> instead</p> <pre><code>inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_inifile(self, inifile: IniFile = None) -&gt; None:\n    \"\"\"Use this method to set configuration file object.\n\n    For loading from file, use ``load_inifile`` instead\n\n    Args:\n    ----\n        inifile (IniFile): inifile object. Obtain using e.g. ``get_inifile``.\n\n    \"\"\"\n    self.__iniFile = inifile\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.set_logfile","title":"<code>set_logfile(output_dir, filename='fm2prof.log')</code>","text":"<p>Set log file.</p> <pre><code>output_dir (str): _description_\nfilename (str, optional): _description_. Defaults to \"fm2prof.log\".\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logfile(self, output_dir: str | Path, filename: str = \"fm2prof.log\") -&gt; None:\n    \"\"\"Set log file.\n\n    Args:\n    ----\n        output_dir (str): _description_\n        filename (str, optional): _description_. Defaults to \"fm2prof.log\".\n\n    \"\"\"\n    # create file handler\n    if not output_dir:\n        err_msg = \"output_dir is required.\"\n        raise ValueError(err_msg)\n    fh = logging.FileHandler(Path(output_dir).joinpath(filename), encoding=\"utf-8\")\n    fh.setLevel(logging.DEBUG)\n    fh.setFormatter(self.get_logger()._Filelogformatter)  # noqa: SLF001\n    self.__logger.addHandler(fh)\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.set_logger","title":"<code>set_logger(logger)</code>","text":"<p>Use to set logger.</p> <pre><code>logger (Logger): Logger instance\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger(self, logger: Logger) -&gt; None:\n    \"\"\"Use to set logger.\n\n    Args:\n    ----\n        logger (Logger): Logger instance\n\n    \"\"\"\n    if not isinstance(logger, Logger):\n        err_msg = \"logger should be instance of Logger class\"\n        raise TypeError(err_msg)\n    self.__logger = logger\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.set_logger_message","title":"<code>set_logger_message(err_mssg='', level='info', *, header=False)</code>","text":"<p>Set message to logger if this is set.</p> <pre><code>err_mssg (str, optional): Error message to log. Defaults to \"\".\nlevel (str, optional): Log level. Defaults to \"info\".\nheader (bool, optional): Set error message as header. Defaults to False.\n</code></pre> Source code in <code>fm2prof\\common.py</code> <pre><code>def set_logger_message(\n    self,\n    err_mssg: str = \"\",\n    level: str = \"info\",\n    *,\n    header: bool = False,\n) -&gt; None:\n    \"\"\"Set message to logger if this is set.\n\n    Args:\n    ----\n        err_mssg (str, optional): Error message to log. Defaults to \"\".\n        level (str, optional): Log level. Defaults to \"info\".\n        header (bool, optional): Set error message as header. Defaults to False.\n\n    \"\"\"\n    if not self.__logger:\n        return\n\n    if header:\n        self.get_logformatter().set_intro(True)\n        self.get_logger()._Filelogformatter.set_intro(True)  # noqa: SLF001\n    else:\n        self.get_logformatter().set_intro(False)\n        self.get_logger()._Filelogformatter.set_intro(False)  # noqa: SLF001\n\n    if level.lower() not in [\"info\", \"debug\", \"warning\", \"error\", \"critical\"]:\n        err_msg = f\"{level.lower()} is not valid logging level.\"\n        raise ValueError(err_msg)\n\n    if level.lower() == \"info\":\n        self.__logger.info(err_mssg)\n    elif level.lower() == \"debug\":\n        self.__logger.debug(err_mssg)\n    elif level.lower() == \"warning\":\n        self.__logger.warning(err_mssg)\n    elif level.lower() == \"error\":\n        self.__logger.error(err_mssg)\n    elif level.lower() in [\"succes\", \"critical\"]:\n        self.__logger.critical(err_mssg)\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FM2ProfBase.start_new_log_task","title":"<code>start_new_log_task(task_name='NOT DEFINED', pbar=None)</code>","text":"<p>Use this method to start a new task. Will reset the internal clock.</p> <p>:param task_name: task name, will be displayed in log message</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def start_new_log_task(\n    self,\n    task_name: str = \"NOT DEFINED\",\n    pbar: tqdm.tqdm = None,\n) -&gt; None:\n    \"\"\"Use this method to start a new task. Will reset the internal clock.\n\n    :param task_name: task name, will be displayed in log message\n    \"\"\"\n    self.get_logformatter().start_new_iteration(pbar=pbar)\n    self.get_filelogformatter().start_new_iteration(pbar=pbar)\n    self.set_logger_message(f\"Starting new task: {task_name}\")\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FrictionTable","title":"<code>FrictionTable(level, friction)</code>","text":"<p>Container for friction table.</p> <p>Instantiate a FrictionTable object.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def __init__(self, level: np.ndarray, friction: np.ndarray) -&gt; None:\n    \"\"\"Instantiate a FrictionTable object.\"\"\"\n    if self._validate_input(level, friction):\n        self.level = level\n        self.friction = friction\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.FrictionTable.interpolate","title":"<code>interpolate(new_z)</code>","text":"<p>Interpolate friction.</p> <p>Parameters:</p> Name Type Description Default <code>new_z</code> <code>ndarray</code> <p>description</p> required Source code in <code>fm2prof\\common.py</code> <pre><code>def interpolate(self, new_z: np.ndarray) -&gt; None:\n    \"\"\"Interpolate friction.\n\n    Args:\n        new_z (np.ndarray): _description_\n    \"\"\"\n    self.friction = np.interp(new_z, self.level, self.friction)\n    self.level = new_z\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.TqdmLoggingHandler","title":"<code>TqdmLoggingHandler()</code>","text":"<p>               Bases: <code>StreamHandler</code></p> <p>Logging handler for tqdm package.</p> <p>Instantiate a TqdmLoggingHandler.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Instantiate a TqdmLoggingHandler.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"markdown/api/#fm2prof.common.TqdmLoggingHandler.emit","title":"<code>emit(record)</code>","text":"<p>Write progressbar to logstream.</p> Source code in <code>fm2prof\\common.py</code> <pre><code>def emit(self, record: LogRecord) -&gt; None:\n    \"\"\"Write progressbar to logstream.\"\"\"\n    try:\n        msg = self.format(record)\n        if self.formatter.pbar:\n            self.formatter.pbar.write(msg)\n        else:\n            stream = self.stream\n            stream.write(msg + self.terminator)\n\n        self.flush()\n    except Exception:\n        self.handleError(record)\n</code></pre>"},{"location":"markdown/api/#fm2prof.nearest_neighbour.classify_with_regions","title":"<code>classify_with_regions(cssdata, time_independent_data, edge_data, css_regions)</code>","text":"<p>Assign cross-section id's based on region polygons.</p> <p>Within a region, assignment will be done by k nearest neighbour</p> Source code in <code>fm2prof\\nearest_neighbour.py</code> <pre><code>def classify_with_regions(\n    cssdata: dict,\n    time_independent_data: pd.DataFrame,\n    edge_data: dict,\n    css_regions: list[str],\n    ) -&gt; tuple[pd.DataFrame, dict]:\n    \"\"\"Assign cross-section id's based on region polygons.\n\n    Within a region, assignment will be done by k nearest neighbour\n    \"\"\"\n    time_independent_data[\"sclass\"] = time_independent_data[\"region\"].astype(str)\n\n    # Nearest Neighbour within regions\n    for region in time_independent_data[\"region\"].unique():\n        # Select cross-sections within this region\n        css_xy = cssdata[\"xy\"][np.array(css_regions) == region]\n        css_id = cssdata[\"id\"][np.array(css_regions) == region]\n\n        if len(css_id) == 0:\n            # no cross-sections in this region\n            continue\n        # Select 2d points within region\n        node_mask = time_independent_data[\"region\"] == region\n        x_2d_node = time_independent_data[\"x\"][node_mask]\n        y_2d_node = time_independent_data[\"y\"][node_mask]\n\n        edge_mask = np.array(edge_data[\"region\"]) == region\n        x_2d_edge = edge_data[\"x\"][edge_mask]\n        y_2d_edge = edge_data[\"y\"][edge_mask]\n\n        # Do Nearest Neighour\n        neigh = _get_class_tree(css_xy, css_id)\n        css_2d_nodes = neigh.predict(np.array([x_2d_node, y_2d_node]).T)\n        css_2d_edges = neigh.predict(np.array([x_2d_edge, y_2d_edge]).T)\n\n        # Update data in main structures\n        time_independent_data.loc[node_mask, \"sclass\"] = css_2d_nodes  # sclass = cross-section id\n\n        edge_data[\"sclass\"][edge_mask] = css_2d_edges\n\n    return time_independent_data, edge_data\n</code></pre>"},{"location":"markdown/api/#fm2prof.nearest_neighbour.classify_without_regions","title":"<code>classify_without_regions(cssdata, time_independent_data, edge_data)</code>","text":"<p>Classify without regions.</p> Source code in <code>fm2prof\\nearest_neighbour.py</code> <pre><code>def classify_without_regions(\n    cssdata: dict,\n    time_independent_data: pd.DataFrame,\n    edge_data: dict,\n    ) -&gt; tuple[pd.DataFrame, dict]:\n    \"\"\"Classify without regions.\"\"\"\n    # Create a class identifier to map points to cross-sections\n    neigh = _get_class_tree(cssdata[\"xy\"], cssdata[\"id\"])\n\n    # Expand time-independent dataset with cross-section names\n    time_independent_data[\"sclass\"] = neigh.predict(\n        np.array([time_independent_data[\"x\"], time_independent_data[\"y\"]]).T,\n    )\n\n    # Assign cross-section names to edge coordinates as well\n    edge_data[\"sclass\"] = neigh.predict(np.array([edge_data[\"x\"], edge_data[\"y\"]]).T)\n\n    return time_independent_data, edge_data\n</code></pre>"},{"location":"markdown/api/#fm2prof.nearest_neighbour.get_centre_values","title":"<code>get_centre_values(location, x, y, waterdepth, waterlevel)</code>","text":"<p>Find output point closest to x,y location, output depth and water level as nd arrays.</p> Source code in <code>fm2prof\\nearest_neighbour.py</code> <pre><code>def get_centre_values(\n    location: np.array,\n    x: float,\n    y: float,\n    waterdepth: pd.DataFrame,\n    waterlevel: pd.DataFrame,\n    ) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Find output point closest to x,y location, output depth and water level as nd arrays.\"\"\"\n    nn = NearestNeighbors(n_neighbors=1, algorithm=\"ball_tree\").fit(np.array([x, y]).T)\n\n    # conversion to 2d array, as 1d arrays are deprecated for kneighbors\n    location_array = np.array(location).reshape(1, -1)\n    (_, index) = nn.kneighbors(location_array)\n\n    # retrieve cell characteristic waterdepth\n    centre_depth = waterdepth.iloc[index[0]].to_numpy()\n    centre_level = waterlevel.iloc[index[0]].to_numpy()\n\n    # When starting from a dry bed, the centre_level may have nan values\n    #\n    bed_level = np.nanmin(centre_level - centre_depth)\n    centre_level[np.isnan(centre_level)] = bed_level\n\n    return centre_depth[0], centre_level[0]\n</code></pre>"},{"location":"markdown/conceptual_design/","title":"Methodology","text":"<p>This chapter describes in more detail the steps FM2PROF takes to go from a 2D representation of reality to a 1D representation of reality. Conceptually, FM2PROF works in three distinct steps: (1) initialisation, (2) building cross-sections and (3) finalisation.</p>"},{"location":"markdown/conceptual_design/#initialisation","title":"Initialisation","text":"Image caption <p>The initialisation step involves parsing (i.e. reading and making available for further analysis) the input. In this step control volumes and sections are defined as well. This step may take some time to complete, but this preprocessing greatly reduces the computation times in the next step.</p>"},{"location":"markdown/conceptual_design/#region-polygon-file","title":"Region polygon file","text":"<p>The region polygon file (Dutch: gebiedsvakken) is provided in the configuration and should be a valid MultiPolygon geojson file. If a polygon file is provided, FM2PROF will perform an <code>inpolygon</code> algorithm during initialisation and write the results to a <code>.region_cache.json</code> file which is placed in the same directory as the 2D map file. This can take up to 30 minutes for a sizable river. If a cache file is already present and valid, it will be read instead. A cache file is invalidated if the 2D input has changed since the cache was created. </p> <p>Note</p> <p>There are special conditions for the geojson file, see MultiPolygon. </p> <p>The region file is used to map each point (node, edge or face) in the 2D input grid to one unique region. They are used to determine what 2D points are assigned to which cross-section, see Classification of volumes</p>"},{"location":"markdown/conceptual_design/#section-polygon-file","title":"Section polygon file","text":"<p>The section polygon file (Dutch: gebiedsvakken) is provided in the configuration and should be a valid MultiPolygon geojson file. If a polygon file is provided, FM2PROF will perform an <code>inpolygon</code> algorithm during initialisation and write the results to a <code>.section_cache.json</code> file which is placed in the same directory as the 2D map file. This can take up to 30 minutes for a sizable river. If a cache file is already present and valid, it will be read instead. A cache file is invalidated if the 2D input has changed since the cache was created. </p> <p>Sections are used to divide the cross-section between floodplain and main channel (e.g. the 'floodplain' section and the 'main channel' section). This distinction is only used to assign different roughness values to each section. </p> <p>Tip</p> <p>The default section is \"floodplain1\". To reduce initialisation time, provide only a section polygon covering the main channel (so a polygon with attribute <code>section</code> set to <code>main</code>). By default, all  points not covered by the main channel will be floodplain1. </p>"},{"location":"markdown/conceptual_design/#import-2d-data","title":"Import 2D data","text":""},{"location":"markdown/conceptual_design/#parsing-2d-data","title":"Parsing 2D data","text":"<p>Dflow2d uses a staggered grid to solve the (hydrostatic) flow equations. Because of this staggered approach, there is not a single 2D point that has all information. Flow information (flow velocity, discharge) is stored in flow links (or edges), while geometry (bed level) is stored in cell faces. FM2PROF needs both information from the faces, as from the links.</p> The dflow2d staggered grid."},{"location":"markdown/conceptual_design/#classification-of-control-volumes","title":"Classification of control volumes","text":"<p><code>Control volumes</code> are used to define which 2D datepoints are linked to which 1D cross-section. This is done in the following steps:</p> <ul> <li>Each 2D point (node, edge and face) is assigned a Region. If a region polygon is provided, each 2D point is assigned the same region as the polygon they are in. If no region polygon is provided, each point will be assigned to the same default region. </li> <li>Each cross-section is assigned a region following the same principle. </li> <li>For each region seperately, we perform nearest neighbour classification to uniquely identify each 2D point to a 1D cross-section. Only 2D points that have the same region as the cross-section can be assigned to a cross-section. </li> </ul>"},{"location":"markdown/conceptual_design/#classification-of-sections","title":"Classification of sections","text":"<p>Sections are used to output a different roughness function for the main channel and the floodplains. The purpose of the classification is to determine whether a 2D point belongs to the main channel section, or to the floodplain section (see warning below).</p> <p>Two methods are implemented:</p> <ul> <li><code>Variance based classification&lt;section_classification_variance&gt;</code>{.interpreted-text     role=\"ref\"}</li> <li>Polygon-based classification</li> </ul>"},{"location":"markdown/conceptual_design/#build-cross-section","title":"Build Cross-Section","text":"The dflow2d staggered grid. <p>Once initialisation is complete, will loop over each <code>cross-section location&lt;Cross-section location&gt;</code>{.interpreted-text role=\"term\"}. In each iteration, the program takes two steps: (1) building the geometry and (2) building the roughness tables.</p> <p>Warning</p> <p>No cross-section will be generated for locations that have no 2D data assigned or have less than 10 faces assigned. This may happen if a location lies outside the 2D grid, or if there are many cross-section closely together. If this happens, an error is raised by FM2PROF. The user should check the cross-section location input file to resolve the problem.</p>"},{"location":"markdown/conceptual_design/#build-geometry","title":"Build Geometry","text":"<p>In each loop, a number of steps is taken based on the 2D data that is uniquely assigned to that cross-section:</p> <ul> <li><code>Lakes</code> are identified using the     <code>identify_lakes</code></li> <li><code>Flow volume</code> and     <code>Storage volume</code> are seperated using     the <code>distinguish_storage</code></li> <li>The     <code>water level dependent geometry&lt;Water level (in)dependent geometry&gt;</code>{.interpreted-text     role=\"term\"} is computed using <code>wl_dependent_css</code>{.interpreted-text     role=\"ref\"}</li> <li>The     <code>water level independent geometry&lt;Water level (in)dependent geometry&gt;</code>{.interpreted-text     role=\"term\"} is computed using     <code>wl_independent_css</code></li> <li>The parameters for <code>Summerdikes</code> are     defined using the <code>sd_optimisation</code></li> <li>Finally, the cross-section is simplified using the     Visvalingam-Whyatt method of poly-line vertex reduction     <code>simplify_css</code></li> </ul>"},{"location":"markdown/conceptual_design/#build-roughness","title":"Build roughness","text":"<p>At each cross-section point, a roughness look-up table is constructed that relates water level (in m + NAP) to a Ch\u00e9zy roughness coefficient. This is done in three steps:</p> <ul> <li>For each section, a roughness table is constructed by averaging the     2D points</li> </ul>"},{"location":"markdown/conceptual_design/#finalisation","title":"Finalisation","text":"The dflow2d staggered grid."},{"location":"markdown/conceptual_design/#interpolate-friction-tables","title":"Interpolate friction tables","text":"<p>Some output formats (e.g. SOBEK 3) require that the friction tables are uniform for each branch: each point on the branch must have the same dimensions. This means that if friction is defined as a function of water level, that each point on a branch must have the same water level dimension. </p> <p>During cross-section generation, it is not yet known what the water levels are for each  point. During finalisation, a uniform water level dimension is defined. For each point on  the branch, the friction value is interpolated to the uniform dimension. </p>"},{"location":"markdown/conceptual_design/#export-output-files","title":"Export output files","text":"<p>Output files are written to the required 1D format. Optionally, additional files are written as well.  These optional output files can be enabled in the <code>debug</code> section of the configuration file. </p>"},{"location":"markdown/configuration/","title":"FM2PROF configuration","text":""},{"location":"markdown/configuration/#exec-1--input","title":"Input","text":""},{"location":"markdown/configuration/#exec-1--2dmapoutput","title":"2DMapOutput","text":"<p>type: str</p> <p>default value: </p> <p>Output file from FM2D model (.net file)</p>"},{"location":"markdown/configuration/#exec-1--crosssectionlocationfile","title":"CrossSectionLocationFile","text":"<p>type: str</p> <p>default value: </p> <p>.csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.</p>"},{"location":"markdown/configuration/#exec-1--regionpolygonfile","title":"RegionPolygonFile","text":"<p>type: str</p> <p>default value: </p> <p>User defined polygons in json format</p>"},{"location":"markdown/configuration/#exec-1--sectionpolygonfile","title":"SectionPolygonFile","text":"<p>type: str</p> <p>default value: </p> <p>User defined polygons in json format</p>"},{"location":"markdown/configuration/#exec-1--parameters","title":"Parameters","text":""},{"location":"markdown/configuration/#exec-1--casename","title":"CaseName","text":"<p>type: str</p> <p>default value: </p> <p>Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used</p>"},{"location":"markdown/configuration/#exec-1--maximumpointsinprofile","title":"MaximumPointsInProfile","text":"<p>type: int</p> <p>default value: 20</p> <p>Number of points which are used to generate cross-sections</p>"},{"location":"markdown/configuration/#exec-1--conveyancedetectionmethod","title":"ConveyanceDetectionMethod","text":"<p>type: int</p> <p>default value: 1</p> <p>[0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)</p>"},{"location":"markdown/configuration/#exec-1--absolutevelocitythreshold","title":"AbsoluteVelocityThreshold","text":"<p>type: float</p> <p>default value: 0.1</p> <p>Absolute velocity threshold in m/s. Used to determine storage</p>"},{"location":"markdown/configuration/#exec-1--relativevelocitythreshold","title":"RelativeVelocityThreshold","text":"<p>type: float</p> <p>default value: 0.15</p> <p>Relative velocity threshold (percentage). Used to determine storage</p>"},{"location":"markdown/configuration/#exec-1--minimumdepththreshold","title":"MinimumDepthThreshold","text":"<p>type: float</p> <p>default value: 0.02</p> <p>Minimum depth (m) for storage identification</p>"},{"location":"markdown/configuration/#exec-1--bedlevelcriterium","title":"BedlevelCriterium","text":"<p>type: float</p> <p>default value: 0.05</p> <p>Ignore the lowest percentage of bed level points</p>"},{"location":"markdown/configuration/#exec-1--laketimesteps","title":"LakeTimesteps","text":"<p>type: int</p> <p>default value: 10</p> <p>Number of timesteps that are used for identifying lakes</p>"},{"location":"markdown/configuration/#exec-1--extrapolatestorage","title":"ExtrapolateStorage","text":"<p>type: fm2prof.ini_file.ImportBoolType</p> <p>default value: True</p> <p>Add storage to water level independent cross-section section</p>"},{"location":"markdown/configuration/#exec-1--sdcorrection","title":"SDCorrection","text":"<p>type: fm2prof.ini_file.ImportBoolType</p> <p>default value: True</p> <p>Use summerdike volume correction</p>"},{"location":"markdown/configuration/#exec-1--sdfloodplainbase","title":"SDFloodplainBase","text":"<p>type: float</p> <p>default value: 0.5</p> <p>minimum distance between floodplain base level and crest level in meters</p>"},{"location":"markdown/configuration/#exec-1--sdtransitionheight","title":"SDTransitionHeight","text":"<p>type: float</p> <p>default value: 0.5</p> <p>Transition height at the summer dike (m)</p>"},{"location":"markdown/configuration/#exec-1--sdoptimisationmethod","title":"SDOptimisationMethod","text":"<p>type: int</p> <p>default value: 0</p> <p>[0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both</p>"},{"location":"markdown/configuration/#exec-1--frictionweighingmethod","title":"FrictionWeighingMethod","text":"<p>type: int</p> <p>default value: 0</p> <p>Options. [0] arithmetric mean, [1] Weighted average</p>"},{"location":"markdown/configuration/#exec-1--skipmaps","title":"SkipMaps","text":"<p>type: int</p> <p>default value: 0</p> <p>number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. </p>"},{"location":"markdown/configuration/#exec-1--minimumtotalwidth","title":"MinimumTotalWidth","text":"<p>type: float</p> <p>default value: 0.5</p> <p>Minimum width in meters. Zero width may lead to numerical instability in 1D solvers</p>"},{"location":"markdown/configuration/#exec-1--defaultsection","title":"DefaultSection","text":"<p>type: str</p> <p>default value: floodplain1</p> <p>Default section name to use in cells not covered by a section polygon. Value options: floodplain1, floodplain2 or main</p>"},{"location":"markdown/configuration/#exec-1--defaultregion","title":"DefaultRegion","text":"<p>type: str</p> <p>default value: undefined</p> <p>Default region name to use in cells not covered by a region polygon.</p>"},{"location":"markdown/configuration/#exec-1--debug","title":"Debug","text":""},{"location":"markdown/configuration/#exec-1--exportcssdata","title":"ExportCSSData","text":"<p>type: fm2prof.ini_file.ImportBoolType</p> <p>default value: False</p> <p>If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.</p>"},{"location":"markdown/configuration/#exec-1--exportmapfiles","title":"ExportMapFiles","text":"<p>type: fm2prof.ini_file.ImportBoolType</p> <p>default value: False</p> <p>Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.</p>"},{"location":"markdown/configuration/#exec-1--cssselection","title":"CssSelection","text":"<p>type: fm2prof.ini_file.ImportListType</p> <p>default value: </p> <p>provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections</p>"},{"location":"markdown/configuration/#exec-1--output","title":"Output","text":""},{"location":"markdown/configuration/#exec-1--outputdirectory","title":"OutputDirectory","text":"<p>type: str</p> <p>default value: output</p> <p>Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory</p>"},{"location":"markdown/contributing/","title":"Contributing","text":"<p>This is brief guide on how to contribute to the code. This guide is  written for Deltares developers. At the moment, we are not accepting  external pull requests. </p>"},{"location":"markdown/contributing/#set-up-development-environment","title":"Set up development environment","text":""},{"location":"markdown/contributing/#dependency-management","title":"Dependency management","text":"<p>Dependencies are managed through the standard pyproject.toml  configuration file. </p> <p>Lock files are maintained for the uv and pixi environment managers, but note that our CI system uses <code>uv</code>. We therefore recommend using the uv. </p> <p>With a supported environment manager installed, set up your development environment using the <code>lock</code> command. This will create a virtual environment.</p> uvpixi <pre><code>git clone https://github.com/Deltares/Fm2Prof.git\ncd Fm2Prof\nuv lock \n</code></pre> <pre><code>git clone https://github.com/Deltares/Fm2Prof.git\ncd Fm2Prof\npixi lock \n</code></pre>"},{"location":"markdown/contributing/#style-documentation-conventions","title":"Style &amp; documentation conventions","text":"<p>We use ruff for linting and code formatting.  Documentation is based on mkdocs and mkdocstringds. Numpy, sphinx and google-style docstrings are supported, but when writing new code please use Google-style docstring syntax</p> <p>To support documentation for multiple versions, we use the mike preprocessor.  See \"How to make a new release\" below on how to use mike. </p>"},{"location":"markdown/contributing/#testing","title":"Testing","text":"<p>Automatic tests are run on each pull request and push. A PR cannot be merged unless all tests are passing. To run tests locally, use <code>pytest</code>:</p> uvpixi <pre><code>uv run pytest --cov=fm2prof \n</code></pre> <pre><code>pixi run -e dev pytest --cov=fm2prof \n</code></pre>"},{"location":"markdown/contributing/#deploying","title":"Deploying","text":""},{"location":"markdown/contributing/#locally-build-executable-optional","title":"Locally build executable (optional)","text":"<p>To build a local version of an FM2PROF executable, run:</p> <p><code>uv run pyinstaller FM2PROF_WINDOWS.spec</code></p> <p>Note</p> <p>Executables are no longer automatically made since fm2prof was published on pypi </p>"},{"location":"markdown/contributing/#how-to-make-a-new-release","title":"How to make a new release","text":"<p>Publishing a new release takes some steps. </p>"},{"location":"markdown/contributing/#tag-your-version","title":"Tag your version","text":"<p>After merging a PR to <code>master</code>, first make a new tag. Using version <code>v2.3.0</code> as an example,  a tag can be made via the terminal:</p> <pre><code>git tag v2.3.0\n</code></pre>"},{"location":"markdown/contributing/#make-a-new-release","title":"Make a new release","text":"<p>Use Github interface to draft a new release using the appropriate. Document all changes since the previous version.  If possible, refer to Github Issues. </p>"},{"location":"markdown/contributing/#update-the-documentation","title":"Update the documentation","text":"<p>We use mike as a pre-processor for <code>mkdocs</code>. To update the documentation for a new release, use the following line in a terminal:</p> <pre><code>uv run mike deploy 2.3.0 latest -u\n</code></pre> <p>This will build the documentation for a specific version (e.g. <code>2.3.0</code> for version v2.3.0). The keyword <code>latest</code> will set this to be the default version. The flag <code>-u</code> will overwrite any existing documentation for this versino. </p> <p>Finally, you need to push the documentation to github. First, checkout the documentation branch</p> <pre><code>git checkout gh-pages\n</code></pre> <p>and then push changes to github</p> <pre><code>git push\n</code></pre> <p>The documentation is hosted on github pages, no other steps are necessary. </p>"},{"location":"markdown/glossary/","title":"Glossary","text":""},{"location":"markdown/glossary/#region","title":"Region","text":"<p>Regions are used to have some finer control over which 2D model output is assigned to which 1D cross-section. If no region are defined, 2D model output is assigned to cross-section using k-nearest neighbour. This is not always a good approach, for example if a tributary or retention area. In the figure a section of the River Meuse is plotted near the Blitterswijck retention area. The retention area is demarcated from the main river by levees. Cross-sections generated for the retention area should therefore not 'eat out of' the area of the main channel - which could results in a small cross-section non-physical constriction of the flow.</p> Region polygons are used to prevent cross-sections generated     in the retention area to 'eat out of' the main channel. Within each     region polygon (red borders) nearest neighour is used to assign 2D     points to cross-sections. Points with the same color are associated with     the same 1D cross-section"},{"location":"markdown/glossary/#section","title":"Section","text":"<p>Section are used to divide the cross-section between floodplain and main channel (e.g. the 'floodplain' section and the 'main channel' section). This distinction is only used to assign different roughness values to each section.</p>"},{"location":"markdown/glossary/#water-level-independent-geometry","title":"Water level (in)dependent geometry","text":"<p>It is often not possible to start the 2D computation from a completely dry bed - instead some initial water level is present in the model. This initial condition divides the 1D geometry in water level dependent part and a water level independent part. Below the initial condition, we cannot take advantage of the 2D model to tell us which cells are part of the conveyance and which cells are wet. Instead, the water level is artificially lowered in a number of steps to estimate the volume below the initial water levels.</p>"},{"location":"markdown/glossary/#summerdikes","title":"Summerdikes","text":"<p>Summerdikes are a Dutch term for levees that are designed to be flooded with higher discharges, but not with relatively low floods (i.e.: they withstand summer floods). They contrast with 'winterdikes', which are designed to not flood at all. Summerdikes effectively comparimentalise the floodplain. They can have a profound effect on stage-discharge relationships: as these levees overflow the compartments start flowing which leads to a retention effect. Such an effect cannot be modelled using regulare cross-sections. SOBEK therefore has a 'summerdike' functionality.</p>"},{"location":"markdown/glossary/#control-volume","title":"Control volume","text":"<p>A control volume of a cross-section is the geographical part of the 2D model that is associated with that cross-section. Contol volumes are assigned by k-Nearest Neighbour classification.</p> <p>Note</p> <p>Control volumes are the equivalent of WAQ2PROF's sobekvakken</p> A control volume"},{"location":"markdown/glossary/#lakes","title":"Lakes","text":"<p>Lakes are water bodies that are not hydraulically connected to the main channel in the first few timesteps of the 2D model computation. They do not contribute to the volume present in the control volume until they connect with the rest of the river and will not feature in the water level independent computation.  Water bodies that are connected to the main channel in the first few timesteps do count as volume. However, as these likely do not contribute to conveyance, they will be flagged as 'storage' instead.</p>"},{"location":"markdown/glossary/#cross-section-location","title":"Cross-section location","text":"<p>The cross-section location is defined in the <code>CrossSectionLocationFile</code>.</p>"},{"location":"markdown/glossary/#total-volume","title":"Total volume","text":"<p>The Total volume refers to the volume of water [in m\\^3] within a <code>Control volume</code> for a given water level at the <code>Cross-section location</code>{.interpreted-text role=\"term\"}. The total volume is the sum of the <code>Flow volume</code> and the <code>Storage volume</code>.</p>"},{"location":"markdown/glossary/#flow-volume","title":"Flow volume","text":"<p>The Flow volume is defined as the volume of water [in m\\^3] for which the conditions for flowing water are met. This volume is considered to be available for the conveyance of water through the <code>Control volume</code>.</p> <p>See <code>distinguish_storage</code></p>"},{"location":"markdown/glossary/#storage-volume","title":"Storage volume","text":"<p>The Storage volume is defined as the volume of water [in m\\^3] for which the conditions for flowing water are not met. Storage volume does not contribute to conveyance, but serves only for water retention. Examples include groyne fields and</p> <p>See <code>distinguish_storage</code></p>"},{"location":"markdown/glossary/#total-width","title":"Total width","text":"<p>See <code>Total volume</code></p>"},{"location":"markdown/glossary/#flow-width","title":"Flow width","text":"<p>See <code>Flow volume</code></p>"},{"location":"markdown/installation/","title":"Getting started","text":""},{"location":"markdown/installation/#installation","title":"Installation","text":"<p>FM2PROF is a package written in Python. If you're familiar with Python, you can install FM2PROF with <code>pip</code>, the Python package manager. If not, we recommend the executable. </p>"},{"location":"markdown/installation/#with-pip","title":"With pip","text":"<p>FM2PROF is published as a Python package and can be installed with <code>pip</code>, ideally by using a virtual environment and using Python 3.10 or higher. Open up a terminal and install FM2PROF with:</p> LatestSpecific versionupdate existing install <pre><code>pip install fm2prof\n</code></pre> <pre><code>pip install fm2prof=\"2.2.8\"\n</code></pre> <pre><code>pip install fm2prof --upgrade\n</code></pre> <p>This will also install compatible versions of all dependencies like <code>numpy</code>, and <code>pandas</code>. </p>"},{"location":"markdown/installation/#executable","title":"Executable","text":"<p>FM2PROF is compiled to an executable for Windows (version 1.5.4 and higher). Download them from Releases on the Github home page.</p> <p>The executable provides a command line interface (CLI). To use it, make sure it is available in your Path. To view available options, open a Terminal and type:</p> <pre><code>FM2PROF --help\n</code></pre> <p>Warning</p> <p>The first time you call the executable, it may take a long time to produce results. This is because your OS needs to unpack the executable.</p>"},{"location":"markdown/numerical_methods/","title":"Numerical methods","text":""},{"location":"markdown/numerical_methods/#cross-section-construction","title":"Cross-section construction","text":""},{"location":"markdown/numerical_methods/#conveyance-storage-separation","title":"Conveyance-storage separation","text":"<p>Distinguish conveyance from storage.</p> <p>In 1D hydrodynamic models, flow through a cross-section is resolved assuming a cross-sectionally average velocity. This assumed that the entire cross-section is available to for conveyance. However in reality some parts of the cross-section do not contribute to flow. For example, sections of a river behind a levee where water is stagnant contribute to storage (volume), but not flow.</p> <p>SOBEK enables distinction between 'flow area' and 'storage area'. <code>fm2prof</code> implements methods to resolve from 2D model output which cells add to the 'flow volume' within a control volume and which to the storage volume.</p> <p><code>fm2prof</code> implements two methods. The configuration parameter [<code>ConveyanceDetectionMethod</code>] (configuration.md#exec-1--conveyancedetectionmethod) is used to determine which method is used.</p> <p><code>max_method</code> A cell is considered flowing if the velocity magnitude is more than the average of the three higher flow velocities per outputmap multiplied by the <code>relative velocity threshold</code> OR if the flow velocity meets the absolute threshold [<code>absolute velocity threshold</code>] (configuration.md#exec-1--absolutevelocitythreshold)</p> <p><code>mean_method</code> Not recommended. Legacy method.</p> <pre><code>waterdepth (pd.DataFrame): dataframe of a control volume with waterdepths per cel per output map\nvelocity (pd.DataFrame):  dataframe of a control volume with velocity magnitude per cel per output map\n</code></pre> <pre><code>flow_mask: dataframe of a control volume with the flow condition per cel per output map. `True` means\nflowing, `False` storage.\n</code></pre> Source code in <code>fm2prof\\cross_section.py</code> <pre><code>def _distinguish_conveyance_from_storage(\n    self,\n    waterdepth: pd.DataFrame,\n    velocity: pd.DataFrame,\n) -&gt; pd.DataFrame:\n    \"\"\"Distinguish conveyance from storage.\n\n    In 1D hydrodynamic models, flow through a cross-section is resolved assuming a\n    cross-sectionally average velocity. This assumed that the entire cross-section\n    is available to for conveyance. However in reality some parts of the cross-section\n    do not contribute to flow. For example, sections of a river behind a levee where\n    water is stagnant contribute to storage (volume), but not flow.\n\n    SOBEK enables distinction between 'flow area' and 'storage area'. `fm2prof` implements\n    methods to resolve from 2D model output which cells add to the 'flow volume' within a\n    [control volume](glossary.md#control-volume) and which to the storage volume.\n\n    `fm2prof` implements two methods. The configuration parameter [`ConveyanceDetectionMethod`]\n    (configuration.md#exec-1--conveyancedetectionmethod) is used\n    to determine which method is used.\n\n    **`max_method`**\n    A cell is considered flowing if the velocity magnitude is more than the average\n    of the three higher flow velocities per outputmap multiplied by the\n    [`relative velocity threshold`](configuration.md#exec-1--relativevelocitythreshold) OR\n    if the flow velocity meets the absolute threshold [`absolute velocity threshold`]\n    (configuration.md#exec-1--absolutevelocitythreshold)\n\n    **`mean_method`**\n    Not recommended. Legacy method.\n\n    Args:\n    ----\n        waterdepth (pd.DataFrame): dataframe of a control volume with waterdepths per cel per output map\n        velocity (pd.DataFrame):  dataframe of a control volume with velocity magnitude per cel per output map\n\n    Returns:\n    -------\n        flow_mask: dataframe of a control volume with the flow condition per cel per output map. `True` means\n        flowing, `False` storage.\n\n    \"\"\"\n\n    @staticmethod\n    def max_velocity_method(\n        waterdepth: pd.DataFrame,\n        velocity: pd.DataFrame,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Calculate the max velocity.\n\n        This method was added in version 2.3 because the mean_velocity_method\n        led to unreasonably high conveyance if the river was connected to\n        an inland harbour.\n        \"\"\"\n        # This condition may be redundant\n        waterdepth_condition = waterdepth &gt; 0\n\n        # Determine maximum as the average of the top 3 flow velocities\n        maxv = velocity.max()\n        for i in velocity:\n            maxv[i] = velocity[i].sort_values().iloc[-3:].mean()\n\n        # Relative to max condition\n        relative_velocity_condition = velocity &gt; maxv * self.get_parameter(\n            self.__cs_parameter_relative_threshold,\n        )\n\n        # Absolute flow condition\n        absolute_velocity_condition = velocity &gt; self.get_parameter(\n            self.__cs_parameter_velocity_threshold,\n        )\n\n        # Flow mask determines which cells are conveyance (TRUE)\n        return waterdepth_condition &amp; (\n            relative_velocity_condition | absolute_velocity_condition\n        )\n\n    @staticmethod\n    def mean_velocity_method(\n        waterdepth: np.ndarray,\n        velocity: np.ndarray,\n    ) -&gt; np.ndarray:\n        \"\"\"Calculate mean velocity.\n\n        This was the default method &lt; 2.3. This method leads to unreasonably\n        high conveyance if the river was connected to an inland harbour.\n        \"\"\"\n        # apply rolling average over the velocities\n        # to smooth out extreme values\n        velocity = velocity.rolling(window=10, min_periods=1, center=True).mean()\n\n        return (\n            (waterdepth &gt; 0)\n            &amp; (\n                velocity\n                &gt; self.get_parameter(self.__cs_parameter_velocity_threshold)\n            )\n            &amp; (\n                velocity\n                &gt; self.get_parameter(self.__cs_parameter_relative_threshold)\n                * np.mean(velocity)\n            )\n        )\n\n    match self.get_inifile().get_parameter(\n        self.__cs_parameter_conveyance_detection_method,\n    ):\n        case 0:\n            return mean_velocity_method(waterdepth, velocity)\n        case 1:\n            return max_velocity_method(waterdepth, velocity)\n        case _:\n            self.set_logger_message(\n                \"Invalid conveyance method. Defaulting to [1]\",\n                \"warning\",\n            )\n            return max_velocity_method(waterdepth, velocity)\n</code></pre>"},{"location":"markdown/numerical_methods/#simplification","title":"Simplification","text":"<p>Reduce points while preserving the shape of the geometry.</p> <p>The cross-section geometry generated by <code>fm2prof</code> contains one point per output timestep in the 2D map file. This resolution is often too high given the complexity of the cross-sections, and results in very large input files for the 1D model. Therefore <code>fm2prof</code> includes a simplification algorithm that reduces the number of points while preservering the shape of the geometry. This algorithm reduces as many points until the number specified in <code>MaximumPointsInProfile</code> is reached.</p> <p>We use the Visvalingam-Whyatt method of poly-line vertex reduction<sup>1</sup>. The total width is leading for the simplification of the geometry meaning that the choice for which points to remove to simplify the geometry is based on the total width. Subsequently, the corresponding point are removed from the flow width.</p> <ol> <li> <p>Visvalingam, M and Whyatt J D (1993) \"Line Generalisation by Repeated Elimination of Points\", Cartographic J., 30 (1), 46 - 51 URL: http://web.archive.org/web/20100428020453/http://www2.dcs.hull.ac.uk/CISRG/publications/DPs/DP10/DP10.html     Implemented vertex reduction methods:\u00a0\u21a9</p> </li> </ol> <pre><code>count_after (int): number of points in cross-section after application of this function\n</code></pre> Source code in <code>fm2prof\\cross_section.py</code> <pre><code>def reduce_points(self, count_after: int = 20) -&gt; None:\n    \"\"\"Reduce points while preserving the shape of the geometry.\n\n    The cross-section geometry generated by `fm2prof` contains one point per output\n    timestep in the 2D map file. This resolution is often too high given the\n    complexity of the cross-sections, and results in very large input files for the\n    1D model. Therefore `fm2prof` includes a simplification algorithm that reduces\n    the number of points while preservering the shape of the geometry. This algorithm\n    reduces as many points until the number specified in\n    `MaximumPointsInProfile` is reached.\n\n    We use the Visvalingam-Whyatt method of poly-line vertex reduction[^1].\n    The [total width](glossary.md#total-width) is leading for the simplification of the geometry meaning\n    that the choice for which points to remove to simplify the geometry is based on\n    the total width. Subsequently, the corresponding point are removed from the\n    [flow width](glossary.md#flow-width).\n\n    [^1]:\n        Visvalingam, M and Whyatt J D (1993) \"Line Generalisation by Repeated Elimination of Points\",\n        Cartographic J., 30 (1), 46 - 51\n        URL: http://web.archive.org/web/20100428020453/http://www2.dcs.hull.ac.uk/CISRG/publications/DPs/DP10/DP10.html\n            Implemented vertex reduction methods:\n\n\n    Args:\n    ----\n        count_after (int): number of points in cross-section after application of this function\n\n    \"\"\"\n    n_before_reduction = self.get_number_of_vertices()\n\n    points = np.array(\n        [\n            [self._css_z[i], self._css_total_width[i]]\n            for i in range(n_before_reduction)\n        ],\n    )\n\n    # The number of points is equal to n, it cannot be further reduced\n    reduced_index = np.array([True] * n_before_reduction)\n\n    if n_before_reduction &gt; count_after:\n        try:\n            simplifier = ps.VWSimplifier(points)\n            reduced_index = simplifier.from_number_index(count_after)\n        except Exception as e:\n            self.set_logger_message(\n                \"Exception thrown while using polysimplify: \" + f\"{e!s}\",\n                \"error\",\n            )\n\n    # Write to attributes\n    self.z = self._css_z[reduced_index]\n    self.total_width = self._css_total_width[reduced_index]\n    self.flow_width = self._css_flow_width[reduced_index]\n\n    self.set_logger_message(\n        \"Cross-section reduced from {n_before_reduction} to {len(self.total_width)} points\",\n    )\n\n    self._css_is_reduced = True\n</code></pre>"},{"location":"markdown/numerical_methods/#lake-identification","title":"Lake identification","text":"<p>Determine whether a 2D cell should be marked as Lake.</p> <p>Cells are marked as lake if the following conditions are both met: - the waterdepth on timestep LakeTimeSteps is positive - the waterdepth on timestep LakeTimeSteps is at least 1 cm higher than the waterlevel on timestep 0.</p> <p>Next, the following steps are taken</p> <ul> <li>It is determined at what timestep the waterlevel in the lake starts rising. From that point on the lake counts as regular geometry and counts toward the total volume. A cell is considered active if its waterlevel has risen by 1 mm.</li> <li>A correction matrix is built that contains the 'lake water level' for each lake cell. This matrix is subtracted from the waterdepth to compute volumes.</li> </ul> <pre><code>waterdepth (pd.DataFrame): a DataFrame containing all waterdepth output in the [control volume]\n(glossary.md#control-volume)\n</code></pre> <pre><code>lake_mask: mask of all cells that are a 'lake'\nwet_not_lake_mask: mask of all cells that are wet, but not a lake\nlake_depth_correction: the depth of a lake at the start of the 2D computation\n</code></pre> Source code in <code>fm2prof\\cross_section.py</code> <pre><code>def _identify_lakes(self, waterdepth: pd.DataFrame) -&gt; np.ndarray:\n    \"\"\"Determine whether a 2D cell should be marked as [Lake](glossary.md#Lakes).\n\n    Cells are marked as lake if the following conditions are both met:\n    - the waterdepth on timestep [LakeTimeSteps](configuration.md#exec-1--laketimesteps) is positive\n    - the waterdepth on timestep [LakeTimeSteps](configuration.md#exec-1--laketimesteps) is at least\n    1 cm higher than the waterlevel on timestep 0.\n\n    Next, the following steps are taken\n\n    - It is determined at what timestep the waterlevel in the lake starts rising. From that point on the lake counts\n    as regular geometry and counts toward the total volume. A cell is considered active if its waterlevel has risen\n    by 1 mm.\n    - A correction matrix is built that contains the 'lake water level' for each lake cell. This matrix is\n    subtracted from the waterdepth to compute volumes.\n\n\n    Args:\n    ----\n        waterdepth (pd.DataFrame): a DataFrame containing all waterdepth output in the [control volume]\n        (glossary.md#control-volume)\n\n    Returns:\n    -------\n        lake_mask: mask of all cells that are a 'lake'\n        wet_not_lake_mask: mask of all cells that are wet, but not a lake\n        lake_depth_correction: the depth of a lake at the start of the 2D computation\n\n    \"\"\"\n    # preallocate arrays\n    plassen_depth_correction = np.zeros(waterdepth.shape, dtype=float)\n\n    # check for non-rising waterlevels\n    waterdepth_diff = np.diff(waterdepth, n=1, axis=-1)\n\n    # find all wet cells\n    wet_mask: np.ndarray = waterdepth &gt; 0\n\n    # find all lakes\n    lake_mask = (\n        waterdepth.T.iloc[self.get_parameter(self.__cs_parameter_plassen_timesteps)]\n        &gt; 0\n    ) &amp; (\n        np.abs(\n            waterdepth.T.iloc[\n                self.get_parameter(self.__cs_parameter_plassen_timesteps)\n            ]\n            - waterdepth.T.iloc[0],\n        )\n        &lt;= 0.01  #  noqa: PLR2004 NOTE: What is this value?\n    )\n\n    self.plassen_mask = lake_mask\n\n    # Plassen_mask_time is to determine at whata timestep the lake starts rising again.\n    plassen_mask_time = np.zeros((len(waterdepth.T), len(lake_mask)), dtype=bool)\n\n    # At t=0, all lakes are inactive\n    plassen_mask_time[0, :] = lake_mask\n\n    # walk through dataframe in time, for each timestep check\n    # when to unmask a plassen cell\n    for i, diff in enumerate(waterdepth_diff.T):\n        final_mask = reduce(\n            np.logical_and,\n            [(diff &lt;= 0.001), (plassen_mask_time[i] == True)],  # noqa: E712, PLR2004,  NOTE what does 0.001 represent?\n        )\n        plassen_mask_time[i + 1, :] = final_mask\n\n    plassen_mask_time = pd.DataFrame(plassen_mask_time).T\n\n    # The depth of a lake is the waterdepth at t=0\n    for i, _depths in enumerate(waterdepth):\n        plassen_depth_correction[lake_mask, i] = -waterdepth.T.iloc[0][lake_mask]\n\n    # correct wet cells for plassen\n    wet_not_plas_mask = reduce(\n        np.logical_and,\n        [(wet_mask == True), np.asarray(plassen_mask_time == False)],  # noqa: E712\n    )\n\n    return lake_mask, wet_not_plas_mask, plassen_depth_correction\n</code></pre>"},{"location":"markdown/quickstart/","title":"Tutorial","text":"<p>In this tutorial we will walk through the basics of creating a 1D model input from a 2D model.</p> <p>To use , we need at least two input files:</p> <ul> <li><code>2DMapOutput</code></li> <li><code>CrossSectionLocationFile</code></li> </ul> <p>in this tutorial we will use the test data bundled with the package. You will find this in the source directory:</p> <pre><code># 2DMapOutput\ntests\\test_data\\cases\\case_02_compound\\Data\\2DModelOutput\\FlowFM_map.nc \n# CrossSectionLocationFile\ntests\\test_data\\cases\\case_02_compound\\Data\\cross_section_locations.xyz  \n</code></pre> <p>This case is a simple 2D compound channel model.</p>"},{"location":"markdown/quickstart/#create-a-new-project","title":"Create a new project","text":"<p>To start a new project:</p> PythonCLI <pre><code>from fm2prof.IniFile import IniFile\n\ninifile = IniFile().print_configuration()\nini_path = f\"MyProject.ini\"\n\nwith open(ini_path, \"w\") as f:\n    f.write(inifile)\n</code></pre> <pre><code>FM2PROF create MyProject\n</code></pre> <p>This will create a valid configuration file with all parameters set to their default values. </p>"},{"location":"markdown/quickstart/#modify-the-input","title":"Modify the input","text":"<p>For the purpose of this tutorial, move the 2D model simulation file to [input]{.title-ref}. This is not a requirement - you can refer to any location on your pc.</p> <p>Open the configuration file with your favorite text editor and change the following two settings to your input data:</p> <pre><code>[input]\n2DMapOutput                   =         # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\n</code></pre> <p>To be sure you used the correct data, run:</p> PythonCLI <pre><code>from fm2prof import Project\n\nproject = Project(\"MyProject.ini\")\n</code></pre> <pre><code>FM2PROF check MyProject\n</code></pre> <p>Study the output. Errors indicate that something is wrong with your input. In that case, you will need to correct the configurationfile.</p>"},{"location":"markdown/quickstart/#run-fm2prof","title":"Run FM2PROF","text":"<p>You should also see a print-out of the configuration file. These are the settings that will be used and can be altered using a config file. The configuration file does not need all parameters to be specified. If a parameter is not in the configuration file, default values will be used.</p> <p>The following examples run FM2PROF, overwrite any existing results and produce figures of the generated cross-sections. </p> PythonCLI <pre><code>from fm2prof import Project\nfrom fm2prof.utils import VisualiseOutput\n\n# load project\nproject = Project(\"MyProject.ini\")\n\n# overwrite = True overwrites any existing output\nproject.run(overwrite=True)\n\n# to visualize cross-sectino putput:\nvis = VisualiseOutput(\n            project.get_output_directory(), \n            logger=project.get_logger()\n        )\n\nfor css in vis.cross_sections:\n    vis.figure_cross_section(css)\n</code></pre> <pre><code>FM2PROF run MyProject -o -p\n</code></pre> <p>All <code>outputFiles</code> are written to the <code>output</code> directory specified in the FM2PROF configuration file. </p> <p>After generating output it is important to check whether everything went well. See the following links to learn more about available tools:</p> <ul> <li>Inspection cross-sections using a notebook</li> </ul>"},{"location":"markdown/utils/","title":"Utilities API","text":"<p>FM2PROF includes a set of utilities to analyse its output. </p>"},{"location":"markdown/utils/#compare1d2d","title":"Compare1D2D","text":"<p>               Bases: <code>ModelOutputReader</code></p> <p>Utility to compare the results of a 1D and 2D model through visualisation and statistical post-processing.</p> Note <p>If 2D and 1D netCDF input files are provided, they will first be converted to csv files. Once csv files are present, the original netCDF files are no longer used. In that case, the arguments to <code>path_1d</code> and <code>path_2d</code> should be <code>None</code>.</p> Example usage <pre><code>from fm2prof import Project, utils\nproject = Project(fr'tests/test_data/compare1d2d/cases/case1/fm2prof.ini')\nplotter = utils.Compare1D2D(project=project,\n                            start_time=datetime(year=2000, month=1, day=5))\n\nplotter.figure_at_station(\"NR_919.00\")\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D--parameters","title":"Parameters","text":"<pre><code>project: `fm2prof.Project` object.\npath_1d: path to SOBEK dimr directory\npath_2d: path to his nc file\nroutes: list of branch abbreviations, e.g. ['NR', 'LK']\nstart_time: start time for plotting and analytics. Use this to crop the time to prevent initalisation from\naffecting statistics.\nstop_time: stop time for plotting and analytics.\nstyle: `PlotStyles` style\n</code></pre> <p>Instantiate a Compare1D2D object.</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    project: Project,\n    path_1d: Path | str | None = None,\n    path_2d: Path | str | None = None,\n    routes: list[list[str]] | None = None,\n    start_time: None | datetime = None,\n    stop_time: None | datetime = None,\n    style: str = \"sito\",\n) -&gt; None:\n    \"\"\"Instantiate a Compare1D2D object.\"\"\"\n    if project:\n        super().__init__(logger=project.get_logger(), start_time=start_time, stop_time=stop_time)\n        self.output_path = project.get_output_directory()\n    else:\n        super().__init__()\n\n    if isinstance(path_1d, (Path, str)) and Path(path_1d).is_file():\n        self.path_flow1d = path_1d\n    else:\n        self.set_logger_message(\n            f\"1D netCDF file does not exist or is not provided. Input provided: {path_1d}.\",\n            \"debug\",\n        )\n    if isinstance(path_1d, (Path, str)) and Path(path_2d).is_file():\n        self.path_flow2d = path_2d\n    else:\n        self.set_logger_message(\n            f\"2D netCDF file does not exist or is not provided. Input provided: {path_2d}.\",\n            \"debug\",\n        )\n\n    # Defaults\n    self.routes = routes\n    self.statistics = None\n    self._data_1d_h: pd.DataFrame = None\n    self._data_2d_h: pd.DataFrame = None\n    self._data_1d_h_digitized: pd.DataFrame = None\n    self._data_2d_h_digitized: pd.DataFrame = None\n    self._qsteps = np.arange(0, 100 * np.ceil(18000 / 100), 200)\n\n    # initiate plotstyle\n    self._error_colors = [\"#7e3e00\", \"#FF4433\", \"#d86a00\"]\n    self._color_error = self._error_colors[1]\n    self._color_scheme = COLORSCHEMES[\"Koeln\"]\n    self._plotstyle: str = style\n    PlotStyles.apply(style=self._plotstyle)\n\n    # set start time\n    self.start_time = start_time\n    self.stop_time = stop_time\n\n    self.read_all_data()\n    self.digitize_data()\n\n    # create output folder\n    output_dirs = [\n        \"figures/longitudinal\",\n        \"figures/discharge\",\n        \"figures/heatmaps\",\n        \"figures/stations\",\n    ]\n    for od in output_dirs:\n        self.output_path.joinpath(od).mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.colorscheme","title":"<code>colorscheme: str</code>  <code>property</code>","text":"<p>Color scheme.</p>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.file_1d_h_digitized","title":"<code>file_1d_h_digitized: Path</code>  <code>property</code>","text":"<p>Return 1D water level digitized file path.</p>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.file_2d_h_digitized","title":"<code>file_2d_h_digitized: Path</code>  <code>property</code>","text":"<p>Return 2D water level digitized file path.</p>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.routes","title":"<code>routes: list[list[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>Return routes.</p>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.digitize_data","title":"<code>digitize_data()</code>","text":"<p>Compute the average for a given bin for 1D and 2D water level data.</p> <p>Use to make Q-H graphs instead of T-H graph</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def digitize_data(self) -&gt; None:\n    \"\"\"Compute the average for a given bin for 1D and 2D water level data.\n\n    Use to make Q-H graphs instead of T-H graph\n    \"\"\"\n    if self.file_1d_h_digitized.is_file():\n        self.set_logger_message(\"Using existing digitized file for 1d\")\n        self._data_1d_h_digitized = pd.read_csv(self.file_1d_h_digitized, index_col=0)\n    else:\n        self._data_1d_h_digitized = self._digitize_data(self._data_1d_h, self._data_1d_q, self._qsteps)\n        self._data_1d_h_digitized.to_csv(self.file_1d_h_digitized)\n    if self.file_2d_h_digitized.is_file():\n        self.set_logger_message(\"Using existing digitized file for 2d\")\n        self._data_2d_h_digitized = pd.read_csv(self.file_2d_h_digitized, index_col=0)\n    else:\n        self._data_2d_h_digitized = self._digitize_data(self._data_2d_h, self._data_2d_q, self._qsteps)\n        self._data_2d_h_digitized.to_csv(self.file_2d_h_digitized)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.eval","title":"<code>eval()</code>","text":"<p>Create multiple figures.</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def eval(self) -&gt; None:\n    \"\"\"Create multiple figures.\"\"\"\n    for route in tqdm.tqdm(self.routes):\n        self.set_logger_message(f\"Making figures for route {route}\")\n        self.figure_longitudinal_rating_curve(route)\n        self.figure_longitudinal_time(route)\n        self.heatmap_rating_curve(route)\n        self.heatmap_time(route)\n\n    self.set_logger_message(\"Making figures for stations\")\n    for station in tqdm.tqdm(self.stations(), total=self._data_1d_h.shape[1]):\n        self.figure_at_station(station)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_at_station","title":"<code>figure_at_station(station, func='time', *, savefig=True)</code>","text":"<p>Create a figure with the timeseries at a single observation station.</p> <p>Parameters:</p> Name Type Description Default <code>station</code> <code>str</code> <p>name of station. use <code>stations</code> method to list all station names</p> required <code>func</code> <code>str</code> <p>use <code>time</code> for a timeseries and <code>qh</code> for rating curve</p> <code>'time'</code> <code>savefig</code> <code>bool</code> <p>if True, saves to png. If False, returned FigureOutput. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>FigureOutput | None</code> <p>FigureOutput | None: FigureOutput object or None if savefig is set to True.</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_at_station(self, station: str, func: str = \"time\", *, savefig: bool = True) -&gt; FigureOutput | None:\n    \"\"\"Create a figure with the timeseries at a single observation station.\n\n    Args:\n        station (str): name of station. use `stations` method to list all station names\n        func (str, optional):  use `time` for a timeseries and `qh` for rating curve\n        savefig (bool, optional):if True, saves to png. If False, returned FigureOutput. Defaults to True.\n\n    Returns:\n        FigureOutput | None: FigureOutput object or None if savefig is set to True.\n\n    \"\"\"\n    fig, ax = plt.subplots(1, figsize=(12, 5))\n    error_ax = ax.twinx()\n\n    # q/h view\n    match func.lower():\n        case \"qh\":\n            ax.plot(\n                self._qsteps,\n                self._data_2d_h_digitized[station],\n                \"--\",\n                linewidth=2,\n                label=\"2D\",\n            )\n            ax.plot(\n                self._qsteps,\n                self._data_1d_h_digitized[station],\n                \"-\",\n                linewidth=2,\n                label=\"1D\",\n            )\n            ax.set_title(f\"{station}\\nQH-relatie\")\n            ax.set_title(\"QH-relatie\")\n            ax.set_xlabel(\"Afvoer [m$^3$/s]\")\n            ax.set_ylabel(\"Waterstand [m+NAP]\")\n            error_ax.plot(\n                self._qsteps,\n                self._data_1d_h_digitized[station] - self._data_2d_h_digitized[station],\n                \".\",\n                color=self._color_error,\n            )\n        case \"time\":\n            ax.plot(self.data_2d_h[station], \"--\", linewidth=2, label=\"2D\")\n            ax.plot(self.data_1d_h[station], \"-\", linewidth=2, label=\"1D\")\n\n            ax.set_ylabel(\"Waterstand [m+NAP]\")\n            ax.set_title(f\"{station}\\nTijdreeks\")\n\n            error_ax.plot(\n                self.data_1d_h[station] - self.data_2d_h[station],\n                \".\",\n                label=\"1D-2D\",\n                color=self._color_error,\n            )\n\n    # statistics\n    stats = self._get_statistics(station)\n\n    stats_labels = [\n        f\"bias={stats['bias']:.2f} m\",\n        f\"std={stats['std']:.2f} m\",\n        f\"MAE={stats['mae']:.2f} m\",\n    ]\n    stats_handles = [mpatches.Patch(color=\"white\")] * len(stats_labels)\n\n    # Style\n    fig, lgd = PlotStyles.apply(\n        fig=fig,\n        style=self._plotstyle,\n        use_legend=True,\n        extra_labels=[stats_handles, stats_labels],\n    )\n\n    self._style_error_axes(error_ax, ylim=[-1, 1])\n\n    fig.tight_layout()\n\n    if savefig:\n        fig.savefig(\n            self.output_path.joinpath(\"figures/stations\").joinpath(f\"{station}.png\"),\n            bbox_extra_artists=[lgd],\n            bbox_inches=\"tight\",\n        )\n        plt.close()\n        return None\n\n    return FigureOutput(fig=fig, axes=ax, legend=lgd)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_compare_discharge_at_stations","title":"<code>figure_compare_discharge_at_stations(stations, title='no_title', *, savefig=True)</code>","text":"<p>Comparea discharge distribution over two stations.</p> <p>Like <code>Compare1D2D.figure_at_station</code>.</p> <p>Example usage: <pre><code>Compare1D2().figure_compare_discharge_at_stations(stations=[\"WL_869.00\", \"PK_869.00\"])\n</code></pre> Figures are saved to <code>[Compare1D2D.output_path]/figures/discharge</code></p> <p>Example output:</p> <p>.. figure:: figures_utils/discharge/example.png</p> <pre><code>Example output figure\n</code></pre> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_compare_discharge_at_stations(\n    self,\n    stations: list[str],\n    title: str = \"no_title\",\n    *,\n    savefig: bool = True,\n) -&gt; FigureOutput | None:\n    \"\"\"Comparea discharge distribution over two stations.\n\n    Like `Compare1D2D.figure_at_station`.\n\n    Example usage:\n    ``` py\n    Compare1D2().figure_compare_discharge_at_stations(stations=[\"WL_869.00\", \"PK_869.00\"])\n    ```\n    Figures are saved to `[Compare1D2D.output_path]/figures/discharge`\n\n    Example output:\n\n    .. figure:: figures_utils/discharge/example.png\n\n        Example output figure\n\n    \"\"\"\n    fig, axs = plt.subplots(2, 1, figsize=(12, 10))\n\n    ax_error = axs[0].twinx()\n    ax_error.set_zorder(axs[0].get_zorder() - 1)  # default zorder is 0 for ax1 and ax2\n\n    if len(stations) != 2:  # noqa: PLR2004\n        err_msg = \"Must define 2 stations\"\n        raise ValueError(err_msg)\n\n    linestyles_2d = [\"-\", \"--\"]\n    for j, station in enumerate(stations):\n        if station not in self.stations():\n            self.set_logger_message(f\"{station} not known\", \"warning\")\n\n        # tijdserie\n        axs[0].plot(\n            self.data_2d_q[station],\n            label=f\"2D, {station.split('_')[0]}\",\n            linewidth=2,\n            linestyle=linestyles_2d[j],\n        )\n        axs[0].plot(\n            self.data_1d_q[station],\n            label=f\"1D, {station.split('_')[0]}\",\n            linewidth=2,\n            linestyle=\"-\",\n        )\n\n    ax_error.plot(\n        self._data_1d_q[station] - self._data_2d_q[station],\n        \".\",\n        color=\"r\",\n        markersize=5,\n        label=\"1D-2D\",\n    )\n\n    # discharge distribution\n\n    q_2d = self.data_2d_q[stations]\n    q_1d = self.data_1d_q[stations]\n    axs[1].plot(\n        q_2d.sum(axis=1),\n        (q_2d.iloc[:, 0] / q_2d.sum(axis=1)) * 100,\n        linewidth=2,\n        linestyle=\"--\",\n    )\n    axs[1].plot(\n        q_1d.sum(axis=1),\n        (q_1d.iloc[:, 0] / q_1d.sum(axis=1)) * 100,\n        linewidth=2,\n        linestyle=\"-\",\n    )\n    axs[1].plot(\n        q_2d.sum(axis=1),\n        (q_2d.iloc[:, 1] / q_2d.sum(axis=1)) * 100,\n        linewidth=2,\n        linestyle=\"--\",\n    )\n    axs[1].plot(\n        q_1d.sum(axis=1),\n        (q_1d.iloc[:, 1] / q_1d.sum(axis=1)) * 100,\n        linewidth=2,\n        linestyle=\"-\",\n    )\n\n    # style\n    axs[1].set_ylim(0, 100)\n    axs[1].set_title(\"afvoerverdeling\")\n    axs[1].set_ylabel(\"percentage t.o.v. totaal\")\n    axs[1].set_xlabel(\"afvoer bovenstrooms [m$^3$/s]\")\n    axs[0].set_ylabel(\"afvoer [m$^3$/s]\")\n    axs[0].set_title(\"tijdserie\")\n\n    suptitle = plt.suptitle(title.upper())\n\n    # Style figure\n    fig, lgd = PlotStyles.apply(fig=fig, style=self._plotstyle, use_legend=True)\n    self._style_error_axes(ax_error, ylim=[-500, 500], ylabel=\"1D-2D [m$^3$/s]\")\n    fig.tight_layout()\n\n    if savefig:\n        fig.savefig(\n            self.output_path.joinpath(\"figures/discharge\").joinpath(f\"{title}.png\"),\n            bbox_extra_artists=[lgd, suptitle],\n            bbox_inches=\"tight\",\n        )\n        plt.close()\n    return FigureOutput(fig=fig, axes=axs, legend=lgd)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_longitudinal","title":"<code>figure_longitudinal(route, stat='time', label='', add_to_fig=None, *, savefig=True)</code>","text":"<p>Create a figure along a <code>route</code>.</p> <p>Content of figure depends on <code>stat</code>. Figures are saved to <code>[Compare1D2D.output_path]/figures/longitudinal</code></p> <p>Example output:</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>list[str]</code> <p>List of branches (e.g. ['NK', 'LK'])</p> required <code>stat</code> <code>str</code> <p>What type of longitudinal plot to make (options: \"time\", \"last3\", \"last25\", \"max3\",</p> <code>'time'</code> <code>label</code> <code>str</code> <p>Label of figure. Defaults to \"\".</p> <code>''</code> <code>add_to_fig</code> <code>FigureOutput | None</code> <p>if <code>FigureOutput</code> is provided, adds content to figure. Defaults to None.</p> <code>None</code> <code>savefig</code> <code>bool</code> <p>if true, figure is saved to png file. If false, <code>FigureOutput</code>      returned, which is input for <code>add_to_fig</code>. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>FigureOutput | None</code> <p>FigureOutput | None: FigureOutput object or None</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_longitudinal(\n    self,\n    route: list[str],\n    stat: str = \"time\",\n    label: str = \"\",\n    add_to_fig: FigureOutput | None = None,\n    *,\n    savefig: bool = True,\n) -&gt; FigureOutput | None:\n    \"\"\"Create a figure along a `route`.\n\n    Content of figure depends on `stat`. Figures are saved to `[Compare1D2D.output_path]/figures/longitudinal`\n\n    Example output:\n\n    ![title](../figures/test_results/compare1d2d/BR-PK-IJ.png)\n\n\n    Args:\n        route (list[str]): List of branches (e.g. ['NK', 'LK'])\n        stat (str, optional): What type of longitudinal plot to make (options: \"time\", \"last3\", \"last25\", \"max3\",\n        \"max13\"). Defaults to \"time\".\n        label (str, optional): Label of figure. Defaults to \"\".\n        add_to_fig (FigureOutput | None, optional):if `FigureOutput` is provided, adds content to figure.\n            Defaults to None.\n        savefig (bool, optional): if true, figure is saved to png file. If false, `FigureOutput`\n                 returned, which is input for `add_to_fig`. Defaults to True.\n\n\n\n    Returns:\n        FigureOutput | None: FigureOutput object or None\n\n    \"\"\"\n    # Get route and stations along route\n    routename = \"-\".join(route)\n\n    # Make configurable in the future\n    labelfunc = self._lmw_func\n\n    # TIME FUNCTION plot line every delta_days days\n    match stat:\n        case \"time\":\n            lines = self._time_func(route=route)\n        case y if y in [\"last3\", \"last25\", \"max3\", \"max13\"]:\n            lines = self._stat_func(stat=y, route=route)\n        case _:\n            err_msg = f\"{stat} is unknown statistics\"\n            raise KeyError(err_msg)\n\n    # Get figure object\n    if add_to_fig is None:\n        fig, axs = plt.subplots(2, 1, figsize=(12, 12))\n    else:\n        fig = add_to_fig.fig\n        axs = add_to_fig.axes\n\n    # Filtering which stations to plot\n    if add_to_fig is None:\n        station_names, station_locs, _ = self.get_route(route)\n        st_names, st_locs = labelfunc(station_names, station_locs)\n        h1d = self.get_data_along_route(data=self.data_1d_h, route=route)\n        for st_name, st_loc in zip(st_names, st_locs):\n            for ax in axs:\n                ax.axvline(x=st_loc, linestyle=\"--\")\n\n            axs[0].text(\n                st_loc,\n                h1d.min().min(),\n                st_name,\n                fontsize=12,\n                rotation=90,\n                horizontalalignment=\"left\",\n                verticalalignment=\"bottom\",\n            )\n\n    for line in lines:\n        axs[0].plot(line.get(\"1D\"), label=f\"{label} {line.get('label')}\")\n\n        axs[0].set_ylabel(\"Waterstand [m+NAP]\")\n        routestr = \"-\".join(route)\n\n        axs[0].set_title(f\"route: {routestr}\")\n\n        axs[1].plot(line.get(\"1D\") - line.get(\"2D\"))\n        axs[1].set_ylabel(\"Verschil 1D-2D [m]\")\n\n        for ax in axs:\n            ax.set_xlabel(\"Rivierkilometers\")\n            ax.xaxis.set_major_locator(MultipleLocator(20))\n            ax.xaxis.set_minor_locator(MultipleLocator(10))\n\n    axs[1].set_ylim(-1, 1)\n    fig, lgd = PlotStyles.apply(fig=fig, style=self._plotstyle, use_legend=True)\n\n    if savefig:\n        plt.tight_layout()\n        fig.savefig(\n            self.output_path.joinpath(f\"figures/longitudinal/{routename}.png\"),\n            bbox_extra_artists=[lgd],\n            bbox_inches=\"tight\",\n        )\n        plt.close()\n\n    return FigureOutput(fig=fig, axes=axs, legend=lgd)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_longitudinal_rating_curve","title":"<code>figure_longitudinal_rating_curve(route)</code>","text":"<p>Create a figure along a route with lines at various dicharges.</p> <p>To to this, rating curves are generated at each point by digitizing the model output.</p> <p>Figures are saved to <code>[Compare1D2D.output_path]/figures/longitudinal</code></p> <p>Example output:</p> <p>.. figure:: figures_utils/longitudinal/example_rating_curve.png</p> <pre><code>example output figure\n</code></pre> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_longitudinal_rating_curve(self, route: list[str]) -&gt; None:\n    \"\"\"Create a figure along a route with lines at various dicharges.\n\n    To to this, rating curves are generated at each point by digitizing\n    the model output.\n\n    Figures are saved to `[Compare1D2D.output_path]/figures/longitudinal`\n\n    Example output:\n\n    .. figure:: figures_utils/longitudinal/example_rating_curve.png\n\n        example output figure\n\n    \"\"\"\n    routename = \"-\".join(route)\n    _, _, lmw_stations = self.get_route(route)\n\n    h1d = self.get_data_along_route(data=self._data_1d_h_digitized, route=route)\n    h2d = self.get_data_along_route(data=self._data_2d_h_digitized, route=route)\n\n    discharge_steps = list(self._iter_discharge_steps(h1d.T, n=8))\n    if len(discharge_steps) &lt; 1:\n        self.set_logger_message(\"There is too little data to plot a QH relationship\", \"error\")\n        return\n\n    # Plot LMW station locations\n    fig, axs = plt.subplots(2, 1, figsize=(12, 10))\n    prevloc = -9999\n    for lmw in lmw_stations:\n        if lmw is None:\n            continue\n        newloc = max(lmw[1], prevloc + 3)\n        prevloc = lmw[1]\n        for ax in axs:\n            ax.axvline(x=lmw[1], linestyle=\"--\", color=\"#7a8ca0\")\n        axs[0].text(\n            newloc,\n            h1d[discharge_steps[0]].min(),\n            lmw[0],\n            fontsize=12,\n            rotation=90,\n            horizontalalignment=\"right\",\n            verticalalignment=\"bottom\",\n        )\n\n    # Plot betrekkingslijnen\n    for discharge in discharge_steps:\n        axs[0].plot(h1d[discharge], label=f\"{discharge:.0f} m$^3$/s\")\n        axs[0].set_ylabel(\"waterstand [m+nap]\")\n        routestr = \"-\".join(route)\n\n        axs[0].set_title(f\"Betrekkingslijnen\\n{routestr}\")\n\n        axs[1].plot(h1d[discharge] - h2d[discharge])\n        axs[1].set_ylabel(\"Verschil 1D-2D [m]\")\n\n        for ax in axs:\n            ax.set_xlabel(\"rivierkilometers\")\n            ax.xaxis.set_major_locator(MultipleLocator(20))\n            ax.xaxis.set_minor_locator(MultipleLocator(10))\n\n    # style figure\n    axs[1].set_ylim(-1, 1)\n    fig, lgd = PlotStyles.apply(fig, style=self._plotstyle, use_legend=True)\n    plt.tight_layout()\n    fig.savefig(\n        self.output_path.joinpath(\n            f\"figures/longitudinal/{routename}_rating_curve.png\",\n        ),\n        bbox_extra_artists=[lgd],\n        bbox_inches=\"tight\",\n    )\n    plt.close()\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_longitudinal_time","title":"<code>figure_longitudinal_time(route)</code>","text":"<p>Create a figure along a <code>route</code>.</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_longitudinal_time(self, route: list[str]) -&gt; None:\n    \"\"\"Create a figure along a `route`.\"\"\"\n    warnings.warn(  # noqa: B028\n        'Method figure_longitudinal_time will be removed in the future. Use figure_longitudinal(route, stat=\"time\")'\n        \"instead\",\n        category=DeprecationWarning,\n    )\n\n    self.figure_longitudinal(route, stat=\"time\")\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.get_data_along_route","title":"<code>get_data_along_route(data, route)</code>","text":"<p>Get data along route.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with data</p> required <code>route</code> <code>list[str]</code> <p>list with route data</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: data</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def get_data_along_route(self, data: pd.DataFrame, route: list[str]) -&gt; pd.DataFrame:\n    \"\"\"Get data along route.\n\n    Args:\n        data (pd.DataFrame): DataFrame with data\n        route (list[str]): list with route data\n\n    Returns:\n        pd.DataFrame: data\n\n    \"\"\"\n    stations, rkms, _ = self.get_route(route)\n\n    tmp_data = []\n    tmp_data = [data[station] for station in stations]\n\n    route_data_df = pd.DataFrame(index=rkms, data=tmp_data)\n\n    # drop duplicates\n    return route_data_df.drop_duplicates()\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.get_data_along_route_for_time","title":"<code>get_data_along_route_for_time(data, route, time_index)</code>","text":"<p>Get data along route for a given time index.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>Dataframe with data</p> required <code>route</code> <code>list[str]</code> <p>list of route</p> required <code>time_index</code> <code>int</code> <p>time index</p> required <p>Returns:</p> Type Description <code>Series</code> <p>pd.Series: Series containing route data</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def get_data_along_route_for_time(self, data: pd.DataFrame, route: list[str], time_index: int) -&gt; pd.Series:\n    \"\"\"Get data along route for a given time index.\n\n    Args:\n        data (pd.DataFrame): Dataframe with data\n        route (list[str]): list of route\n        time_index (int): time index\n\n    Returns:\n        pd.Series: Series containing route data\n\n    \"\"\"\n    stations, rkms, _ = self.get_route(route)\n\n    tmp_data = []\n    tmp_data = [data[station].iloc[time_index] for station in stations]\n    return pd.Series(index=rkms, data=tmp_data)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.get_route","title":"<code>get_route(route)</code>","text":"<p>Return a sorted list of stations along a route, with rkms.</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def get_route(self, route: list[str]) -&gt; tuple[list[str], list[float], list[tuple[str, float]]]:\n    \"\"\"Return a sorted list of stations along a route, with rkms.\"\"\"\n    station_names = self._data_2d_h.columns\n\n    # Parse names\n    rkms = self._names_to_rkms(station_names)\n    branches = self._names_to_branches(station_names)\n\n    # select along route\n    routekms = []\n    stations = []\n    lmw_stations = []\n\n    for stop in route:\n        indices = [i for i, b in enumerate(branches) if b == stop]\n        routekms.extend([rkms[i] for i in indices])\n        stations.extend([station_names[i] for i in indices])\n        lmw_stations.extend([(station_names[i], rkms[i]) for i in indices if \"LMW\" in station_names[i]])\n\n    # sort data\n    sorted_indices = np.argsort(routekms)\n    sorted_stations = [stations[i] for i in sorted_indices if routekms[i] is not np.nan]\n    sorted_rkms = [routekms[i] for i in sorted_indices if routekms[i] is not np.nan]\n\n    # sort lmw stations\n    lmw_stations = [lmw_stations[j] for j in np.argsort([i[1] for i in lmw_stations])]\n    return sorted_stations, sorted_rkms, lmw_stations\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.heatmap_rating_curve","title":"<code>heatmap_rating_curve(route)</code>","text":"<p>Create a 2D heatmap along a route.</p> <p>The horizontal axis uses the digitized rating curves to match the two models</p> <p>Figures are saved to <code>[Compare1D2D.output_path]/figures/heatmap</code></p> <p>Example output:</p> <p>.. figure:: figures_utils/heatmaps/example_rating_curve.png</p> <pre><code>example output figure\n</code></pre> Source code in <code>fm2prof\\utils.py</code> <pre><code>def heatmap_rating_curve(self, route: list[str]) -&gt; None:\n    \"\"\"Create a 2D heatmap along a route.\n\n    The horizontal axis uses the digitized rating curves to match the two models\n\n    Figures are saved to `[Compare1D2D.output_path]/figures/heatmap`\n\n    Example output:\n\n    .. figure:: figures_utils/heatmaps/example_rating_curve.png\n\n        example output figure\n\n    \"\"\"\n    routename = \"-\".join(route)\n    _, _, lmw_stations = self.get_route(route)\n    data = self._data_1d_h_digitized - self._data_2d_h_digitized\n\n    routedata = self.get_data_along_route(data.dropna(how=\"all\"), route)\n\n    fig, ax = plt.subplots(1, figsize=(12, 7))\n    im = ax.pcolormesh(\n        routedata.columns,\n        routedata.index,\n        routedata,\n        cmap=\"Spectral_r\",\n        vmin=-1,\n        vmax=1,\n    )\n    for lmw in lmw_stations:\n        if lmw is None:\n            continue\n        ax.plot(routedata.columns, [lmw[1]] * len(routedata.columns), \"--k\", linewidth=1)\n        ax.text(routedata.columns[0], lmw[1], lmw[0], fontsize=12)\n\n    ax.set_ylabel(\"rivierkilometer\")\n    ax.set_title(f\"{routename}\\nheatmap Verschillen in waterstand 1D-2D\")\n\n    cb = fig.colorbar(im, ax=ax)\n    cb.set_label(\"waterstandsverschil [m+nap]\".upper(), rotation=270, labelpad=15)\n    PlotStyles.apply(fig, style=self._plotstyle, use_legend=False)\n    fig.tight_layout()\n    fig.savefig(self.output_path.joinpath(f\"figures/heatmaps/{routename}_rating_curve.png\"))\n    plt.close()\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.heatmap_time","title":"<code>heatmap_time(route)</code>","text":"<p>Create a 2D heatmap along a route.</p> <p>The horizontal axis uses timemarks to match the 1D and 2D models</p> <p>Figures are saved to <code>[Compare1D2D.output_path]/figures/heatmap</code></p> <p>Example output:</p> <p>.. figure:: figures_utils/heatmaps/example_time_series.png</p> <pre><code>example output figure\n</code></pre> Source code in <code>fm2prof\\utils.py</code> <pre><code>def heatmap_time(self, route: list[str]) -&gt; None:\n    \"\"\"Create a 2D heatmap along a route.\n\n    The horizontal axis uses timemarks to match the 1D and 2D models\n\n    Figures are saved to `[Compare1D2D.output_path]/figures/heatmap`\n\n    Example output:\n\n    .. figure:: figures_utils/heatmaps/example_time_series.png\n\n        example output figure\n\n    \"\"\"\n    routename = \"-\".join(route)\n    _, _, lmw_stations = self.get_route(route)\n    data = self._data_1d_h - self._data_2d_h\n    routedata = self.get_data_along_route(data.dropna(how=\"all\"), route)\n\n    fig, ax = plt.subplots(1, figsize=(12, 7))\n    im = ax.pcolormesh(\n        routedata.columns,\n        routedata.index,\n        routedata,\n        cmap=\"Spectral_r\",\n        vmin=-1,\n        vmax=1,\n    )\n    for lmw in lmw_stations:\n        if lmw is None:\n            continue\n        ax.plot(routedata.columns, [lmw[1]] * len(routedata.columns), \"--k\", linewidth=1)\n        ax.text(routedata.columns[0], lmw[1], lmw[0], fontsize=12)\n\n    ax.set_ylabel(\"rivierkilometer\")\n    ax.set_title(f\"{routename}\\nheatmap Verschillen in waterstand 1D-2D\")\n\n    cb = fig.colorbar(im, ax=ax)\n    cb.set_label(\"waterstandsverschil [m+nap]\".upper(), rotation=270, labelpad=15)\n    PlotStyles.apply(fig, style=self._plotstyle, use_legend=False)\n    fig.tight_layout()\n    fig.savefig(self.output_path.joinpath(f\"figures/heatmaps/{routename}_timeseries.png\"))\n    plt.close()\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.stations","title":"<code>stations()</code>","text":"<p>Yield station names.</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def stations(self) -&gt; Generator[str, None, None]:\n    \"\"\"Yield station names.\"\"\"\n    yield from self._data_1d_h.columns\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.statistics_to_file","title":"<code>statistics_to_file(file_path='error_statistics')</code>","text":"<p>Calculate statistics and write them to file.</p> <p>The output file is a comma-seperated file with the following columns:</p> <p>,bias,rkm,branch,is_lmw,std,mae,max13,last25</p> <p>with for each station:</p> <ul> <li>bias = bias, mean error</li> <li>rkm = river kilometer of the station</li> <li>branch = name of 1D branch on which the station lies</li> <li>is_lmw = if \"LMW\" is in the name of station, True.</li> <li>std = standard deviation of the rror</li> <li>mae = mean absolute error of the error</li> </ul> Source code in <code>fm2prof\\utils.py</code> <pre><code>def statistics_to_file(self, file_path: str = \"error_statistics\") -&gt; None:\n    \"\"\"Calculate statistics and write them to file.\n\n    The output file is a comma-seperated file with the following columns:\n\n    ,bias,rkm,branch,is_lmw,std,mae,max13,last25\n\n    with for each station:\n\n    - bias = bias, mean error\n    - rkm = river kilometer of the station\n    - branch = name of 1D branch on which the station lies\n    - is_lmw = if \"LMW\" is in the name of station, True.\n    - std = standard deviation of the rror\n    - mae = mean absolute error of the error\n\n    \"\"\"\n    self.statistics = self._compute_statistics()\n\n    statfile = self.output_path.joinpath(file_path).with_suffix(\".csv\")\n    sumfile = self.output_path.joinpath(file_path + \"_summary\").with_suffix(\".csv\")\n\n    # all statistics\n    self.statistics.to_csv(statfile)\n    self.set_logger_message(f\"statistics written to {statfile}\")\n\n    # summary of statistics\n    s = self.statistics\n    with sumfile.open(\"w\") as f:\n        for branch in s.branch.unique():\n            bbias = s.bias[s.branch == branch].mean()\n            bstd = s[\"std\"][s.branch == branch].mean()\n            lmw_bias = s.bias[(s.branch == branch) &amp; s.is_lmw].mean()\n            lmw_std = s[\"std\"][(s.branch == branch) &amp; s.is_lmw].mean()\n            f.write(f\"{branch},{bbias:.2f}\u00b1({bstd:.2f}), {lmw_bias:.2f}\u00b1({lmw_std:.2f})\\n\")\n</code></pre>"},{"location":"notebooks/VisualiseOutput/","title":"VisualiseOutput","text":"In\u00a0[1]: Copied! <pre>from fm2prof import Project\nfrom fm2prof.utils import VisualiseOutput\n\n# Initialize the project\nproject = Project(r\"../../tests/test_data/cases/case_02_compound/fm2prof_config.ini\")\n\n# The VisualiseOutput class imports all FM2PROF output files\nvis = VisualiseOutput(\n            project.get_output_directory(), logger=project.get_logger()\n        )\n\n# To loop over all cross-sections, use the following generator\ncross_sections = list(vis.cross_sections)\n\n# To print the z-values of the first cross-section:\nprint(cross_sections[0].get('levels'))\n</pre> from fm2prof import Project from fm2prof.utils import VisualiseOutput  # Initialize the project project = Project(r\"../../tests/test_data/cases/case_02_compound/fm2prof_config.ini\")  # The VisualiseOutput class imports all FM2PROF output files vis = VisualiseOutput(             project.get_output_directory(), logger=project.get_logger()         )  # To loop over all cross-sections, use the following generator cross_sections = list(vis.cross_sections)  # To print the z-values of the first cross-section: print(cross_sections[0].get('levels'))   <pre>\u2554\u2550\u2550\u2550\u2550\u2550\u2563 2024-05-07 21:03 Starting new task: Loading configuration file\n\u2551     DEBUG  T+ 0.01s Received ini file: ..\\..\\tests\\test_data\\cases\\case_02_compound\\fm2prof_config.ini\n\u2551   WARNING  T+ 0.05s Could not find optional input file for RegionPolygonFile, skipping\n\u2551   WARNING  T+ 0.07s Could not find optional input file for SectionPolygonFile, skipping\n\u2551   WARNING  T+ 0.12s exportmapfiles is not a known key\n\u2551     ERROR  T+ 0.13s Unexpected error reading (debug) parameters. Check config file\n\u255a\u2550\u2550\u2550\u2550\u2550\u2563 Task finished in 0.15sec\n================================================================================\nFM2PROF version 2.3.2\nDocumentation: https://deltares.github.io/Fm2Prof/\nAuthors: Koen Berends, Asako Fujisaki, Carles Soriano Perez, Ilia Awakimjan\nContact: koen.berends@deltares.nl\nLicense:   LPGL license. For more info see LICENSE.txt\nCopyright 2016-2020, University of Twente &amp; Deltares\n================================================================================\n\n[input]\n2DMapOutput                   = ..\\..\\tests\\test_data\\cases\\case_02_compound\\Data\\2DModelOutput\\FlowFM_map.nc# Output file from FM2D model (.net file)\nCrossSectionLocationFile      = ..\\..\\tests\\test_data\\cases\\case_02_compound\\Data\\cross_section_locations.xyz# .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\nRegionPolygonFile             =           # User defined polygons in json format\nSectionPolygonFile            =           # User defined polygons in json format\n\n[parameters]\nCaseName                      =           # Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used\nMaximumPointsInProfile        = 20        # Number of points which are used to generate cross-sections\nConveyanceDetectionMethod     = 1         # [0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)\nAbsoluteVelocityThreshold     = 0.01      # Absolute velocity threshold in m/s. Used to determine storage\nRelativeVelocityThreshold     = 0.03      # Relative velocity threshold (percentage). Used to determine storage\nMinimumDepthThreshold         = 0.02      # Minimum depth (m) for storage identification\nBedlevelCriterium             = 0.05      # Ignore the lowest percentage of bed level points\nLakeTimesteps                 = 10        # Number of timesteps that are used for identifying lakes\nExtrapolateStorage            = True      # Add storage to water level independent cross-section section\nSDCorrection                  = True      # Use summerdike volume correction\nSDFloodplainBase              = 0.5       # minimum distance between floodplain base level and crest level in meters\nSDTransitionHeight            = 0.5       # Transition height at the summer dike (m)\nSDOptimisationMethod          = 0         # [0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both\nFrictionWeighingMethod        = 0         # Options. [0] arithmetric mean, [1] Weighted average\nSkipMaps                      = 0         # number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. \nClassificationMethod          = 0         # How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell\nMinimumTotalWidth             = 0.5       # Minimum width in meters. Zero width may lead to numerical instability in 1D solvers\n\n[debug]\nExportCSSData                 = False     # If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.\nExportMapFiles                = False     # Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.\nCssSelection                  =           # provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections\n\n[output]\nOutputDirectory               = output    # Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory\n\n\n\u2551      INFO  T+ 0.28s Using ..\\..\\tests\\test_data\\cases\\case_02_compound\\output\\figures as output directory for figures\n</pre> <pre>[-2.025, -2.015, -1.9486, -1.9055, -1.8261, -1.7498, -1.6281, -1.5567, -1.4315, -1.3622, -0.571, -0.0747, -0.0391, -0.0216, -0.0049, 0.0695, 0.4215, 0.835, 1.243, 1.7807]\n</pre> <p>To visualise the first cross-section:</p> In\u00a0[3]: Copied! <pre># Plot the first cross-section\nvis.figure_cross_section(cross_sections[0], save_to_file=False, overwrite=True)\n\n# You can loop over the generator to create figures in a bunch:\n#for css in vis.cross_sections:\n#    vis.figure_cross_section(css)\n</pre> # Plot the first cross-section vis.figure_cross_section(cross_sections[0], save_to_file=False, overwrite=True)  # You can loop over the generator to create figures in a bunch: #for css in vis.cross_sections: #    vis.figure_cross_section(css) Out[3]: In\u00a0[4]: Copied! <pre>vis.figure_roughness_longitudinal(branch=\"channel1\")\n</pre> vis.figure_roughness_longitudinal(branch=\"channel1\")"},{"location":"notebooks/VisualiseOutput/#visualiseoutput","title":"VisualiseOutput\u00b6","text":"<p>This notebook show examples of how to use the <code>VisualiseOutput</code> utility. This utility is used to visualise <code>fm2prof</code> output, such as generated cross-sections and roughness fields.</p>"},{"location":"notebooks/VisualiseOutput/#cross-sections","title":"Cross-sections\u00b6","text":""},{"location":"notebooks/VisualiseOutput/#plot-roughness","title":"Plot roughness\u00b6","text":"<p>To plot roughness along a branch:</p>"},{"location":"notebooks/compare1d2d/","title":"Compare 1D and 2D model output","text":"In\u00a0[1]: Copied! <pre>from fm2prof import Project, utils\n\nproject = Project(fr'../../tests/test_data/compare1d2d/cases/case1/fm2prof.ini');\n\n# To convert model output to csv files, initialise like this:\n\"\"\"\nplotter = utils.Compare1D2D(project=project, \n                           path_1d='../path/to/dir/that/contains/dimr.xml',\n                           path_2d='../path/to/his/netcdf/file' )  \n\"\"\"\n\n# The minimal information you need to provide is an fm2prof config file. \nplotter = utils.Compare1D2D(project=project)\n</pre> from fm2prof import Project, utils  project = Project(fr'../../tests/test_data/compare1d2d/cases/case1/fm2prof.ini');  # To convert model output to csv files, initialise like this: \"\"\" plotter = utils.Compare1D2D(project=project,                             path_1d='../path/to/dir/that/contains/dimr.xml',                            path_2d='../path/to/his/netcdf/file' )   \"\"\"  # The minimal information you need to provide is an fm2prof config file.  plotter = utils.Compare1D2D(project=project) <pre>\u2554\u2550\u2550\u2550\u2550\u2550\u2563 2024-08-30 14:10 Starting new task: Loading configuration file\n\u2551     DEBUG  T+ 0.01s Received ini file: ..\\..\\tests\\test_data\\compare1d2d\\cases\\case1\\fm2prof.ini\n\u2551     ERROR  T+ 0.03s Could not find input file: 2DMapOutput\n\u2551     ERROR  T+ 0.05s Unexpected error reading input files. Check config file\n\u2551   WARNING  T+ 0.13s exportmapfiles is not a known key\n\u2551     ERROR  T+ 0.14s Unexpected error reading (debug) parameters. Check config file\n\u255a\u2550\u2550\u2550\u2550\u2550\u2563 Task finished in 0.15sec\n================================================================================\nFM2PROF version 2.3.3\nDocumentation: https://deltares.github.io/Fm2Prof/\nAuthors: Koen Berends, Asako Fujisaki, Carles Soriano Perez, Ilia Awakimjan\nContact: koen.berends@deltares.nl\nLicense:   LPGL license. For more info see LICENSE.txt\nCopyright 2016-2020, University of Twente &amp; Deltares\n================================================================================\n\n[input]\n2DMapOutput                   =           # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\nRegionPolygonFile             =           # User defined polygons in json format\nSectionPolygonFile            =           # User defined polygons in json format\n\n[parameters]\nCaseName                      =           # Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used\nMaximumPointsInProfile        = 20        # Number of points which are used to generate cross-sections\nConveyanceDetectionMethod     = 1         # [0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)\nAbsoluteVelocityThreshold     = 0.01      # Absolute velocity threshold in m/s. Used to determine storage\nRelativeVelocityThreshold     = 0.03      # Relative velocity threshold (percentage). Used to determine storage\nMinimumDepthThreshold         = 0.02      # Minimum depth (m) for storage identification\nBedlevelCriterium             = 0.05      # Ignore the lowest percentage of bed level points\nLakeTimesteps                 = 10        # Number of timesteps that are used for identifying lakes\nExtrapolateStorage            = True      # Add storage to water level independent cross-section section\nSDCorrection                  = True      # Use summerdike volume correction\nSDFloodplainBase              = 0.5       # minimum distance between floodplain base level and crest level in meters\nSDTransitionHeight            = 0.5       # Transition height at the summer dike (m)\nSDOptimisationMethod          = 0         # [0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both\nFrictionWeighingMethod        = 0         # Options. [0] arithmetric mean, [1] Weighted average\nSkipMaps                      = 0         # number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. \nClassificationMethod          = 0         # How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell\nMinimumTotalWidth             = 0.5       # Minimum width in meters. Zero width may lead to numerical instability in 1D solvers\n\n[debug]\nExportCSSData                 = False     # If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.\nExportMapFiles                = False     # Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.\nCssSelection                  =           # provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections\n\n[output]\nOutputDirectory               = output    # Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory\n\n\n\u2551     DEBUG  T+ 0.23s 1D netCDF file does not exist or is not provided. Input provided: None.\n\u2551     DEBUG  T+ 0.24s 2D netCDF file does not exist or is not provided. Input provided: None.\n\u2551      INFO  T+ 1.07s Using existing flow1d csv files\n\u2551      INFO  T+ 1.10s using existing 1d-2d map\n\u2551      INFO  T+ 2.30s Using existing flow2d csv files\n\u2551      INFO  T+ 2.31s Using existing digitized file for 1d\n\u2551      INFO  T+ 2.37s Using existing digitized file for 2d\n</pre> In\u00a0[2]: Copied! <pre>plotter.figure_longitudinal(route=[\"BR\", \"WL\"], savefig=False)\n</pre> plotter.figure_longitudinal(route=[\"BR\", \"WL\"], savefig=False) <pre>\u2551   WARNING  T+ 13.87s skipped labelling BR_863.9_R_LMW-H_Lobith-haven because too close to previous station\n</pre> Out[2]: <pre>FigureOutput(fig=&lt;Figure size 1200x1200 with 2 Axes&gt;, axes=array([&lt;Axes: title={'center': 'route: BR-WL'}, xlabel='Rivierkilometers', ylabel='Waterstand [m+NAP]'&gt;,\n       &lt;Axes: xlabel='Rivierkilometers', ylabel='Verschil 1D-2D [m]'&gt;],\n      dtype=object), legend=&lt;matplotlib.legend.Legend object at 0x00000247A18A7C50&gt;)</pre> <p>These results show that the first shown time is not really initialised very well. In fact, for this simulations it makes sense to start showing results only from January 1st. We can do this by giving the plotter a start time:</p> In\u00a0[4]: Copied! <pre>from datetime import datetime\n\nplotter.start_time = datetime(year=2000, month=1, day=5)\nplotter.figure_longitudinal(route=[\"BR\", \"WL\"], savefig=False)\n</pre> from datetime import datetime  plotter.start_time = datetime(year=2000, month=1, day=5) plotter.figure_longitudinal(route=[\"BR\", \"WL\"], savefig=False) <pre>\u2551   WARNING  T+ 38.98s skipped labelling BR_863.9_R_LMW-H_Lobith-haven because too close to previous station\n</pre> Out[4]: <pre>FigureOutput(fig=&lt;Figure size 1200x1200 with 2 Axes&gt;, axes=array([&lt;Axes: title={'center': 'route: BR-WL'}, xlabel='Rivierkilometers', ylabel='Waterstand [m+NAP]'&gt;,\n       &lt;Axes: xlabel='Rivierkilometers', ylabel='Verschil 1D-2D [m]'&gt;],\n      dtype=object), legend=&lt;matplotlib.legend.Legend object at 0x00000247AE31AE50&gt;)</pre> In\u00a0[5]: Copied! <pre># Loading output from two sources\nproject = Project(fr'../../tests/test_data/compare1d2d/cases/case1/fm2prof.ini')\nproject2 = Project(fr'../../tests/test_data/compare1d2d/cases/case2/fm2prof.ini')\n\nplotter = utils.Compare1D2D(project=project,\n                            start_time=datetime(year=2000, month=1, day=5))\nplotter2 = utils.Compare1D2D(project=project2,\n                            start_time=datetime(year=2000, month=1, day=5))\n\n# Where setting savefig to False to get the Figure outptu\nFigure = plotter.figure_longitudinal(route=['BR', \"PK\", \"IJ\"], \n                                     stat=\"last3\", \n                                     label = \"D8000\",\n                                     savefig=False)\n\n# The second potter takes the `FigureOutput` from the first plotter as argument for the `add_to_fig` parameter. \nplotter2.figure_longitudinal(route=['BR', \"PK\", \"IJ\"], \n                             stat=\"last3\", \n                             label = \"D16000\",\n                             savefig=False,\n                             add_to_fig=Figure)\n</pre> # Loading output from two sources project = Project(fr'../../tests/test_data/compare1d2d/cases/case1/fm2prof.ini') project2 = Project(fr'../../tests/test_data/compare1d2d/cases/case2/fm2prof.ini')  plotter = utils.Compare1D2D(project=project,                             start_time=datetime(year=2000, month=1, day=5)) plotter2 = utils.Compare1D2D(project=project2,                             start_time=datetime(year=2000, month=1, day=5))  # Where setting savefig to False to get the Figure outptu Figure = plotter.figure_longitudinal(route=['BR', \"PK\", \"IJ\"],                                       stat=\"last3\",                                       label = \"D8000\",                                      savefig=False)  # The second potter takes the `FigureOutput` from the first plotter as argument for the `add_to_fig` parameter.  plotter2.figure_longitudinal(route=['BR', \"PK\", \"IJ\"],                               stat=\"last3\",                               label = \"D16000\",                              savefig=False,                              add_to_fig=Figure) <pre>\u2551      INFO  T+ 44.24s Starting new task: Loading configuration file\n\u2551     DEBUG  T+ 44.25s Received ini file: ..\\..\\tests\\test_data\\compare1d2d\\cases\\case1\\fm2prof.ini\n\u2551     ERROR  T+ 44.27s Could not find input file: 2DMapOutput\n\u2551     ERROR  T+ 44.28s Unexpected error reading input files. Check config file\n\u2551   WARNING  T+ 44.32s exportmapfiles is not a known key\n\u2551     ERROR  T+ 44.35s Unexpected error reading (debug) parameters. Check config file\n\u2551      INFO  T+ 44.37s \n\u2551      INFO  T+ 44.38s ================================================================================\n\u2551      INFO  T+ 44.40s FM2PROF version 2.3.3\n\u2551      INFO  T+ 44.41s Documentation: https://deltares.github.io/Fm2Prof/\n\u2551      INFO  T+ 44.45s Authors: Koen Berends, Asako Fujisaki, Carles Soriano Perez, Ilia Awakimjan\n\u2551      INFO  T+ 44.47s Contact: koen.berends@deltares.nl\n\u2551      INFO  T+ 44.48s License:   LPGL license. For more info see LICENSE.txt\n\u2551      INFO  T+ 44.50s Copyright 2016-2020, University of Twente &amp; Deltares\n\u2551      INFO  T+ 44.51s ================================================================================\n\u2551      INFO  T+ 44.52s \n\u2551      INFO  T+ 44.52s [input]\n2DMapOutput                   =           # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\nRegionPolygonFile             =           # User defined polygons in json format\nSectionPolygonFile            =           # User defined polygons in json format\n\n[parameters]\nCaseName                      =           # Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used\nMaximumPointsInProfile        = 20        # Number of points which are used to generate cross-sections\nConveyanceDetectionMethod     = 1         # [0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)\nAbsoluteVelocityThreshold     = 0.01      # Absolute velocity threshold in m/s. Used to determine storage\nRelativeVelocityThreshold     = 0.03      # Relative velocity threshold (percentage). Used to determine storage\nMinimumDepthThreshold         = 0.02      # Minimum depth (m) for storage identification\nBedlevelCriterium             = 0.05      # Ignore the lowest percentage of bed level points\nLakeTimesteps                 = 10        # Number of timesteps that are used for identifying lakes\nExtrapolateStorage            = True      # Add storage to water level independent cross-section section\nSDCorrection                  = True      # Use summerdike volume correction\nSDFloodplainBase              = 0.5       # minimum distance between floodplain base level and crest level in meters\nSDTransitionHeight            = 0.5       # Transition height at the summer dike (m)\nSDOptimisationMethod          = 0         # [0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both\nFrictionWeighingMethod        = 0         # Options. [0] arithmetric mean, [1] Weighted average\nSkipMaps                      = 0         # number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. \nClassificationMethod          = 0         # How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell\nMinimumTotalWidth             = 0.5       # Minimum width in meters. Zero width may lead to numerical instability in 1D solvers\n\n[debug]\nExportCSSData                 = False     # If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.\nExportMapFiles                = False     # Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.\nCssSelection                  =           # provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections\n\n[output]\nOutputDirectory               = output    # Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory\n\n\n\u2551      INFO  T+ 44.55s Starting new task: Loading configuration file\n\u2551     DEBUG  T+ 44.57s Received ini file: ..\\..\\tests\\test_data\\compare1d2d\\cases\\case2\\fm2prof.ini\n\u2551     ERROR  T+ 44.59s Could not find input file: 2DMapOutput\n\u2551     ERROR  T+ 44.60s Unexpected error reading input files. Check config file\n\u2551   WARNING  T+ 44.64s exportmapfiles is not a known key\n\u2551     ERROR  T+ 44.68s Unexpected error reading (debug) parameters. Check config file\n\u2551      INFO  T+ 44.69s \n\u2551      INFO  T+ 44.71s ================================================================================\n\u2551      INFO  T+ 44.72s FM2PROF version 2.3.3\n\u2551      INFO  T+ 44.73s Documentation: https://deltares.github.io/Fm2Prof/\n\u2551      INFO  T+ 44.74s Authors: Koen Berends, Asako Fujisaki, Carles Soriano Perez, Ilia Awakimjan\n\u2551      INFO  T+ 44.75s Contact: koen.berends@deltares.nl\n\u2551      INFO  T+ 44.76s License:   LPGL license. For more info see LICENSE.txt\n\u2551      INFO  T+ 44.78s Copyright 2016-2020, University of Twente &amp; Deltares\n\u2551      INFO  T+ 44.80s ================================================================================\n\u2551      INFO  T+ 44.81s \n\u2551      INFO  T+ 44.82s [input]\n2DMapOutput                   =           # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\nRegionPolygonFile             =           # User defined polygons in json format\nSectionPolygonFile            =           # User defined polygons in json format\n\n[parameters]\nCaseName                      =           # Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used\nMaximumPointsInProfile        = 20        # Number of points which are used to generate cross-sections\nConveyanceDetectionMethod     = 1         # [0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)\nAbsoluteVelocityThreshold     = 0.01      # Absolute velocity threshold in m/s. Used to determine storage\nRelativeVelocityThreshold     = 0.03      # Relative velocity threshold (percentage). Used to determine storage\nMinimumDepthThreshold         = 0.02      # Minimum depth (m) for storage identification\nBedlevelCriterium             = 0.05      # Ignore the lowest percentage of bed level points\nLakeTimesteps                 = 10        # Number of timesteps that are used for identifying lakes\nExtrapolateStorage            = True      # Add storage to water level independent cross-section section\nSDCorrection                  = True      # Use summerdike volume correction\nSDFloodplainBase              = 0.5       # minimum distance between floodplain base level and crest level in meters\nSDTransitionHeight            = 0.5       # Transition height at the summer dike (m)\nSDOptimisationMethod          = 0         # [0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both\nFrictionWeighingMethod        = 0         # Options. [0] arithmetric mean, [1] Weighted average\nSkipMaps                      = 0         # number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. \nClassificationMethod          = 0         # How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell\nMinimumTotalWidth             = 0.5       # Minimum width in meters. Zero width may lead to numerical instability in 1D solvers\n\n[debug]\nExportCSSData                 = False     # If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.\nExportMapFiles                = False     # Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.\nCssSelection                  =           # provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections\n\n[output]\nOutputDirectory               = output    # Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory\n\n\n\u2551     DEBUG  T+ 44.83s 1D netCDF file does not exist or is not provided. Input provided: None.\n\u2551     DEBUG  T+ 44.84s 2D netCDF file does not exist or is not provided. Input provided: None.\n\u2551      INFO  T+ 46.07s Using existing flow1d csv files\n\u2551      INFO  T+ 46.08s using existing 1d-2d map\n\u2551      INFO  T+ 46.86s Using existing flow2d csv files\n\u2551      INFO  T+ 46.86s Using existing digitized file for 1d\n\u2551      INFO  T+ 46.89s Using existing digitized file for 2d\n\u2551     DEBUG  T+ 46.93s 1D netCDF file does not exist or is not provided. Input provided: None.\n\u2551     DEBUG  T+ 46.95s 2D netCDF file does not exist or is not provided. Input provided: None.\n\u2551      INFO  T+ 48.12s Using existing flow1d csv files\n\u2551      INFO  T+ 48.13s using existing 1d-2d map\n\u2551      INFO  T+ 48.50s Using existing flow2d csv files\n\u2551      INFO  T+ 48.51s Using existing digitized file for 1d\n\u2551      INFO  T+ 48.55s Using existing digitized file for 2d\n\u2551   WARNING  T+ 50.02s skipped labelling BR_863.9_R_LMW-H_Lobith-haven because too close to previous station\n\u2551   WARNING  T+ 50.03s skipped labelling PK_871.8_L_LMW-H_Pannerden because too close to previous station\n\u2551   WARNING  T+ 50.05s skipped labelling PK_878.5_R_LMW-H_IJsselkop because too close to previous station\n\u2551   WARNING  T+ 50.06s skipped labelling IJ_879.6_R_LMW-H_Hondsbroeksche-Pleij-IJssel because too close to previous station\n\u2551   WARNING  T+ 50.08s skipped labelling IJ_881.1_R_LMW-H_Westervoort-IJsseldijkerwaard because too close to previous station\n\u2551   WARNING  T+ 50.10s skipped labelling IJ_931.2_R_LMW-H_Eefde-beneden because too close to previous station\n</pre> Out[5]: <pre>FigureOutput(fig=&lt;Figure size 1200x1200 with 2 Axes&gt;, axes=array([&lt;Axes: title={'center': 'route: BR-PK-IJ'}, xlabel='Rivierkilometers', ylabel='Waterstand [m+NAP]'&gt;,\n       &lt;Axes: xlabel='Rivierkilometers', ylabel='Verschil 1D-2D [m]'&gt;],\n      dtype=object), legend=&lt;matplotlib.legend.Legend object at 0x00000247AE770410&gt;)</pre> In\u00a0[5]: Copied! <pre>plotter.figure_at_station(\"WL_900.00\", savefig=False)\n</pre> plotter.figure_at_station(\"WL_900.00\", savefig=False) Out[5]: <pre>FigureOutput(fig=&lt;Figure size 1200x500 with 2 Axes&gt;, axes=&lt;Axes: title={'center': 'WL_900.00\\nTijdreeks'}, ylabel='Waterstand [m+NAP]'&gt;, legend=&lt;matplotlib.legend.Legend object at 0x000002AC022D2110&gt;)</pre> <p>If you are not sure what stations are available, use the <code>stations</code> method to list all stations. The code below returns all stations that contain the abbreviation \"WL\"</p> In\u00a0[6]: Copied! <pre>[station for station in plotter.stations() if \"WL\" in station]\n</pre> [station for station in plotter.stations() if \"WL\" in station] Out[6]: <pre>['WL_914.00',\n 'WL_915.00',\n 'WL_916.00',\n 'WL_917.00',\n 'WL_918.00',\n 'WL_919.00',\n 'WL_920.00',\n 'WL_921.00',\n 'WL_922.00',\n 'WL_923.00',\n 'WL_924.00',\n 'WL_925.00',\n 'WL_926.00',\n 'WL_927.00',\n 'WL_928.00',\n 'WL_929.00',\n 'WL_930.00',\n 'WL_931.00',\n 'WL_932.00',\n 'WL_933.00',\n 'WL_934.00',\n 'WL_935.00',\n 'WL_936.00',\n 'WL_937.00',\n 'WL_938.00',\n 'WL_939.00',\n 'WL_940.00',\n 'WL_941.00',\n 'WL_942.00',\n 'WL_943.00',\n 'WL_944.00',\n 'WL_945.00',\n 'WL_946.00',\n 'WL_947.00',\n 'WL_948.00',\n 'WL_949.00',\n 'WL_950.00',\n 'WL_951.00',\n 'WL_952.00',\n 'WL_926.1_L_LMW-H_Sint-Andries-Waal-g6',\n 'WL_934.8_L_LMW-H_Zaltbommel',\n 'WL_951.8_R_LMW-H_Vuren',\n 'WL_867.00',\n 'WL_913.3_R_LMW-H_Tiel-Waal',\n 'WL_868.00',\n 'WL_869.00',\n 'WL_870.00',\n 'WL_871.00',\n 'WL_872.00',\n 'WL_873.00',\n 'WL_874.00',\n 'WL_875.00',\n 'WL_876.00',\n 'WL_877.00',\n 'WL_878.00',\n 'WL_879.00',\n 'WL_880.00',\n 'WL_881.00',\n 'WL_882.00',\n 'WL_883.00',\n 'WL_884.00',\n 'WL_885.00',\n 'WL_886.00',\n 'WL_887.00',\n 'WL_888.00',\n 'WL_889.00',\n 'WL_890.00',\n 'WL_891.00',\n 'WL_892.00',\n 'WL_893.00',\n 'WL_894.00',\n 'WL_895.00',\n 'WL_896.00',\n 'WL_897.00',\n 'WL_898.00',\n 'WL_899.00',\n 'WL_900.00',\n 'WL_901.00',\n 'WL_902.00',\n 'WL_903.00',\n 'WL_904.00',\n 'WL_905.00',\n 'WL_906.00',\n 'WL_907.00',\n 'WL_908.00',\n 'WL_909.00',\n 'WL_910.00',\n 'WL_911.00',\n 'WL_912.00',\n 'WL_913.00',\n 'WL_884.9_L_LMW-H_Nijmegen-haven',\n 'WL_901.4_R_LMW-H_Dodewaard']</pre> In\u00a0[6]: Copied! <pre>plotter.figure_compare_discharge_at_stations(stations=['WL_869.00', 'PK_869.00'], \n                                             title=\"Pannerdensche Kop\",\n                                            savefig=False)\n</pre> plotter.figure_compare_discharge_at_stations(stations=['WL_869.00', 'PK_869.00'],                                               title=\"Pannerdensche Kop\",                                             savefig=False) Out[6]: <pre>FigureOutput(fig=&lt;Figure size 1200x1000 with 3 Axes&gt;, axes=array([&lt;Axes: title={'center': 'tijdserie'}, ylabel='afvoer [m$^3$/s]'&gt;,\n       &lt;Axes: title={'center': 'afvoerverdeling'}, xlabel='afvoer bovenstrooms [m$^3$/s]', ylabel='percentage t.o.v. totaal'&gt;],\n      dtype=object), legend=&lt;matplotlib.legend.Legend object at 0x00000247ADD02B10&gt;)</pre> <p>All statistics, like bias, mean average error and 'max13' can also be written to a csv file for analysis. The following method will immediately write t file. It can also take an optional argument <code>file_path</code> where you can change the name of the output</p> In\u00a0[7]: Copied! <pre>plotter.statistics_to_file()\n</pre> plotter.statistics_to_file() <pre>\u2551      INFO  T+ 76.20s statistics written to ..\\..\\tests\\test_data\\compare1d2d\\cases\\case1\\output\\error_statistics.csv\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/compare1d2d/#compare-1d-and-2d-model-output","title":"Compare 1D and 2D model output\u00b6","text":"<p>This notebook show examples of how to use the <code>Compare1D2D</code> utility to produce figures and tables.</p>"},{"location":"notebooks/compare1d2d/#reading-1d-and-2d-output","title":"Reading 1D and 2D output\u00b6","text":"<p>Model output can be quite large, so we only want to read output once. In this notebook, we assume the utility has already initialised and <code>1D_H.csv</code>, <code>2D_H.csv</code> files are already generated. However, see the commented-out code on how to generate these csv files from netCDF model output.</p>"},{"location":"notebooks/compare1d2d/#showing-results-along-a-route","title":"Showing results along a route\u00b6","text":"<p>The example data contains results for the Rijn river. A route along the Rhine we might inspect is the Bovenrijn (BR) to Waal (WL). Below, we set <code>savefig=False</code>, so that the figure renders in the notebook. If you set <code>savefig=True</code>, it will save as a png to the <code>project</code> output folder.</p>"},{"location":"notebooks/compare1d2d/#combining-multiple-simulations-in-a-single-graph","title":"Combining multiple simulations in a single graph\u00b6","text":"<p>To show the results of multiple simulations, it makes sense to plot a single line per simulation. Two available stats are implemented: <code>max13</code> plots the average of the 13 highest values for each location, which makes sense for a Dynamic standard simulation. The <code>last25</code> shows the average of the last 25 output, which makes most sense for a steady simulation.</p>"},{"location":"notebooks/compare1d2d/#showing-results-for-a-single-station","title":"Showing results for a single station\u00b6","text":"<p>To compare results at a single station, use the following method</p>"},{"location":"notebooks/compare1d2d/#compare-discharge-distribution","title":"Compare discharge distribution\u00b6","text":"<p>To plot discharge distribution between two stations, use the following code</p>"},{"location":"notebooks/compare1d2d/#statistics","title":"Statistics\u00b6","text":""},{"location":"notebooks/cross_section_data/","title":"Inspecting cross-sections","text":"In\u00a0[8]: Copied! <pre>import pickle\n\n# Cross-sections test cases\ncases = [\"waal_1_40147.826\", \"reevediep_2888.800\", \"veessenwapenveld_3519.948\", \"ketelmeer02_0.000\", \"twentekanaal_941.714\", \"nederrijn_20011.855\"]\n\ncase = cases[0]\n\nwith open(fr\"../../tests/test_data/cross_sections/{case}.pickle\", \"rb\") as f:\n    data = pickle.load(f)\n</pre> import pickle  # Cross-sections test cases cases = [\"waal_1_40147.826\", \"reevediep_2888.800\", \"veessenwapenveld_3519.948\", \"ketelmeer02_0.000\", \"twentekanaal_941.714\", \"nederrijn_20011.855\"]  case = cases[0]  with open(fr\"../../tests/test_data/cross_sections/{case}.pickle\", \"rb\") as f:     data = pickle.load(f) In\u00a0[9]: Copied! <pre>import matplotlib.pyplot as plt\n\nvariable = 'bedlevel'  # other variables to plot: bedlevel, section, region, area\nx = data.get('fm_data').get('x')\ny = data.get('fm_data').get('y')\nz = data.get('fm_data').get(variable)\n\nfig, ax = plt.subplots(1)\nsc = ax.scatter(x/1000, y/1000, c=z)\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(variable)\n</pre> import matplotlib.pyplot as plt  variable = 'bedlevel'  # other variables to plot: bedlevel, section, region, area x = data.get('fm_data').get('x') y = data.get('fm_data').get('y') z = data.get('fm_data').get(variable)  fig, ax = plt.subplots(1) sc = ax.scatter(x/1000, y/1000, c=z) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(variable)                       Figure                  In\u00a0[10]: Copied! <pre>%matplotlib widget\nfrom ipywidgets import *\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\nvariable = 'velocity' # try also: waterlevel, waterdepth\n\nz = data.get('fm_data').get(variable)\nfig, ax = plt.subplots(1)\n\nsc = ax.scatter(x/1000, y/1000, c=z.iloc[6])\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(variable)\nplt.show(fig)\n\ndef update(i):\n    plt.gca()\n    zi = z.iloc[i]\n    ax.scatter(x/1000, y/1000, c=zi)\n    fig.canvas.draw()\n\ninteract(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))\n</pre> %matplotlib widget from ipywidgets import * import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap  variable = 'velocity' # try also: waterlevel, waterdepth  z = data.get('fm_data').get(variable) fig, ax = plt.subplots(1)  sc = ax.scatter(x/1000, y/1000, c=z.iloc[6]) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(variable) plt.show(fig)  def update(i):     plt.gca()     zi = z.iloc[i]     ax.scatter(x/1000, y/1000, c=zi)     fig.canvas.draw()  interact(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))                      Figure                  <pre>interactive(children=(IntSlider(value=6, description='i', max=46), Output()), _dom_classes=('widget-interact',\u2026</pre> Out[10]: <pre>&lt;function __main__.update(i)&gt;</pre> In\u00a0[7]: Copied! <pre>with open(fr\"../../tests/test_data/cross_sections/{case}_flowmask.pickle\", \"rb\") as f:\n    flowmask = pickle.load(f)\n</pre> with open(fr\"../../tests/test_data/cross_sections/{case}_flowmask.pickle\", \"rb\") as f:     flowmask = pickle.load(f) <p>The code below visualises how this criterium is met during the 2D simulation. You'll see that as you progress in time, more cells will mee the criterium.</p> In\u00a0[8]: Copied! <pre>%matplotlib widget\nfrom ipywidgets import *\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\nfig, ax = plt.subplots(1)\nfm = flowmask.T.iloc[0]\nsc = ax.scatter(x/1000, y/1000, c=fm)\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(\"meets conveyance criterium\")\nplt.show(fig)\n\ndef update(i):\n    plt.gca()\n    fm = flowmask.T.iloc[i]\n    ax.scatter(x/1000, y/1000, c=fm)\n    fig.canvas.draw()\n\ninteract(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))\n</pre> %matplotlib widget from ipywidgets import * import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap  fig, ax = plt.subplots(1) fm = flowmask.T.iloc[0] sc = ax.scatter(x/1000, y/1000, c=fm) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(\"meets conveyance criterium\") plt.show(fig)  def update(i):     plt.gca()     fm = flowmask.T.iloc[i]     ax.scatter(x/1000, y/1000, c=fm)     fig.canvas.draw()  interact(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))                      Figure                  <pre>interactive(children=(IntSlider(value=6, description='i', max=46), Output()), _dom_classes=('widget-interact',\u2026</pre> Out[8]: <pre>&lt;function __main__.update(i)&gt;</pre>"},{"location":"notebooks/cross_section_data/#inspecting-cross-sections","title":"Inspecting cross-sections\u00b6","text":"<p>If deeper analysis of cross-section is required, you can enable the option <code>ExportCSSData</code> in the fm2prof project configuration file. This notebooks shows some techniques to visualise this data.</p>"},{"location":"notebooks/cross_section_data/#loading-the-data","title":"Loading the data\u00b6","text":"<p>Example output is provided in the tests directory of the fm2prof repository. This is pickled data, so we'll use <code>pickle</code> to read it.</p>"},{"location":"notebooks/cross_section_data/#visualise-the-cross-section-input-data","title":"Visualise the cross-section input data\u00b6","text":"<p>When unpickled, this data is a <code>dict</code> of pandas DataFrames. The variable <code>data</code> holds all information that the <code>fm2prof.CrossSection</code> class uses to build a 1D cross-section. Let's visualise this data:</p>"},{"location":"notebooks/cross_section_data/#visualising-velocity","title":"Visualising velocity\u00b6","text":""},{"location":"notebooks/cross_section_data/#visualising-conveyance","title":"Visualising conveyance\u00b6","text":"<p>Another provided data file is the <code>flowmask.pickle</code> file. This file contains information generated during the cross-section production. The <code>flowmask</code> encodes information on which cells meet the conveyance criterium (stroomvoeringscriterium).</p>"}]}