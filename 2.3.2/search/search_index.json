{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v231-24-04-2024","title":"v2.3.1 (24-04-2024)","text":"<p>Bug fixes - Fixed a bug that threw an exception if user did not specify a stop time when using <code>utils.Compare1D2D</code> (#78) - Fixed bug (#81) that prevented executable from being build because of missing favico</p> <p>Documentation - added python snippets to quickstart tutorial</p>"},{"location":"CHANGELOG/#v230-19-04-2024","title":"v2.3.0 (19-04-2024)","text":""},{"location":"CHANGELOG/#new-functionality","title":"New functionality","text":"<ul> <li>Configuration file now has a new <code>debug</code> section with debug specific parameters. This section includes two parameters previously in the general <code>parameters</code> section (<code>ExportMapFiles</code> and <code>CssSelection</code>) and the new <code>ExportCSSData</code>. </li> <li>new debug option <code>ExportCSSData</code> that when enabled output data to analyse cross-section generation. </li> <li>new option <code>ConveyanceDetectionMethod</code> to toggle between the previous way to detect storage (0) and a the new one (1, default). </li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>documentation now includes a notebook specifying how output from <code>ExportCSSData</code> option can be used to analyse flow data</li> <li>docstrings of cross-section class updated to describe flow/storage separation methodology</li> <li>several chapters ported over from sphinx</li> </ul>"},{"location":"CHANGELOG/#bug-fixes-chores","title":"bug fixes &amp; chores","text":"<ul> <li>added dedicated tests for cross-section class</li> <li>test coverage is now reported in Sonarcloud</li> <li>fixed bug that caused error while writing log</li> </ul>"},{"location":"CHANGELOG/#bug-fixes-chores_1","title":"bug fixes &amp; chores","text":"<ul> <li>fixed bug in <code>utils</code> that threw an error when using matplotlib 3.7 or higher</li> <li>removed unused code blocks</li> <li>updated type hinting and code documentation of <code>CrossSection.py</code></li> </ul>"},{"location":"CHANGELOG/#v228-2023-10-03","title":"v2.2.8 (2023-10-03)","text":"<p>This version update FM2PROF to Python 3.10 or higher. It removes unused dependencies and updates the package system <code>poetry</code> to version 1.8.2. Due to this switch, the commitizen workflow is currently not used, and the documentation system switch from sphinx to mkdocs. </p> <p>This is the first version to be published to PyPi, which means that FM2PROF can now be installed using pip</p> <p><code>pip install fm2prof</code></p> <p>Known issues:</p> <ul> <li>The executable is not available for this version. </li> </ul>"},{"location":"CHANGELOG/#v227-2023-10-03","title":"v2.2.7 (2023-10-03)","text":"<p>This version adds the parameter stoptime to utils.Compare1D2D and makes both starttime and stoptime parameters optional. With these parameters users can crop the section of the results over which statistics will be computed and figures made.</p>"},{"location":"CHANGELOG/#v226-2023-10-01","title":"v2.2.6 (2023-10-01)","text":"<ul> <li>Fixed an issue where irregular station names like <code>MA_67.00Z</code> caused a sorting error in <code>utils.Compare1D2D</code></li> </ul>"},{"location":"CHANGELOG/#v225-2023-07-28","title":"v2.2.5 (2023-07-28)","text":"<ul> <li>FM2PROF now validates the \"SkipMaps\" parameter and throws error if its value is larger than the available number of maps</li> <li>Fixed bug that threw exception if roughness tables could not be produced during finalization step</li> <li>Fixed bug that prevented BranchRules file to be read if multiple empty lines existed at the end of the file</li> <li>Fixed bug where <code>utils.Compare1D2D</code> would throw exception if input netCDF files did not exist, but csv files did. </li> <li>Fixed bug in <code>utils.Compare1D2D</code> where execution failed if a QH relationship could not be produced</li> <li>Statistics are no longer computed on initialization of <code>utils.Compare1D2D</code>. Instead, they are not computed when requested during evaluation. </li> </ul>"},{"location":"CHANGELOG/#v224-2023-07-05","title":"v2.2.4 (2023-07-05)","text":"<ul> <li>Implemented 'onlyFirst' and 'onlyLast' rules for BranchRules file</li> </ul>"},{"location":"CHANGELOG/#v223-2022-12-21","title":"v2.2.3 (2022-12-21)","text":"<ul> <li>Implemented functionality to compare two 1D models for bed level change, Summer dike change and width change</li> </ul>"},{"location":"CHANGELOG/#v222-2022-08-26","title":"v2.2.2 (2022-08-26)","text":""},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>wrong method output type</li> <li>catching wrong exception</li> <li>exception in utils</li> </ul>"},{"location":"CHANGELOG/#v221-2022-08-24","title":"v2.2.1 (2022-08-24)","text":""},{"location":"CHANGELOG/#v220-2022-07-13","title":"v2.2.0 (2022-07-13)","text":""},{"location":"CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>log style now the same as stream, added support for tqdm</li> <li>added cross-section progress to log</li> <li>(#34)</li> <li>revised logger style (#34)</li> <li>first figure does not use correct style</li> <li>added 10 cm tolerance to section width correction</li> <li>main section width check</li> <li>output path compare1d2d discharge figure</li> <li> </li> </ul>"},{"location":"CHANGELOG/#33","title":"33","text":""},{"location":"CHANGELOG/#v212-2022-07-05","title":"v2.1.2 (2022-07-05)","text":""},{"location":"CHANGELOG/#v211-2022-07-04","title":"v2.1.1 (2022-07-04)","text":""},{"location":"CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>missing index.rst</li> </ul>"},{"location":"CHANGELOG/#v210-2022-07-04","title":"v2.1.0 (2022-07-04)","text":""},{"location":"CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>macos/linux posixpath fail fix</li> <li>isolated set_locale and wrapped in try/except</li> <li>possibly fix posix path error with trailing whitespace</li> <li>run with ini suffix fix (#29)</li> <li>docs now only build on master</li> </ul>"},{"location":"CHANGELOG/#feat","title":"Feat","text":"<ul> <li>expanded cli</li> <li>groundwork for expansion of cli (#31, #30)</li> <li>overwrite option for output, single output folder (#31)</li> <li>added new tools to utils</li> </ul>"},{"location":"CHANGELOG/#v200-2022-06-28","title":"v2.0.0 (2022-06-28)","text":""},{"location":"CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>IniFile: fixed bug introduced by switching to pathlib</li> <li>output path now relative to config file</li> </ul>"},{"location":"CHANGELOG/#v153-2022-05-27","title":"v1.5.3 (2022-05-27)","text":""},{"location":"CHANGELOG/#fix_5","title":"Fix","text":"<ul> <li>adding cm accuracy to section width check (#23)</li> </ul>"},{"location":"CHANGELOG/#v152-2022-05-27","title":"v1.5.2 (2022-05-27)","text":""},{"location":"CHANGELOG/#fix_6","title":"Fix","text":"<ul> <li>adding cm accuracy to section width check (#23)</li> <li>main section width check</li> <li>fixed bug introduced by earlier fix :p</li> <li>files now relative to config file (#24)</li> </ul>"},{"location":"CHANGELOG/#v151-2022-05-26","title":"v1.5.1 (2022-05-26)","text":""},{"location":"CHANGELOG/#fix_7","title":"Fix","text":"<ul> <li>CrossSection.py: add main section width requirement (#23)</li> </ul>"},{"location":"CHANGELOG/#v150-2022-05-26","title":"v1.5.0 (2022-05-26)","text":""},{"location":"CHANGELOG/#fix_8","title":"Fix","text":"<ul> <li>CrossSection.py: add main section width requirement (#23)</li> <li>sc bug</li> </ul>"},{"location":"CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>cli: new cli with poetry script hook &amp; python -m</li> </ul>"},{"location":"CHANGELOG/#v144-2022-05-03","title":"v1.4.4 (2022-05-03)","text":""},{"location":"CHANGELOG/#fix_9","title":"Fix","text":"<ul> <li>update black to 22.3 (#16)</li> </ul>"},{"location":"CHANGELOG/#v143-2021-11-29","title":"v1.4.3 (2021-11-29)","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"markdown/conceptual_design/","title":"Methodology","text":"<p>This chapter describes in more detail the steps FM2PROF takes to go from a 2D representation of reality to a 1D representation of reality. Conceptually, FM2PROF works in three distinct steps: (1) initialisation, (2) building cross-sections and (3) finalisation.</p>"},{"location":"markdown/conceptual_design/#initialisation","title":"Initialisation","text":"Image caption <p>The initialisation step involves parsing (i.e. reading and making available for further analysis) the 2D data. In this step control volumes and sections are defined as well. This step may take some time to complete, but this preprocessing greatly reduces the computation times in the next step.</p>"},{"location":"markdown/conceptual_design/#import-region-file","title":"Import region file","text":"<p>The <code>Region</code> file is specified in the configuration file.</p> <p>Warning</p> <p>For any reasonably sized river model, it is currently not advised to supply a polygon. Instead, a NetCDF file should be supplied. See <code>issue_region_polygon</code> for more information.</p>"},{"location":"markdown/conceptual_design/#import-section-file","title":"Import section file","text":"<p>The <code>Section</code> file is specified in the configuration file.</p> <p>Warning</p> <p>For any reasonably sized river model, it is currently not advised to supply a polygon. Instead, a NetCDF file should be supplied. See <code>issue_region_polygon</code> for more information.</p>"},{"location":"markdown/conceptual_design/#import-2d-data","title":"Import 2D data","text":""},{"location":"markdown/conceptual_design/#section_parsing_2d_data","title":"Parsing 2D data","text":"<p>Dflow2d uses a staggered grid to solve the (hydrostatic) flow equations. Because of this staggered approach, there is not a single 2D point that has all information. Flow information (flow velocity, discharge) is stored in [flow links]{.title-ref}, while geometry (bed level) is stored in cell faces. needs both information from the faces, as from the links.</p> The dflow2d staggered grid. <p>Below is a table that lists all variables read by from dflowd map output.</p> <p>FM2PROF variable                    Variable in dflow2d output</p> <p>x (at face)                         mesh2d_face_x</p> <p>y (at face)                         mesh2d_face_y</p> <p>area (at face)                      mesh2d_flowelem_ba</p> <p>bedlevel (at face)                  mesh2d_flowelem_bl</p> <p>x (at flow link)                    mesh2d_edge_x</p> <p>y (at flow link)                    mesh2d_edge_y</p> <p>edge_faces (at flow link)           mesh2d_edge_faces</p> <p>edge_nodes (at flow link)           mesh2d_edge_nodes</p> <p>waterdepth                          mesh2d_waterdepth</p> <p>waterlevel                          mesh2d_s1</p> <p>chezy_mean                          mesh2d_czs</p> <p>chezy_edge                          mesh2d_czu</p> <p>velocity_x                          mesh2d_ucx</p> <p>velocity_y                          mesh2d_ucy</p> <p>velocity_edge                       mesh2d_u1</p> <p>: Overview of variables from the 2D model that are used by FM2PROF</p>"},{"location":"markdown/conceptual_design/#classification-of-volumes","title":"Classification of volumes","text":"<p><code>Control volumes</code> are used to define which 2D datepoints are linked to which 1D cross-section. This is done in the following steps:</p> <ul> <li>Each node, link and face is assigned a <code>Region</code>{.interpreted-text     role=\"term\"}. This is currently done through DeltaShell (see     <code>issue_region_polygon</code>)</li> <li>For each region seperately, a scikit-learn     KNearestNeighbour     classifier is trained.</li> <li>The classifier is used to uniquely identify each 2D link and each     face to a 1D cross-section</li> </ul>"},{"location":"markdown/conceptual_design/#classification-of-sections","title":"Classification of sections","text":"<p><code>Sections &lt;Section&gt;</code> are used to output a different roughness function for the main channel and the floodplains. The purpose of the classification is to determine whether a 2D point belongs to the main channel section, or to the floodplain section (see warning below).</p> <p>Two methods are implemented:</p> <ul> <li><code>Variance based classification&lt;section_classification_variance&gt;</code>{.interpreted-text     role=\"ref\"}</li> <li>Polygon-based classification using DeltaShell (see     <code>issue_region_polygon</code>)</li> </ul> <p>Warning</p> <p>If classification is done using DeltaShell, it is possible to define more than two sections. However, this functionality is not tested and may not work properly.</p>"},{"location":"markdown/conceptual_design/#build-cross-section","title":"Build Cross-Section","text":"The dflow2d staggered grid. <p>Once initialisation is complete, will loop over each <code>cross-section location&lt;Cross-section location&gt;</code>{.interpreted-text role=\"term\"}. In each iteration, the program takes two steps: (1) building the geometry and (2) building the roughness tables.</p> <p>Warning</p> <p>No cross-section will be generated for locations that have no 2D data assigned or have less than 10 faces assigned. This may happen if a location lies outside the 2D grid, or if there are many cross-section closely together. If this happens, an error is raised by FM2PROF. The user should check the cross-section location input file to resolve the problem.</p>"},{"location":"markdown/conceptual_design/#build-geometry","title":"Build Geometry","text":"<p>In each loop, a number of steps is taken based on the 2D data that is uniquely assigned to that cross-section:</p> <ul> <li><code>Lakes</code> are identified using the     <code>identify_lakes</code></li> <li><code>Flow volume</code> and     <code>Storage volume</code> are seperated using     the <code>distinguish_storage</code></li> <li>The     <code>water level dependent geometry&lt;Water level (in)dependent geometry&gt;</code>{.interpreted-text     role=\"term\"} is computed using <code>wl_dependent_css</code>{.interpreted-text     role=\"ref\"}</li> <li>The     <code>water level independent geometry&lt;Water level (in)dependent geometry&gt;</code>{.interpreted-text     role=\"term\"} is computed using     <code>wl_independent_css</code></li> <li>The parameters for <code>Summerdikes</code> are     defined using the <code>sd_optimisation</code></li> <li>Finally, the cross-section is simplified using the     Visvalingam-Whyatt method of poly-line vertex reduction     <code>simplify_css</code></li> </ul>"},{"location":"markdown/conceptual_design/#build-roughness","title":"Build roughness","text":"<p>At each cross-section point, a roughness look-up table is constructed that relates water level (in m + NAP) to a Ch\u00e9zy roughness coefficient. This is done in three steps:</p> <ul> <li>For each section, a roughness table is constructed by averaging the     2D points</li> </ul>"},{"location":"markdown/conceptual_design/#finalisation","title":"Finalisation","text":"The dflow2d staggered grid."},{"location":"markdown/configuration/","title":"FM2PROF configuration","text":""},{"location":"markdown/configuration/#exec-1--input","title":"input","text":""},{"location":"markdown/configuration/#exec-1--2dmapoutput","title":"2DMapOutput","text":"<p>type: str</p> <p>default value: None</p> <p>Output file from FM2D model (.net file)</p>"},{"location":"markdown/configuration/#exec-1--crosssectionlocationfile","title":"CrossSectionLocationFile","text":"<p>type: str</p> <p>default value: None</p> <p>.csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.</p>"},{"location":"markdown/configuration/#exec-1--regionpolygonfile","title":"RegionPolygonFile","text":"<p>type: str</p> <p>default value: None</p> <p>User defined polygons in json format</p>"},{"location":"markdown/configuration/#exec-1--sectionpolygonfile","title":"SectionPolygonFile","text":"<p>type: str</p> <p>default value: None</p> <p>User defined polygons in json format</p>"},{"location":"markdown/configuration/#exec-1--parameters","title":"parameters","text":""},{"location":"markdown/configuration/#exec-1--casename","title":"CaseName","text":"<p>type: str</p> <p>default value: None</p> <p>Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used</p>"},{"location":"markdown/configuration/#exec-1--maximumpointsinprofile","title":"MaximumPointsInProfile","text":"<p>type: int</p> <p>default value: None</p> <p>Number of points which are used to generate cross-sections</p>"},{"location":"markdown/configuration/#exec-1--conveyancedetectionmethod","title":"ConveyanceDetectionMethod","text":"<p>type: int</p> <p>default value: None</p> <p>[0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)</p>"},{"location":"markdown/configuration/#exec-1--absolutevelocitythreshold","title":"AbsoluteVelocityThreshold","text":"<p>type: float</p> <p>default value: None</p> <p>Absolute velocity threshold in m/s. Used to determine storage</p>"},{"location":"markdown/configuration/#exec-1--relativevelocitythreshold","title":"RelativeVelocityThreshold","text":"<p>type: float</p> <p>default value: None</p> <p>Relative velocity threshold (percentage). Used to determine storage</p>"},{"location":"markdown/configuration/#exec-1--minimumdepththreshold","title":"MinimumDepthThreshold","text":"<p>type: float</p> <p>default value: None</p> <p>Minimum depth (m) for storage identification</p>"},{"location":"markdown/configuration/#exec-1--bedlevelcriterium","title":"BedlevelCriterium","text":"<p>type: float</p> <p>default value: None</p> <p>Ignore the lowest percentage of bed level points</p>"},{"location":"markdown/configuration/#exec-1--laketimesteps","title":"LakeTimesteps","text":"<p>type: int</p> <p>default value: None</p> <p>Number of timesteps that are used for identifying lakes</p>"},{"location":"markdown/configuration/#exec-1--extrapolatestorage","title":"ExtrapolateStorage","text":"<p>type: fm2prof.IniFile.ImportBoolType</p> <p>default value: None</p> <p>Add storage to water level independent cross-section section</p>"},{"location":"markdown/configuration/#exec-1--sdcorrection","title":"SDCorrection","text":"<p>type: fm2prof.IniFile.ImportBoolType</p> <p>default value: None</p> <p>Use summerdike volume correction</p>"},{"location":"markdown/configuration/#exec-1--sdfloodplainbase","title":"SDFloodplainBase","text":"<p>type: float</p> <p>default value: None</p> <p>minimum distance between floodplain base level and crest level in meters</p>"},{"location":"markdown/configuration/#exec-1--sdtransitionheight","title":"SDTransitionHeight","text":"<p>type: float</p> <p>default value: None</p> <p>Transition height at the summer dike (m)</p>"},{"location":"markdown/configuration/#exec-1--sdoptimisationmethod","title":"SDOptimisationMethod","text":"<p>type: int</p> <p>default value: None</p> <p>[0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both</p>"},{"location":"markdown/configuration/#exec-1--frictionweighingmethod","title":"FrictionWeighingMethod","text":"<p>type: int</p> <p>default value: None</p> <p>Options. [0] arithmetric mean, [1] Weighted average</p>"},{"location":"markdown/configuration/#exec-1--skipmaps","title":"SkipMaps","text":"<p>type: int</p> <p>default value: None</p> <p>number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. </p>"},{"location":"markdown/configuration/#exec-1--classificationmethod","title":"ClassificationMethod","text":"<p>type: int</p> <p>default value: None</p> <p>How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell</p>"},{"location":"markdown/configuration/#exec-1--minimumtotalwidth","title":"MinimumTotalWidth","text":"<p>type: float</p> <p>default value: None</p> <p>Minimum width in meters. Zero width may lead to numerical instability in 1D solvers</p>"},{"location":"markdown/configuration/#exec-1--debug","title":"debug","text":""},{"location":"markdown/configuration/#exec-1--exportcssdata","title":"ExportCSSData","text":"<p>type: fm2prof.IniFile.ImportBoolType</p> <p>default value: None</p> <p>If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.</p>"},{"location":"markdown/configuration/#exec-1--exportmapfiles","title":"ExportMapFiles","text":"<p>type: fm2prof.IniFile.ImportBoolType</p> <p>default value: None</p> <p>Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.</p>"},{"location":"markdown/configuration/#exec-1--cssselection","title":"CssSelection","text":"<p>type: fm2prof.IniFile.ImportListType</p> <p>default value: None</p> <p>provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections</p>"},{"location":"markdown/configuration/#exec-1--output","title":"output","text":""},{"location":"markdown/configuration/#exec-1--outputdirectory","title":"OutputDirectory","text":"<p>type: str</p> <p>default value: None</p> <p>Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory</p>"},{"location":"markdown/contributing/","title":"Contributing","text":""},{"location":"markdown/contributing/#set-up-development-environment","title":"Set up development environment","text":""},{"location":"markdown/contributing/#style-conventions","title":"Style conventions","text":"<p>Please use Google-style docstring syntax</p>"},{"location":"markdown/contributing/#test-new-code","title":"Test new code","text":"<p>To run tests locally, use pytest:</p> <p><code>poetry run pytest --cov=fm2prof</code></p> <p>To check coverage:</p> <p><code>poetry run pytest --cov=fm2prof</code></p>"},{"location":"markdown/contributing/#deploying","title":"Deploying","text":""},{"location":"markdown/contributing/#locally-build-executable","title":"Locally build executable","text":"<p>To build a local version of an FM2PROF executable, run:</p> <p><code>poetry run pyinstaller FM2PROF_WINDOWS.spec</code></p>"},{"location":"markdown/contributing/#making-a-new-release","title":"Making a new release","text":"<p>After merging a PR, make a new tag. Using version <code>v2.3.0</code> as an example;</p> <p><code>git tag v2.3.0</code></p> <p>Use Github interface to draft a new release. Attach the executable. Then, update the documentation:</p> <p><code>poetry run mike deploy v2.3.0 latest -u</code></p> <p>Checkout the documentation branch</p> <p><code>git checkout gh-pages</code></p> <p>and push changes to github</p> <p><code>git push</code></p>"},{"location":"markdown/glossary/","title":"Glossary","text":""},{"location":"markdown/glossary/#region","title":"Region","text":"<p>Regions are used to have some finer control over which 2D model output is assigned to which 1D cross-section. If no region are defined, 2D model output is assigned to cross-section using k-nearest neighbour. This is not always a good approach, for example if a tributary or retention area. In the figure a section of the River Meuse is plotted near the Blitterswijck retention area. The retention area is demarcated from the main river by levees. Cross-sections generated for the retention area should therefore not 'eat out of' the area of the main channel - which could results in a small cross-section non-physical constriction of the flow.</p> Region polygons are used to prevent cross-sections generated     in the retention area to 'eat out of' the main channel. Within each     region polygon (red borders) nearest neighour is used to assign 2D     points to cross-sections. Points with the same color are associated with     the same 1D cross-section"},{"location":"markdown/glossary/#section","title":"Section","text":"<p>Section are used to divide the cross-section between floodplain and main channel (e.g. the 'floodplain' section and the 'main channel' section). This distinction is only used to assign different roughness values to each section.</p>"},{"location":"markdown/glossary/#water-level-independent-geometry","title":"Water level (in)dependent geometry","text":"<p>It is often not possible to start the 2D computation from a completely dry bed - instead some initial water level is present in the model. This initial condition divides the 1D geometry in water level dependent part and a water level independent part. Below the initial condition, we cannot take advantage of the 2D model to tell us which cells are part of the conveyance and which cells are wet. Instead, the water level is artificially lowered in a number of steps to estimate the volume below the initial water levels.</p>"},{"location":"markdown/glossary/#summerdikes","title":"Summerdikes","text":"<p>Summerdikes are a Dutch term for levees that are designed to be flooded with higher discharges, but not with relatively low floods (i.e.: they withstand summer floods). They contrast with 'winterdikes', which are designed to not flood at all. Summerdikes effectively comparimentalise the floodplain. They can have a profound effect on stage-discharge relationships: as these levees overflow the compartments start flowing which leads to a retention effect. Such an effect cannot be modelled using regulare cross-sections. SOBEK therefore has a 'summerdike' functionality.</p>"},{"location":"markdown/glossary/#control-volume","title":"Control volume","text":"<p>A control volume of a cross-section is the geographical part of the 2D model that is associated with that cross-section. Contol volumes are assigned by k-Nearest Neighbour classification.</p> <p>Note</p> <p>Control volumes are the equivalent of WAQ2PROF's sobekvakken</p> A control volume"},{"location":"markdown/glossary/#lakes","title":"Lakes","text":"<p>Lakes are water bodies that are not hydraulically connected to the main channel in the first few timesteps of the 2D model computation. They do not contribute to the volume present in the control volume until they connect with the rest of the river and will not feature in the water level independent computation.  Water bodies that are connected to the main channel in the first few timesteps do count as volume. However, as these likely do not contribute to conveyance, they will be flagged as 'storage' instead.</p>"},{"location":"markdown/glossary/#cross-section-location","title":"Cross-section location","text":"<p>The cross-section location is defined in the <code>CrossSectionLocationFile</code>.</p>"},{"location":"markdown/glossary/#total-volume","title":"Total volume","text":"<p>The Total volume refers to the volume of water [in m\\^3] within a <code>Control volume</code> for a given water level at the <code>Cross-section location</code>{.interpreted-text role=\"term\"}. The total volume is the sum of the <code>Flow volume</code> and the <code>Storage volume</code>.</p>"},{"location":"markdown/glossary/#flow-volume","title":"Flow volume","text":"<p>The Flow volume is defined as the volume of water [in m\\^3] for which the conditions for flowing water are met. This volume is considered to be available for the conveyance of water through the <code>Control volume</code>.</p> <p>See <code>distinguish_storage</code></p>"},{"location":"markdown/glossary/#storage-volume","title":"Storage volume","text":"<p>The Storage volume is defined as the volume of water [in m\\^3] for which the conditions for flowing water are not met. Storage volume does not contribute to conveyance, but serves only for water retention. Examples include groyne fields and</p> <p>See <code>distinguish_storage</code></p>"},{"location":"markdown/glossary/#total-width","title":"Total width","text":"<p>See <code>Total volume</code></p>"},{"location":"markdown/glossary/#flow-width","title":"Flow width","text":"<p>See <code>Flow volume</code></p>"},{"location":"markdown/installation/","title":"Getting started","text":""},{"location":"markdown/installation/#installation","title":"Installation","text":"<p>FM2PROF is a package written in Python. If you're familiar with Python, you can install FM2PROF with <code>pip</code>, the Python package manager. If not, we recommend the executable. </p>"},{"location":"markdown/installation/#with-pip","title":"With pip","text":"<p>FM2PROF is published as a Python package and can be installed with <code>pip</code>, ideally by using a virtual environment and using Python 3.10 or higher. Open up a terminal and install FM2PROF with:</p> LatestSpecific versionupdate existing install <pre><code>pip install fm2prof\n</code></pre> <pre><code>pip install fm2prof=\"2.2.8\"\n</code></pre> <pre><code>pip install fm2prof --upgrade\n</code></pre> <p>This will also install compatible versions of all dependencies like <code>numpy</code>, and <code>pandas</code>. </p>"},{"location":"markdown/installation/#executable","title":"Executable","text":"<p>FM2PROF is compiled to an executable for Windows (version 1.5.4 and higher). Download them from Releases on the Github home page.</p> <p>The executable provides a command line interface (CLI). To use it, make sure it is available in your Path. To view available options, open a Terminal and type:</p> <pre><code>FM2PROF --help\n</code></pre> <p>Warning</p> <p>The first time you call the executable, it may take a long time to produce results. This is because your OS needs to unpack the executable.</p>"},{"location":"markdown/numerical_methods/","title":"Numerical methods","text":""},{"location":"markdown/numerical_methods/#cross-section-construction","title":"Cross-section construction","text":""},{"location":"markdown/numerical_methods/#conveyance-storage-separation","title":"Conveyance-storage separation","text":"<p>In 1D hydrodynamic models, flow through a cross-section is resolved assuming a  cross-sectionally average velocity. This assumed that the entire cross-section is available to for conveyance. However in reality some parts of the cross-section do not contribute to flow. For example, sections of a river behind a levee where water is stagnant contribute to storage (volume), but not flow. </p> <p>SOBEK enables distinction between 'flow area' and 'storage area'. <code>fm2prof</code> implements methods to resolve from 2D model output which cells add to the 'flow volume' within a control volume and which to the storage volume. </p> <p><code>fm2prof</code> implements two methods. The configuration parameter <code>ConveyanceDetectionMethod</code> is used to determine which method is used.</p> <p><code>max_method</code> A cell is considered flowing if the velocity magnitude is more than the average of the three higher flow velocities per outputmap multiplied by the  <code>relative velocity threshold</code> OR if the flow velocity meets the absolute threshold <code>absolute velocity threshold</code></p> <p><code>mean_method</code> Not recommended. Legacy method.</p> <p>Parameters:</p> Name Type Description Default <code>waterdepth</code> <code>DataFrame</code> <p>dataframe of a control volume with waterdepths per cel per output map</p> required <code>velocity</code> <code>DataFrame</code> <p>dataframe of a control volume with velocity magnitude per cel per output map</p> required <p>Returns:</p> Name Type Description <code>flow_mask</code> <code>DataFrame</code> <p>dataframe of a control volume with the flow condition per cel per output map. <code>True</code> means flowing, <code>False</code> storage.</p> Source code in <code>fm2prof\\CrossSection.py</code> <pre><code>def _distinguish_conveyance_from_storage(self, waterdepth: pd.DataFrame, velocity: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    In 1D hydrodynamic models, flow through a cross-section is resolved assuming a \n    cross-sectionally average velocity. This assumed that the entire cross-section\n    is available to for conveyance. However in reality some parts of the cross-section\n    do not contribute to flow. For example, sections of a river behind a levee where\n    water is stagnant contribute to storage (volume), but not flow. \n\n    SOBEK enables distinction between 'flow area' and 'storage area'. `fm2prof` implements\n    methods to resolve from 2D model output which cells add to the 'flow volume' within a\n    [control volume](glossary.md#control-volume) and which to the storage volume. \n\n    `fm2prof` implements two methods. The configuration parameter [`ConveyanceDetectionMethod`](configuration.md#exec-1--conveyancedetectionmethod) is used\n    to determine which method is used.\n\n    **`max_method`**\n    A cell is considered flowing if the velocity magnitude is more than the average\n    of the three higher flow velocities per outputmap multiplied by the \n    [`relative velocity threshold`](configuration.md#exec-1--relativevelocitythreshold) OR\n    if the flow velocity meets the absolute threshold [`absolute velocity threshold`](configuration.md#exec-1--absolutevelocitythreshold)\n\n    **`mean_method`**\n    Not recommended. Legacy method.\n\n    Parameters:\n        waterdepth: dataframe of a control volume with waterdepths per cel per output map\n        velocity:  dataframe of a control volume with velocity magnitude per cel per output map\n\n    Returns:\n        flow_mask: dataframe of a control volume with the flow condition per cel per output map. `True` means flowing, `False` storage. \n    \"\"\"\n    @staticmethod\n    def max_velocity_method(waterdepth: pd.DataFrame, velocity: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"\n        This method was added in version 2.3 because the mean_velocity_method\n        led to unreasonably high conveyance if the river was connected to \n        an inland harbour. \n        \"\"\"\n        # This condition may be redundant\n        waterdepth_condition = waterdepth &gt; 0\n\n        # Determine maximum as the average of the top 3 flow velocities\n        maxv = velocity.max()\n        for i in velocity:\n            maxv[i] = velocity[i].sort_values().iloc[-3:].mean()\n\n        # Relative to max condition\n        relative_velocity_condition = velocity &gt; maxv*self.get_parameter(self.__cs_parameter_relative_threshold)\n\n        # Absolute flow condition\n        absolute_velocity_condition =  velocity &gt; self.get_parameter(self.__cs_parameter_velocity_threshold)\n\n        # Flow mask determines which cells are conveyance (TRUE)\n        flow_mask = waterdepth_condition &amp; (relative_velocity_condition | absolute_velocity_condition)\n\n        return flow_mask\n\n    @staticmethod\n    def mean_velocity_method(waterdepth, velocity):\n        \"\"\"\n        This was the default method &lt; 2.3. This method leads to unreasonably \n        high conveyance if the river was connected to an inland harbour. \n        \"\"\"\n        # apply rolling average over the velocities\n        # to smooth out extreme values\n        velocity = velocity.rolling(\n            window=10, min_periods=1, center=True).mean()\n\n        flow_mask = (\n            (waterdepth &gt; 0)\n            &amp; (velocity &gt; self.get_parameter(self.__cs_parameter_velocity_threshold))\n            &amp; (\n                velocity\n                &gt; self.get_parameter(self.__cs_parameter_relative_threshold)\n                * np.mean(velocity)\n            )\n        )\n\n        return flow_mask\n\n    match self.get_inifile().get_parameter(self.__cs_parameter_conveyance_detection_method):\n        case 0:\n            return mean_velocity_method(waterdepth, velocity)    \n        case 1:\n            return max_velocity_method(waterdepth, velocity)\n        case _:\n            self.set_logger_message('Invalid conveyance method. Defaulting to [1]', 'warning')\n            return max_velocity_method(waterdepth, velocity)\n</code></pre>"},{"location":"markdown/numerical_methods/#simplification","title":"Simplification","text":"<p>The cross-section geometry generated by <code>fm2prof</code> contains one point per output timestep in the 2D map file. This resolution is often too high given the complexity of the cross-sections, and results in very large input files for the 1D model. Therefore <code>fm2prof</code> includes a simplification algorithm that reduces the number of points while preservering the shape of the geometry. This algorithm reduces as many points until the number specified in <code>MaximumPointsInProfile</code> is reached.</p> <p>We use the Visvalingam-Whyatt method of poly-line vertex reduction<sup>1</sup>. The total width is leading for the simplification of the geometry meaning that the choice for which points to remove to simplify the geometry is based on the total width. Subsequently, the corresponding point are removed from the flow width.</p> <ol> <li> <p>Visvalingam, M and Whyatt J D (1993) \"Line Generalisation by Repeated Elimination of Points\", Cartographic J., 30 (1), 46 - 51 URL: http://web.archive.org/web/20100428020453/http://www2.dcs.hull.ac.uk/CISRG/publications/DPs/DP10/DP10.html     Implemented vertex reduction methods:\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>count_after</code> <code>int</code> <p>number of points in cross-section after application of this function</p> <code>20</code> Source code in <code>fm2prof\\CrossSection.py</code> <pre><code>def reduce_points(self, count_after: int = 20) -&gt; None:\n    \"\"\"\n    The cross-section geometry generated by `fm2prof` contains one point per output\n    timestep in the 2D map file. This resolution is often too high given the\n    complexity of the cross-sections, and results in very large input files for the\n    1D model. Therefore `fm2prof` includes a simplification algorithm that reduces\n    the number of points while preservering the shape of the geometry. This algorithm\n    reduces as many points until the number specified in\n    `MaximumPointsInProfile` is reached.\n\n    We use the Visvalingam-Whyatt method of poly-line vertex reduction[^1].\n    The [total width](glossary.md#total-width) is leading for the simplification of the geometry meaning\n    that the choice for which points to remove to simplify the geometry is based on\n    the total width. Subsequently, the corresponding point are removed from the [flow width](glossary.md#flow-width).\n\n    [^1]:\n        Visvalingam, M and Whyatt J D (1993) \"Line Generalisation by Repeated Elimination of Points\", Cartographic J., 30 (1), 46 - 51 URL: http://web.archive.org/web/20100428020453/http://www2.dcs.hull.ac.uk/CISRG/publications/DPs/DP10/DP10.html\n            Implemented vertex reduction methods:\n\n\n    Parameters:\n        count_after: number of points in cross-section after application of this function\n\n    \"\"\"\n\n    n_before_reduction = self.get_number_of_vertices()\n\n    points = np.array(\n        [\n            [self._css_z[i], self._css_total_width[i]]\n            for i in range(n_before_reduction)\n        ]\n    )\n\n    # The number of points is equal to n, it cannot be further reduced\n    reduced_index = np.array([True] * n_before_reduction)\n\n    if n_before_reduction &gt; count_after:\n        try:\n            simplifier = PS.VWSimplifier(points)\n            reduced_index = simplifier.from_number_index(count_after)\n        except Exception as e:\n            self.set_logger_message(\n                \"Exception thrown while using polysimplify: \"\n                + \"{}\".format(str(e)),\n                \"error\",\n            )\n\n    # Write to attributes\n    self.z = self._css_z[reduced_index]\n    self.total_width = self._css_total_width[reduced_index]\n    self.flow_width = self._css_flow_width[reduced_index]\n\n    self.set_logger_message(\n        \"Cross-section reduced \"\n        + \"from {} \".format(n_before_reduction)\n        + \"to {} points\".format(len(self.total_width))\n    )\n\n    self._css_is_reduced = True\n</code></pre>"},{"location":"markdown/numerical_methods/#lake-identification","title":"Lake identification","text":"<p>This algorithms determines whether a 2D cell should be marked as Lake.</p> <p>Cells are marked as lake if the following conditions are both met: - the waterdepth on timestep LakeTimeSteps is positive - the waterdepth on timestep LakeTimeSteps is at least 1 cm higher than the waterlevel on timestep 0.</p> <p>Next, the following steps are taken</p> <ul> <li>It is determined at what timestep the waterlevel in the lake starts rising. From that point on the lake counts as regular geometry and counts toward the total volume. A cell is considered active if its waterlevel has risen by 1 mm.</li> <li>A correction matrix is built that contains the 'lake water level' for each lake cell. This matrix is subtracted from the waterdepth to compute volumes.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>waterdepth</code> <code>DataFrame</code> <p>a DataFrame containing all waterdepth output in the control volume</p> required <p>Returns:</p> Name Type Description <code>lake_mask</code> <code>ndarray</code> <p>mask of all cells that are a 'lake'</p> <code>wet_not_lake_mask</code> <code>ndarray</code> <p>mask of all cells that are wet, but not a lake</p> <code>lake_depth_correction</code> <code>ndarray</code> <p>the depth of a lake at the start of the 2D computation</p> Source code in <code>fm2prof\\CrossSection.py</code> <pre><code>def _identify_lakes(self, waterdepth:pd.DataFrame) -&gt; np.ndarray:\n    \"\"\"\n    This algorithms determines whether a 2D cell should\n    be marked as [Lake](glossary.md#Lakes).\n\n    Cells are marked as lake if the following conditions are both met:\n    - the waterdepth on timestep [LakeTimeSteps](configuration.md#exec-1--laketimesteps) is positive\n    - the waterdepth on timestep [LakeTimeSteps](configuration.md#exec-1--laketimesteps) is at least 1 cm higher than the waterlevel on timestep 0.\n\n    Next, the following steps are taken\n\n    - It is determined at what timestep the waterlevel in the lake starts rising. From that point on the lake counts as regular geometry and counts toward the total volume. A cell is considered active if its waterlevel has risen by 1 mm.\n    - A correction matrix is built that contains the 'lake water level' for each lake cell. This matrix is subtracted from the waterdepth to compute volumes.\n\n\n    Parameters:\n        waterdepth: a DataFrame containing all waterdepth output in the [control volume](glossary.md#control-volume)\n\n    Returns:\n        lake_mask: mask of all cells that are a 'lake'\n        wet_not_lake_mask: mask of all cells that are wet, but not a lake\n        lake_depth_correction: the depth of a lake at the start of the 2D computation\n\n    \"\"\"\n    # preallocate arrays\n    plassen_depth_correction = np.zeros(waterdepth.shape, dtype=float)\n\n    # check for non-rising waterlevels\n    waterdepth_diff = np.diff(waterdepth, n=1, axis=-1)\n\n    # find all wet cells\n    wet_mask = waterdepth &gt; 0\n\n    # find all lakes\n    lake_mask = (\n        waterdepth.T.iloc[self.get_parameter(self.__cs_parameter_plassen_timesteps)]\n        &gt; 0\n    ) &amp; (\n        np.abs(\n            waterdepth.T.iloc[\n                self.get_parameter(self.__cs_parameter_plassen_timesteps)\n            ]\n            - waterdepth.T.iloc[0]\n        )\n        &lt;= 0.01\n    )\n\n    self.plassen_mask = lake_mask\n\n    # Plassen_mask_time is to determine at whata timestep the lake starts rising again.\n    plassen_mask_time = np.zeros((len(waterdepth.T), len(lake_mask)), dtype=bool)\n\n    # At t=0, all lakes are inactive\n    plassen_mask_time[0, :] = lake_mask\n\n    # walk through dataframe in time, for each timestep check\n    # when to unmask a plassen cell\n    for i, diff in enumerate(waterdepth_diff.T):\n        final_mask = reduce(\n            np.logical_and, [(diff &lt;= 0.001), (plassen_mask_time[i] == True)]\n        )\n        plassen_mask_time[i + 1, :] = final_mask\n\n    plassen_mask_time = pd.DataFrame(plassen_mask_time).T\n\n    # The depth of a lake is the waterdepth at t=0\n    for i, depths in enumerate(waterdepth):\n        plassen_depth_correction[lake_mask, i] = -waterdepth.T.iloc[0][lake_mask]\n\n    # correct wet cells for plassen\n    wet_not_plas_mask = reduce(\n        np.logical_and, [(wet_mask == True), np.asarray(plassen_mask_time == False)]\n    )\n\n    return lake_mask, wet_not_plas_mask, plassen_depth_correction\n</code></pre>"},{"location":"markdown/quickstart/","title":"Tutorial","text":"<p>In this tutorial we will walk through the basics of creating a 1D model input from a 2D model.</p> <p>To use , we need at least two input files:</p> <ul> <li><code>2DMapOutput</code></li> <li><code>CrossSectionLocationFile</code></li> </ul> <p>in this tutorial we will use the test data bundled with the package. You will find this in the source directory:</p> <pre><code># 2DMapOutput\ntests\\test_data\\cases\\case_02_compound\\Data\\2DModelOutput\\FlowFM_map.nc \n# CrossSectionLocationFile\ntests\\test_data\\cases\\case_02_compound\\Data\\cross_section_locations.xyz  \n</code></pre> <p>This case is a simple 2D compound channel model.</p>"},{"location":"markdown/quickstart/#create-a-new-project","title":"Create a new project","text":"<p>To start a new project:</p> PythonCLI <pre><code>from fm2prof.IniFile import IniFile\n\ninifile = IniFile().print_configuration()\nini_path = f\"MyProject.ini\"\n\nwith open(ini_path, \"w\") as f:\n    f.write(inifile)\n</code></pre> <pre><code>FM2PROF create MyProject\n</code></pre> <p>This will create a valid configuration file with all parameters set to their default values. </p>"},{"location":"markdown/quickstart/#modify-the-input","title":"Modify the input","text":"<p>For the purpose of this tutorial, move the 2D model simulation file to [input]{.title-ref}. This is not a requirement - you can refer to any location on your pc.</p> <p>Open the configuration file with your favorite text editor and change the following two settings to your input data:</p> <pre><code>[input]\n2DMapOutput                   =         # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\n</code></pre> <p>To be sure you used the correct data, run:</p> PythonCLI <pre><code>from fm2prof import Project\n\nproject = Project(\"MyProject.ini\")\n</code></pre> <pre><code>FM2PROF check MyProject\n</code></pre> <p>Study the output. Errors indicate that something is wrong with your input. In that case, you will need to correct the configurationfile.</p>"},{"location":"markdown/quickstart/#run-fm2prof","title":"Run FM2PROF","text":"<p>You should also see a print-out of the configuration file. These are the settings that will be used and can be altered using a config file. The configuration file does not need all parameters to be specified. If a parameter is not in the configuration file, default values will be used.</p> <p>The following examples run FM2PROF, overwrite any existing results and produce figures of the generated cross-sections. </p> PythonCLI <pre><code>from fm2prof import Project\nfrom fm2prof.utils import VisualiseOutput\n\n# load project\nproject = Project(\"MyProject.ini\")\n\n# overwrite = True overwrites any existing output\nproject.run(overwrite=True)\n\n# to visualize cross-sectino putput:\nvis = VisualiseOutput(\n            project.get_output_directory(), \n            logger=project.get_logger()\n        )\n\nfor css in vis.cross_sections:\n    vis.figure_cross_section(css)\n</code></pre> <pre><code>FM2PROF run MyProject -o -p\n</code></pre> <p>All <code>outputFiles</code> are written to the <code>output</code> directory specified in the FM2PROF configuration file. </p> <p>After generating output it is important to check whether everything went well. See the following links to learn more about available tools:</p> <ul> <li>Inspection cross-sections using a notebook</li> </ul>"},{"location":"markdown/utils/","title":"Utilities API","text":"<p>FM2PROF includes a set of utilities to analyse its output. </p>"},{"location":"markdown/utils/#compare1d2d","title":"Compare1D2D","text":"<p>             Bases: <code>ModelOutputReader</code></p> <p>Utility to compare the results of a 1D and 2D model through  visualisation and statistical post-processing. </p> Note <p>If 2D and 1D netCDF input files are provided, they will first be  converted to csv files. Once csv files are present, the original netCDF files are no longer used. In that case, the arguments  to <code>path_1d</code> and <code>path_2d</code> should be <code>None</code>. </p> Example usage <pre><code>from fm2prof import Project, utils\nproject = Project(fr'tests/test_data/compare1d2d/cases/case1/fm2prof.ini')\nplotter = utils.Compare1D2D(project=project,\n                            start_time=datetime(year=2000, month=1, day=5))\n\nplotter.figure_at_station(\"NR_919.00\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p><code>fm2prof.Project</code> object.</p> required <code>path_1d</code> <code>Union[Path, str] | None</code> <p>path to SOBEK dimr directory</p> <code>None</code> <code>path_2d</code> <code>Union[Path, str] | None</code> <p>path to his nc file</p> <code>None</code> <code>routes</code> <code>List[List[str]] | None</code> <p>list of branch abbreviations, e.g. ['NR', 'LK']</p> <code>None</code> <code>start_time</code> <code>Union[None, datetime]</code> <p>start time for plotting and analytics. Use this to crop the time to prevent initalisation from affecting statistics. </p> <code>None</code> <code>stop_time</code> <code>Union[None, datetime]</code> <p>stop time for plotting and analytics. </p> <code>None</code> <code>style</code> <code>str</code> <p><code>PlotStyles</code> style</p> <code>'sito'</code> Source code in <code>fm2prof\\utils.py</code> <pre><code>def __init__(\n    self,\n    project: Project,\n    path_1d: Union[Path, str] | None = None,\n    path_2d: Union[Path, str] | None = None,\n    routes: List[List[str]] | None = None,\n    start_time: Union[None, datetime] = None,\n    stop_time: Union[None, datetime] = None,\n    style: str = 'sito',\n):\n    if project:\n        super().__init__(logger=project.get_logger(), start_time=start_time, stop_time=stop_time)\n        self.output_path = project.get_output_directory()\n    else:\n        super().__init__()\n\n    if isinstance(path_1d, (Path, str)) and Path(path_1d).is_file():\n        self.path_flow1d = path_1d\n    else:\n        self.set_logger_message(f'1D netCDF file does not exist or is not provided. Input provided: {path_1d}.', 'debug')\n    if isinstance(path_1d, (Path, str)) and Path(path_2d).is_file():\n        self.path_flow2d = path_2d\n    else:\n        self.set_logger_message(f'2D netCDF file does not exist or is not provided. Input provided: {path_2d}.', 'debug')\n\n    self.routes = routes\n    self.statistics = None\n    self._data_1D_H: pd.DataFrame = None\n    self._data_2D_H: pd.DataFrame = None\n    self._data_1D_H_digitized: pd.DataFrame = None\n    self._data_2D_H_digitized: pd.DataFrame = None\n    self._qsteps = np.arange(0, 100 * np.ceil(18000 / 100), 200)\n\n    # initiate plotstyle\n    self._error_colors = [\"#7e3e00\", \"#FF4433\", \"#d86a00\"]\n    self._color_error = self._error_colors[1]\n    self._color_scheme = COLORSCHEMES[\"Koeln\"]\n    self._plotstyle: str = style\n    PlotStyles.apply(style=self._plotstyle)\n\n    # set start time\n    self.start_time = start_time\n    self.stop_time = stop_time\n\n    self.read_all_data()\n    self.digitize_data()\n\n    # create output folder\n    output_dirs = [\n        \"figures/longitudinal\",\n        \"figures/discharge\",\n        \"figures/heatmaps\",\n        \"figures/stations\",\n    ]\n    for od in output_dirs:\n        try:\n            os.makedirs(self.output_path.joinpath(od))\n        except FileExistsError:\n            pass\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.eval","title":"<code>eval()</code>","text":"<p>does a bunch</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def eval(self):\n    \"\"\"\n    does a bunch\n    \"\"\"\n    for route in tqdm.tqdm(self.routes):\n        self.set_logger_message(f\"Making figures for route {route}\")\n        self.figure_longitudinal_rating_curve(route)\n        self.figure_longitudinal_time(route)\n        self.heatmap_rating_curve(route)\n        self.heatmap_time(route)\n\n    self.set_logger_message(f\"Making figures for stations\")\n    for station in tqdm.tqdm(self.stations(), total=self._data_1D_H.shape[1]):\n        self.figure_at_station(station)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_at_station","title":"<code>figure_at_station(station, func='time', savefig=True)</code>","text":"<p>Creates a figure with the timeseries at a single observation station.</p> <p>Parameters:</p> Name Type Description Default <code>station</code> <code>str</code> <p>name of station. use <code>stations</code> method to list all station names</p> required <code>func</code> <code>str</code> <p>use <code>time</code> for a timeseries and <code>qh</code> for rating curve</p> <code>'time'</code> <code>savefig</code> <code>bool</code> <p>if True, saves to png. If False, returned FigureOutput</p> <code>True</code> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_at_station(self, station: str, func:str=\"time\", savefig:bool=True) -&gt; FigureOutput:\n    \"\"\"\n    Creates a figure with the timeseries at a single observation station.\n\n    ``` py\n\n    ```\n\n    Parameters:\n        station: name of station. use `stations` method to list all station names\n        func: use `time` for a timeseries and `qh` for rating curve\n        savefig: if True, saves to png. If False, returned FigureOutput\n\n\n\n    \"\"\"\n\n    fig, ax = plt.subplots(1, figsize=(12, 5))\n    error_ax = ax.twinx()\n\n    # q/h view\n    match func.lower():\n        case \"qh\":\n            ax.plot(\n                self._qsteps,\n                self._data_2D_H_digitized[station],\n                \"--\",\n                linewidth=2,\n                label=\"2D\",\n            )\n            ax.plot(\n                self._qsteps,\n                self._data_1D_H_digitized[station],\n                \"-\",\n                linewidth=2,\n                label=\"1D\",\n            )\n            ax.set_title(f\"{station}\\nQH-relatie\")\n            ax.set_title(\"QH-relatie\")\n            ax.set_xlabel(\"Afvoer [m$^3$/s]\")\n            ax.set_ylabel(\"Waterstand [m+NAP]\")\n            error_ax.plot(\n                self._qsteps,\n                self._data_1D_H_digitized[station] - self._data_2D_H_digitized[station],\n                \".\",\n                color=self._color_error,\n            )\n        case \"time\":\n            ax.plot(self.data_2D_H[station], \"--\", \n                    linewidth=2,\n                    label=\"2D\")\n            ax.plot(self.data_1D_H[station], \"-\", \n                    linewidth=2,\n                    label=\"1D\")\n\n            ax.set_ylabel(\"Waterstand [m+NAP]\")\n            ax.set_title(f\"{station}\\nTijdreeks\")\n\n            error_ax.plot(\n                self.data_1D_H[station] - self.data_2D_H[station],\n                \".\",\n                label=\"1D-2D\",\n                color=self._color_error,\n            )\n\n    # statistics\n    stats = self._get_statistics(station)\n\n    stats_labels = [\n        f\"bias={stats['bias']:.2f} m\",\n        f\"std={stats['std']:.2f} m\",\n        f\"MAE={stats['mae']:.2f} m\",\n    ]\n    stats_handles = [mpatches.Patch(color=\"white\")] * len(stats_labels)\n\n    # Style\n    fig, lgd = PlotStyles.apply(fig=fig, \n                                style=self._plotstyle,\n                                use_legend=True, \n                                extra_labels=[stats_handles, stats_labels]\n                            )\n\n    self._style_error_axes(error_ax, ylim=[-1, 1])\n\n    fig.tight_layout()\n\n    if savefig:\n        fig.savefig(\n            self.output_path.joinpath(\"figures/stations\").joinpath(f\"{station}.png\"),\n            bbox_extra_artists=[lgd],\n            bbox_inches=\"tight\",\n        )\n        plt.close()\n    else:\n        return FigureOutput(fig=fig, axes=ax, legend=lgd)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_compare_discharge_at_stations","title":"<code>figure_compare_discharge_at_stations(stations, title='no_title', savefig=True)</code>","text":"<p>Like <code>Compare1D2D.figure_at_station</code>, but compares discharge distribution over two stations.</p> <p>Example usage: <pre><code>Compare1D2().figure_compare_discharge_at_stations(stations=[\"WL_869.00\", \"PK_869.00\"])\n</code></pre> Figures are saved to <code>[Compare1D2D.output_path]/figures/discharge</code></p> <p>Example output:</p> <p>.. figure:: figures_utils/discharge/example.png</p> <pre><code>Example output figure\n</code></pre> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_compare_discharge_at_stations(\n    self, stations: List[str], title: str = \"no_title\", savefig:bool=True\n) -&gt; FigureOutput | None:\n    \"\"\"\n    Like `Compare1D2D.figure_at_station`, but compares discharge\n    distribution over two stations.\n\n    Example usage:\n    ``` py\n    Compare1D2().figure_compare_discharge_at_stations(stations=[\"WL_869.00\", \"PK_869.00\"])\n    ```\n    Figures are saved to `[Compare1D2D.output_path]/figures/discharge`\n\n    Example output:\n\n    .. figure:: figures_utils/discharge/example.png\n\n        Example output figure\n\n    \"\"\"\n    fig, axs = plt.subplots(2, 1, figsize=(12, 10))\n\n    ax_error = axs[0].twinx()\n    ax_error.set_zorder(\n        axs[0].get_zorder() - 1\n    )  # default zorder is 0 for ax1 and ax2\n\n    if len(stations) != 2:\n        print(\"error: must define 2 stations\")\n\n    linestyles_2d = [\"-\", \"--\"]\n    for j, station in enumerate(stations):\n\n        if station not in self.stations():\n            self.set_logger_message(f\"{station} not known\", 'warning')\n\n        # tijdserie\n        axs[0].plot(\n            self.data_2D_Q[station],\n            label=f\"2D, {station.split('_')[0]}\",\n            linewidth=2,\n            linestyle=linestyles_2d[j],\n        )\n        axs[0].plot(\n            self.data_1D_Q[station],\n            label=f\"1D, {station.split('_')[0]}\",\n            linewidth=2,\n            linestyle=\"-\",\n        )\n\n    ax_error.plot(\n        self._data_1D_Q[station] - self._data_2D_Q[station],\n        \".\",\n        color=\"r\",\n        markersize=5,\n        label=f\"1D-2D\",\n    )\n\n    # discharge distribution\n\n    Q2D = self.data_2D_Q[stations]\n    Q1D = self.data_1D_Q[stations]\n    axs[1].plot(\n        Q2D.sum(axis=1),\n        (Q2D.iloc[:, 0] / Q2D.sum(axis=1)) * 100,\n        linewidth=2,\n        linestyle='--',\n    )\n    axs[1].plot(\n        Q1D.sum(axis=1),\n        (Q1D.iloc[:, 0] / Q1D.sum(axis=1)) * 100,\n        linewidth=2,\n        linestyle=\"-\",\n    )\n    axs[1].plot(\n        Q2D.sum(axis=1),\n        (Q2D.iloc[:, 1] / Q2D.sum(axis=1)) * 100,\n        linewidth=2,\n        linestyle='--',\n    )\n    axs[1].plot(\n        Q1D.sum(axis=1),\n        (Q1D.iloc[:, 1] / Q1D.sum(axis=1)) * 100,\n        linewidth=2,\n        linestyle=\"-\",\n    )\n\n    # style\n    axs[1].set_ylim(0, 100)\n    axs[1].set_title(\"afvoerverdeling\")\n    axs[1].set_ylabel(\"percentage t.o.v. totaal\")\n    axs[1].set_xlabel(\"afvoer bovenstrooms [m$^3$/s]\")\n    axs[0].set_ylabel(\"afvoer [m$^3$/s]\")\n    axs[0].set_title(\"tijdserie\")\n\n    suptitle = plt.suptitle(title.upper())\n\n    # Style figure\n    fig, lgd = PlotStyles.apply(fig=fig, style=self._plotstyle, use_legend=True)\n    self._style_error_axes(ax_error, ylim=[-500, 500], ylabel=\"1D-2D [m$^3$/s]\")\n    fig.tight_layout()\n\n    if savefig:\n        fig.savefig(\n            self.output_path.joinpath(\"figures/discharge\").joinpath(f\"{title}.png\"),\n            bbox_extra_artists=[lgd, suptitle],\n            bbox_inches=\"tight\",\n        )\n        plt.close()\n    else:\n        return FigureOutput(fig=fig, axes=axs, legend=lgd)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_longitudinal","title":"<code>figure_longitudinal(route, stat='time', savefig=True, label='', add_to_fig=None)</code>","text":"<p>Creates a figure along a <code>route</code>. Content of figure depends  on <code>stat</code>. Figures are saved to <code>[Compare1D2D.output_path]/figures/longitudinal</code></p> <p>Example output:</p> <p></p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>List[str]</code> <p>List of branches (e.g. ['NK', 'LK'])</p> required <code>stat</code> <code>str</code> <p>what type of longitudinal plot to make. Options are:  - time - last25 - max13</p> <code>'time'</code> <code>savefig</code> <code>bool</code> <p>if true, figure is saved to png file. If false, <code>FigureOutput</code>       returned, which is input for <code>add_to_fig</code></p> <code>True</code> <code>add_to_fig</code> <code>FigureOutput | None</code> <p>if <code>FigureOutput</code> is provided, adds content to figure.</p> <code>None</code> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_longitudinal(self, \n                        route: List[str], \n                        stat: str = 'time',\n                        savefig: bool=True,\n                        label: str = '',\n                        add_to_fig: FigureOutput | None = None) -&gt; FigureOutput | None:\n    \"\"\"\n    Creates a figure along a `route`. Content of figure depends \n    on `stat`. Figures are saved to `[Compare1D2D.output_path]/figures/longitudinal`\n\n    Example output:\n\n    ![title](../figures/test_results/compare1d2d/BR-PK-IJ.png)\n\n    Parameters:\n        route: List of branches (e.g. ['NK', 'LK'])\n        stat: what type of longitudinal plot to make. Options are: \n            - time\n            - last25\n            - max13\n        savefig: if true, figure is saved to png file. If false, `FigureOutput` \n                 returned, which is input for `add_to_fig`\n        add_to_fig: if `FigureOutput` is provided, adds content to figure.  \n    \"\"\"\n    # Get route and stations along route\n    routename = \"-\".join(route)\n\n    match stat:\n        case 'time':\n            datafunc = self._time_func\n        case \"last25\":\n            datafunc = self._last25\n        case \"max13\":\n            datafunc = self._max13\n\n    # Make configurable in the future\n    labelfunc = self._lmw_func\n\n    # TIME FUNCTION plot line every delta_days days\n    lines = datafunc(route=route)\n\n    # Get figure object\n    if add_to_fig is None:\n        fig, axs = plt.subplots(2, 1, figsize=(12, 12))\n    else:\n        fig = add_to_fig.fig\n        axs = add_to_fig.axes\n\n    # Filtering which stations to plot\n    if add_to_fig is None:\n        station_names, station_locs, _ = self.get_route(route)\n        st_names, st_locs = labelfunc(station_names, station_locs)\n        h1d = self.get_data_along_route(data=self.data_1D_H, route=route)\n        for st_name, st_loc in zip(st_names, st_locs):\n            for ax in axs:\n                ax.axvline(x=st_loc, linestyle=\"--\")\n\n            axs[0].text(\n                st_loc,\n                h1d.min().min(),\n                st_name,\n                fontsize=12,\n                rotation=90,\n                horizontalalignment=\"left\",\n                verticalalignment=\"bottom\",\n            )\n\n    for line in lines:\n\n        axs[0].plot(line.get(\"1D\"), \n                    label=f\"{label} {line.get('label')}\")\n\n        axs[0].set_ylabel(\"Waterstand [m+NAP]\")\n        routestr = \"-\".join(route)\n\n        axs[0].set_title(f\"route: {routestr}\")\n\n        axs[1].plot(line.get(\"1D\") - line.get(\"2D\"))\n        axs[1].set_ylabel(\"Verschil 1D-2D [m]\")\n\n        for ax in axs:\n            ax.set_xlabel(\"Rivierkilometers\")\n            ax.xaxis.set_major_locator(MultipleLocator(20))\n            ax.xaxis.set_minor_locator(MultipleLocator(10))\n\n\n    axs[1].set_ylim(-1, 1)\n    fig, lgd = PlotStyles.apply(fig=fig, style=self._plotstyle, use_legend=True)\n\n    if savefig:\n        plt.tight_layout()\n        fig.savefig(\n            self.output_path.joinpath(f\"figures/longitudinal/{routename}.png\"),\n            bbox_extra_artists=[lgd],\n            bbox_inches=\"tight\",\n        )\n        plt.close()\n\n    else:\n        return FigureOutput(fig=fig, axes = axs, legend=lgd)\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.figure_longitudinal_rating_curve","title":"<code>figure_longitudinal_rating_curve(route)</code>","text":"<p>Create a figure along a route with lines at various dicharges. To to this, rating curves are generated at each point by digitizing the model output.</p> <p>Figures are saved to <code>[Compare1D2D.output_path]/figures/longitudinal</code></p> <p>Example output:</p> <p>.. figure:: figures_utils/longitudinal/example_rating_curve.png</p> <pre><code>example output figure\n</code></pre> Source code in <code>fm2prof\\utils.py</code> <pre><code>def figure_longitudinal_rating_curve(self, route: List[str]) -&gt; None:\n    \"\"\"\n    Create a figure along a route with lines at various dicharges.\n    To to this, rating curves are generated at each point by digitizing\n    the model output.\n\n    Figures are saved to `[Compare1D2D.output_path]/figures/longitudinal`\n\n    Example output:\n\n    .. figure:: figures_utils/longitudinal/example_rating_curve.png\n\n        example output figure\n\n    \"\"\"\n    routename = \"-\".join(route)\n    _, _, lmw_stations = self.get_route(route)\n\n    h1d = self.get_data_along_route(data=self._data_1D_H_digitized, route=route)\n    h2d = self.get_data_along_route(data=self._data_2D_H_digitized, route=route)\n\n    discharge_steps = list(self._iter_discharge_steps(h1d.T, n=8))\n    if len(discharge_steps) &lt; 1:\n        self.set_logger_message(\"There is too little data to plot a QH relationship\", 'error')\n        return \n\n    # Plot LMW station locations\n    fig, axs = plt.subplots(2, 1, figsize=(12, 10))\n    prevloc = -9999\n    for lmw in lmw_stations:\n        if lmw is None:\n            continue\n        newloc = max(lmw[1], prevloc + 3)\n        prevloc = lmw[1]\n        for ax in axs:\n            ax.axvline(x=lmw[1], linestyle=\"--\", color=\"#7a8ca0\")\n        axs[0].text(\n            newloc,\n            h1d[discharge_steps[0]].min(),\n            lmw[0],\n            fontsize=12,\n            rotation=90,\n            horizontalalignment=\"right\",\n            verticalalignment=\"bottom\",\n        )\n\n    # Plot betrekkingslijnen\n    texty_previous = -999\n    for discharge in discharge_steps:\n        axs[0].plot(h1d[discharge], label=f\"{discharge:.0f} m$^3$/s\")\n        axs[0].set_ylabel(\"waterstand [m+nap]\")\n        routestr = \"-\".join(route)\n\n        axs[0].set_title(f\"Betrekkingslijnen\\n{routestr}\")\n\n        axs[1].plot(h1d[discharge] - h2d[discharge])\n        axs[1].set_ylabel(\"Verschil 1D-2D [m]\")\n\n        for ax in axs:\n            ax.set_xlabel(\"rivierkilometers\")\n            ax.xaxis.set_major_locator(MultipleLocator(20))\n            ax.xaxis.set_minor_locator(MultipleLocator(10))\n\n    # style figure\n    axs[1].set_ylim(-1, 1)\n    fig, lgd = PlotStyles.apply(fig,style=self._plotstyle, use_legend=True)\n    plt.tight_layout()\n    fig.savefig(\n        self.output_path.joinpath(\n            f\"figures/longitudinal/{routename}_rating_curve.png\",\n        ),\n        bbox_extra_artists=[lgd],\n        bbox_inches=\"tight\",\n    )\n    plt.close()\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.get_route","title":"<code>get_route(route)</code>","text":"<p>returns a sorted list of stations along a route, with rkms</p> Source code in <code>fm2prof\\utils.py</code> <pre><code>def get_route(\n    self, route: List[str]\n) -&gt; Tuple[List[str], List[float], List[Tuple[str, float]]]:\n    \"\"\"returns a sorted list of stations along a route, with rkms\"\"\"\n    station_names = self._data_2D_H.columns\n\n    # Parse names\n    rkms = self._names_to_rkms(station_names)\n    branches = self._names_to_branches(station_names)\n\n    # select along route\n    routekms = list()\n    stations = list()\n    lmw_stations = list()\n\n    for stop in route:\n        indices = [i for i, b in enumerate(branches) if b == stop]\n        routekms.extend([rkms[i] for i in indices])\n        stations.extend([station_names[i] for i in indices])\n        lmw_stations.extend(\n            [\n                (station_names[i], rkms[i])\n                for i in indices\n                if \"LMW\" in station_names[i]\n            ]\n        )\n\n    # sort data\n    sorted_indices = np.argsort(routekms)\n    sorted_stations = [stations[i] for i in sorted_indices if routekms[i] is not np.nan]\n    sorted_rkms = [routekms[i] for i in sorted_indices if routekms[i] is not np.nan]\n\n    # sort lmw stations\n    lmw_stations = [\n        lmw_stations[j] for j in np.argsort([i[1] for i in lmw_stations])\n    ]\n    return sorted_stations, sorted_rkms, lmw_stations\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.heatmap_rating_curve","title":"<code>heatmap_rating_curve(route)</code>","text":"<p>Create a 2D heatmap along a route. The horizontal axis uses the digitized rating curves to match the two models</p> <p>Figures are saved to <code>[Compare1D2D.output_path]/figures/heatmap</code></p> <p>Example output:</p> <p>.. figure:: figures_utils/heatmaps/example_rating_curve.png</p> <pre><code>example output figure\n</code></pre> Source code in <code>fm2prof\\utils.py</code> <pre><code>def heatmap_rating_curve(self, route: List[str]) -&gt; None:\n    \"\"\"\n    Create a 2D heatmap along a route. The horizontal axis uses\n    the digitized rating curves to match the two models\n\n    Figures are saved to `[Compare1D2D.output_path]/figures/heatmap`\n\n    Example output:\n\n    .. figure:: figures_utils/heatmaps/example_rating_curve.png\n\n        example output figure\n\n    \"\"\"\n\n    routename = \"-\".join(route)\n    _, _, lmw_stations = self.get_route(route)\n    data = self._data_1D_H_digitized - self._data_2D_H_digitized\n\n    routedata = self.get_data_along_route(data.dropna(how=\"all\"), route)\n\n    fig, ax = plt.subplots(1, figsize=(12, 7))\n    im = ax.pcolormesh(\n        routedata.columns,\n        routedata.index,\n        routedata,\n        cmap=\"Spectral_r\",\n        vmin=-1,\n        vmax=1,\n    )\n    for lmw in lmw_stations:\n        if lmw is None:\n            continue\n        ax.plot(\n            routedata.columns, [lmw[1]] * len(routedata.columns), \"--k\", linewidth=1\n        )\n        ax.text(routedata.columns[0], lmw[1], lmw[0], fontsize=12)\n\n    ax.set_ylabel(\"rivierkilometer\")\n    ax.set_title(f\"{routename}\\nheatmap Verschillen in waterstand 1D-2D\")\n\n    cb = fig.colorbar(im, ax=ax)\n    cb.set_label(\"waterstandsverschil [m+nap]\".upper(), rotation=270, labelpad=15)\n    PlotStyles.apply(fig, style=self._plotstyle, use_legend=False)\n    fig.tight_layout()\n    fig.savefig(\n        self.output_path.joinpath(f\"figures/heatmaps/{routename}_rating_curve.png\")\n    )\n    plt.close()\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.heatmap_time","title":"<code>heatmap_time(route)</code>","text":"<p>Create a 2D heatmap along a route. The horizontal axis uses timemarks to match the 1D and 2D models</p> <p>Figures are saved to <code>[Compare1D2D.output_path]/figures/heatmap</code></p> <p>Example output:</p> <p>.. figure:: figures_utils/heatmaps/example_time_series.png</p> <pre><code>example output figure\n</code></pre> Source code in <code>fm2prof\\utils.py</code> <pre><code>def heatmap_time(self, route: List[str]) -&gt; None:\n    \"\"\"\n    Create a 2D heatmap along a route. The horizontal axis uses\n    timemarks to match the 1D and 2D models\n\n    Figures are saved to `[Compare1D2D.output_path]/figures/heatmap`\n\n    Example output:\n\n    .. figure:: figures_utils/heatmaps/example_time_series.png\n\n        example output figure\n\n    \"\"\"\n\n    routename = \"-\".join(route)\n    _, _, lmw_stations = self.get_route(route)\n    data = self._data_1D_H - self._data_2D_H\n    routedata = self.get_data_along_route(data.dropna(how=\"all\"), route)\n\n    fig, ax = plt.subplots(1, figsize=(12, 7))\n    im = ax.pcolormesh(\n        routedata.columns,\n        routedata.index,\n        routedata,\n        cmap=\"Spectral_r\",\n        vmin=-1,\n        vmax=1,\n    )\n    for lmw in lmw_stations:\n        if lmw is None:\n            continue\n        ax.plot(\n            routedata.columns, [lmw[1]] * len(routedata.columns), \"--k\", linewidth=1\n        )\n        ax.text(routedata.columns[0], lmw[1], lmw[0], fontsize=12)\n\n    ax.set_ylabel(\"rivierkilometer\")\n    ax.set_title(f\"{routename}\\nheatmap Verschillen in waterstand 1D-2D\")\n\n    cb = fig.colorbar(im, ax=ax)\n    cb.set_label(\"waterstandsverschil [m+nap]\".upper(), rotation=270, labelpad=15)\n    PlotStyles.apply(fig, style=self._plotstyle, use_legend=False)\n    fig.tight_layout()\n    fig.savefig(\n        self.output_path.joinpath(f\"figures/heatmaps/{routename}_timeseries.png\")\n    )\n    plt.close()\n</code></pre>"},{"location":"markdown/utils/#fm2prof.utils.Compare1D2D.statistics_to_file","title":"<code>statistics_to_file(file_path='error_statistics')</code>","text":"<p>Creates and output a file `error_statistics.csv', which is a comma-seperated file with the following columns:</p> <p>,bias,rkm,branch,is_lmw,std,mae</p> <p>with for each station:</p> <ul> <li>bias = bias, mean error</li> <li>rkm = river kilometer of the station</li> <li>branch = name of 1D branch on which the station lies</li> <li>is_lmw = if \"LMW\" is in the name of station, True. </li> <li>std = standard deviation of the rror</li> <li>mae = mean absolute error of the error</li> </ul> Source code in <code>fm2prof\\utils.py</code> <pre><code>def statistics_to_file(self, file_path: str = \"error_statistics\") -&gt; None:\n    \"\"\"\n    Creates and output a file `error_statistics.csv', which is a\n    comma-seperated file with the following columns:\n\n    ,bias,rkm,branch,is_lmw,std,mae\n\n    with for each station:\n\n    - bias = bias, mean error\n    - rkm = river kilometer of the station\n    - branch = name of 1D branch on which the station lies\n    - is_lmw = if \"LMW\" is in the name of station, True. \n    - std = standard deviation of the rror\n    - mae = mean absolute error of the error\n\n    \"\"\"\n\n    if self.statistics == None:\n        self.statistics = self._compute_statistics()\n\n    statfile = self.output_path.joinpath(file_path).with_suffix(\".csv\")\n    sumfile = self.output_path.joinpath(file_path + \"_summary\").with_suffix(\".csv\")\n\n    if self.statistics is None:\n        return\n\n    # all statistics\n    self.statistics.to_csv(statfile)\n    self.set_logger_message(f\"statistics written to {statfile}\")\n\n    # summary of statistics\n    s = self.statistics\n    with open(sumfile, \"w\") as f:\n        for branch in s.branch.unique():\n            bbias = s.bias[s.branch == branch].mean()\n            bstd = s[\"std\"][s.branch == branch].mean()\n            lmw_bias = s.bias[(s.branch == branch) &amp; s.is_lmw].mean()\n            lmw_std = s[\"std\"][(s.branch == branch) &amp; s.is_lmw].mean()\n            f.write(\n                f\"{branch},{bbias:.2f}\u00b1({bstd:.2f}), {lmw_bias:.2f}\u00b1({lmw_std:.2f})\\n\"\n            )\n</code></pre>"},{"location":"notebooks/VisualiseOutput/","title":"VisualiseOutput","text":"In\u00a0[1]: Copied! <pre>from fm2prof import Project\nfrom fm2prof.utils import VisualiseOutput\n\n# Initialize the project\nproject = Project(r\"../../tests/test_data/cases/case_02_compound/fm2prof_config.ini\")\n\n# The VisualiseOutput class imports all FM2PROF output files\nvis = VisualiseOutput(\n            project.get_output_directory(), logger=project.get_logger()\n        )\n\n# To loop over all cross-sections, use the following generator\ncross_sections = list(vis.cross_sections)\n\n# To print the z-values of the first cross-section:\nprint(cross_sections[0].get('levels'))\n</pre> from fm2prof import Project from fm2prof.utils import VisualiseOutput  # Initialize the project project = Project(r\"../../tests/test_data/cases/case_02_compound/fm2prof_config.ini\")  # The VisualiseOutput class imports all FM2PROF output files vis = VisualiseOutput(             project.get_output_directory(), logger=project.get_logger()         )  # To loop over all cross-sections, use the following generator cross_sections = list(vis.cross_sections)  # To print the z-values of the first cross-section: print(cross_sections[0].get('levels'))   <pre>\u2554\u2550\u2550\u2550\u2550\u2550\u2563 2024-05-07 21:03 Starting new task: Loading configuration file\n\u2551     DEBUG  T+ 0.01s Received ini file: ..\\..\\tests\\test_data\\cases\\case_02_compound\\fm2prof_config.ini\n\u2551   WARNING  T+ 0.05s Could not find optional input file for RegionPolygonFile, skipping\n\u2551   WARNING  T+ 0.07s Could not find optional input file for SectionPolygonFile, skipping\n\u2551   WARNING  T+ 0.12s exportmapfiles is not a known key\n\u2551     ERROR  T+ 0.13s Unexpected error reading (debug) parameters. Check config file\n\u255a\u2550\u2550\u2550\u2550\u2550\u2563 Task finished in 0.15sec\n================================================================================\nFM2PROF version 2.3.2\nDocumentation: https://deltares.github.io/Fm2Prof/\nAuthors: Koen Berends, Asako Fujisaki, Carles Soriano Perez, Ilia Awakimjan\nContact: koen.berends@deltares.nl\nLicense:   LPGL license. For more info see LICENSE.txt\nCopyright 2016-2020, University of Twente &amp; Deltares\n================================================================================\n\n[input]\n2DMapOutput                   = ..\\..\\tests\\test_data\\cases\\case_02_compound\\Data\\2DModelOutput\\FlowFM_map.nc# Output file from FM2D model (.net file)\nCrossSectionLocationFile      = ..\\..\\tests\\test_data\\cases\\case_02_compound\\Data\\cross_section_locations.xyz# .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\nRegionPolygonFile             =           # User defined polygons in json format\nSectionPolygonFile            =           # User defined polygons in json format\n\n[parameters]\nCaseName                      =           # Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used\nMaximumPointsInProfile        = 20        # Number of points which are used to generate cross-sections\nConveyanceDetectionMethod     = 1         # [0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)\nAbsoluteVelocityThreshold     = 0.01      # Absolute velocity threshold in m/s. Used to determine storage\nRelativeVelocityThreshold     = 0.03      # Relative velocity threshold (percentage). Used to determine storage\nMinimumDepthThreshold         = 0.02      # Minimum depth (m) for storage identification\nBedlevelCriterium             = 0.05      # Ignore the lowest percentage of bed level points\nLakeTimesteps                 = 10        # Number of timesteps that are used for identifying lakes\nExtrapolateStorage            = True      # Add storage to water level independent cross-section section\nSDCorrection                  = True      # Use summerdike volume correction\nSDFloodplainBase              = 0.5       # minimum distance between floodplain base level and crest level in meters\nSDTransitionHeight            = 0.5       # Transition height at the summer dike (m)\nSDOptimisationMethod          = 0         # [0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both\nFrictionWeighingMethod        = 0         # Options. [0] arithmetric mean, [1] Weighted average\nSkipMaps                      = 0         # number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. \nClassificationMethod          = 0         # How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell\nMinimumTotalWidth             = 0.5       # Minimum width in meters. Zero width may lead to numerical instability in 1D solvers\n\n[debug]\nExportCSSData                 = False     # If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.\nExportMapFiles                = False     # Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.\nCssSelection                  =           # provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections\n\n[output]\nOutputDirectory               = output    # Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory\n\n\n\u2551      INFO  T+ 0.28s Using ..\\..\\tests\\test_data\\cases\\case_02_compound\\output\\figures as output directory for figures\n</pre> <pre>[-2.025, -2.015, -1.9486, -1.9055, -1.8261, -1.7498, -1.6281, -1.5567, -1.4315, -1.3622, -0.571, -0.0747, -0.0391, -0.0216, -0.0049, 0.0695, 0.4215, 0.835, 1.243, 1.7807]\n</pre> <p>To visualise the first cross-section:</p> In\u00a0[3]: Copied! <pre># Plot the first cross-section\nvis.figure_cross_section(cross_sections[0], save_to_file=False, overwrite=True)\n\n# You can loop over the generator to create figures in a bunch:\n#for css in vis.cross_sections:\n#    vis.figure_cross_section(css)\n</pre> # Plot the first cross-section vis.figure_cross_section(cross_sections[0], save_to_file=False, overwrite=True)  # You can loop over the generator to create figures in a bunch: #for css in vis.cross_sections: #    vis.figure_cross_section(css) Out[3]: In\u00a0[4]: Copied! <pre>vis.figure_roughness_longitudinal(branch=\"channel1\")\n</pre> vis.figure_roughness_longitudinal(branch=\"channel1\")"},{"location":"notebooks/VisualiseOutput/#visualiseoutput","title":"VisualiseOutput\u00b6","text":"<p>This notebook show examples of how to use the <code>VisualiseOutput</code> utility. This utility is used to visualise <code>fm2prof</code> output, such as generated cross-sections and roughness fields.</p>"},{"location":"notebooks/VisualiseOutput/#cross-sections","title":"Cross-sections\u00b6","text":""},{"location":"notebooks/VisualiseOutput/#plot-roughness","title":"Plot roughness\u00b6","text":"<p>To plot roughness along a branch:</p>"},{"location":"notebooks/compare1d2d/","title":"Compare 1D and 2D model output","text":"In\u00a0[1]: Copied! <pre>from fm2prof import Project, utils\n\nproject = Project(fr'../../tests/test_data/compare1d2d/cases/case1/fm2prof.ini');\n\n# To convert model output to csv files, initialise like this:\n\"\"\"\nplotter = utils.Compare1D2D(project=project, \n                           path_1d='../path/to/dir/that/contains/dimr.xml',\n                           path_2d='../path/to/his/netcdf/file' )  \n\"\"\"\n\n# The minimal information you need to provide is an fm2prof config file. \nplotter = utils.Compare1D2D(project=project)\n</pre> from fm2prof import Project, utils  project = Project(fr'../../tests/test_data/compare1d2d/cases/case1/fm2prof.ini');  # To convert model output to csv files, initialise like this: \"\"\" plotter = utils.Compare1D2D(project=project,                             path_1d='../path/to/dir/that/contains/dimr.xml',                            path_2d='../path/to/his/netcdf/file' )   \"\"\"  # The minimal information you need to provide is an fm2prof config file.  plotter = utils.Compare1D2D(project=project) <pre>\u2554\u2550\u2550\u2550\u2550\u2550\u2563 2024-05-07 15:41 Starting new task: Loading configuration file\n\u2551     DEBUG  T+ 0.01s Received ini file: ..\\..\\tests\\test_data\\compare1d2d\\cases\\case1\\fm2prof.ini\n\u2551     ERROR  T+ 0.03s Could not find input file: 2DMapOutput\n\u2551     ERROR  T+ 0.06s Unexpected error reading input files. Check config file\n\u2551   WARNING  T+ 0.11s exportmapfiles is not a known key\n\u2551     ERROR  T+ 0.11s Unexpected error reading (debug) parameters. Check config file\n\u255a\u2550\u2550\u2550\u2550\u2550\u2563 Task finished in 0.13sec\n================================================================================\nFM2PROF version 2.3.2\nDocumentation: https://deltares.github.io/Fm2Prof/\nAuthors: Koen Berends, Asako Fujisaki, Carles Soriano Perez, Ilia Awakimjan\nContact: koen.berends@deltares.nl\nLicense:   LPGL license. For more info see LICENSE.txt\nCopyright 2016-2020, University of Twente &amp; Deltares\n================================================================================\n\n[input]\n2DMapOutput                   =           # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\nRegionPolygonFile             =           # User defined polygons in json format\nSectionPolygonFile            =           # User defined polygons in json format\n\n[parameters]\nCaseName                      =           # Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used\nMaximumPointsInProfile        = 20        # Number of points which are used to generate cross-sections\nConveyanceDetectionMethod     = 1         # [0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)\nAbsoluteVelocityThreshold     = 0.01      # Absolute velocity threshold in m/s. Used to determine storage\nRelativeVelocityThreshold     = 0.03      # Relative velocity threshold (percentage). Used to determine storage\nMinimumDepthThreshold         = 0.02      # Minimum depth (m) for storage identification\nBedlevelCriterium             = 0.05      # Ignore the lowest percentage of bed level points\nLakeTimesteps                 = 10        # Number of timesteps that are used for identifying lakes\nExtrapolateStorage            = True      # Add storage to water level independent cross-section section\nSDCorrection                  = True      # Use summerdike volume correction\nSDFloodplainBase              = 0.5       # minimum distance between floodplain base level and crest level in meters\nSDTransitionHeight            = 0.5       # Transition height at the summer dike (m)\nSDOptimisationMethod          = 0         # [0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both\nFrictionWeighingMethod        = 0         # Options. [0] arithmetric mean, [1] Weighted average\nSkipMaps                      = 0         # number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. \nClassificationMethod          = 0         # How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell\nMinimumTotalWidth             = 0.5       # Minimum width in meters. Zero width may lead to numerical instability in 1D solvers\n\n[debug]\nExportCSSData                 = False     # If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.\nExportMapFiles                = False     # Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.\nCssSelection                  =           # provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections\n\n[output]\nOutputDirectory               = output    # Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory\n\n\n\u2551     DEBUG  T+ 0.21s 1D netCDF file does not exist or is not provided. Input provided: None.\n\u2551     DEBUG  T+ 0.23s 2D netCDF file does not exist or is not provided. Input provided: None.\n\u2551      INFO  T+ 0.86s Using existing flow1d csv files\n\u2551      INFO  T+ 0.87s using existing 1d-2d map\n\u2551      INFO  T+ 1.23s Using existing flow2d csv files\n\u2551      INFO  T+ 1.24s Using existing digitized file for 1d\n\u2551      INFO  T+ 1.27s Using existing digitized file for 2d\n</pre> In\u00a0[2]: Copied! <pre>plotter.figure_longitudinal(route=[\"BR\", \"WL\"], savefig=False)\n</pre> plotter.figure_longitudinal(route=[\"BR\", \"WL\"], savefig=False) <pre>\u2551   WARNING  T+ 1.62s skipped labelling BR_863.9_R_LMW-H_Lobith-haven because too close to previous station\n</pre> Out[2]: <pre>FigureOutput(fig=&lt;Figure size 1200x1200 with 2 Axes&gt;, axes=array([&lt;Axes: title={'center': 'route: BR-WL'}, xlabel='Rivierkilometers', ylabel='Waterstand [m+NAP]'&gt;,\n       &lt;Axes: xlabel='Rivierkilometers', ylabel='Verschil 1D-2D [m]'&gt;],\n      dtype=object), legend=&lt;matplotlib.legend.Legend object at 0x000002A235E22B90&gt;)</pre> <p>These results show that the first shown time is not really initialised very well. In fact, for this simulations it makes sense to start showing results only from January 1st. We can do this by giving the plotter a start time:</p> In\u00a0[3]: Copied! <pre>from datetime import datetime\n\nplotter.start_time = datetime(year=2000, month=1, day=5)\nplotter.figure_longitudinal(route=[\"BR\", \"WL\"], savefig=False)\n</pre> from datetime import datetime  plotter.start_time = datetime(year=2000, month=1, day=5) plotter.figure_longitudinal(route=[\"BR\", \"WL\"], savefig=False) <pre>\u2551   WARNING  T+ 2.93s skipped labelling BR_863.9_R_LMW-H_Lobith-haven because too close to previous station\n</pre> Out[3]: <pre>FigureOutput(fig=&lt;Figure size 1200x1200 with 2 Axes&gt;, axes=array([&lt;Axes: title={'center': 'route: BR-WL'}, xlabel='Rivierkilometers', ylabel='Waterstand [m+NAP]'&gt;,\n       &lt;Axes: xlabel='Rivierkilometers', ylabel='Verschil 1D-2D [m]'&gt;],\n      dtype=object), legend=&lt;matplotlib.legend.Legend object at 0x000002A235D9A310&gt;)</pre> In\u00a0[4]: Copied! <pre># Loading output from two sources\nproject = Project(fr'../../tests/test_data/compare1d2d/cases/case1/fm2prof.ini')\nproject2 = Project(fr'../../tests/test_data/compare1d2d/cases/case2/fm2prof.ini')\n\nplotter = utils.Compare1D2D(project=project,\n                            start_time=datetime(year=2000, month=1, day=5))\nplotter2 = utils.Compare1D2D(project=project2,\n                            start_time=datetime(year=2000, month=1, day=5))\n\n# Where setting savefig to False to get the Figure outptu\nFigure = plotter.figure_longitudinal(route=['BR', \"PK\", \"IJ\"], \n                                     stat=\"last25\", \n                                     label = \"D8000\",\n                                     savefig=False)\n\n# The second potter takes the `FigureOutput` from the first plotter as argument for the `add_to_fig` parameter. \nplotter2.figure_longitudinal(route=['BR', \"PK\", \"IJ\"], \n                             stat=\"last25\", \n                             label = \"D16000\",\n                             savefig=False,\n                             add_to_fig=Figure)\n</pre> # Loading output from two sources project = Project(fr'../../tests/test_data/compare1d2d/cases/case1/fm2prof.ini') project2 = Project(fr'../../tests/test_data/compare1d2d/cases/case2/fm2prof.ini')  plotter = utils.Compare1D2D(project=project,                             start_time=datetime(year=2000, month=1, day=5)) plotter2 = utils.Compare1D2D(project=project2,                             start_time=datetime(year=2000, month=1, day=5))  # Where setting savefig to False to get the Figure outptu Figure = plotter.figure_longitudinal(route=['BR', \"PK\", \"IJ\"],                                       stat=\"last25\",                                       label = \"D8000\",                                      savefig=False)  # The second potter takes the `FigureOutput` from the first plotter as argument for the `add_to_fig` parameter.  plotter2.figure_longitudinal(route=['BR', \"PK\", \"IJ\"],                               stat=\"last25\",                               label = \"D16000\",                              savefig=False,                              add_to_fig=Figure) <pre>\u2551      INFO  T+ 3.99s Starting new task: Loading configuration file\n\u2551     DEBUG  T+ 4.01s Received ini file: ..\\..\\tests\\test_data\\compare1d2d\\cases\\case1\\fm2prof.ini\n\u2551     ERROR  T+ 4.03s Could not find input file: 2DMapOutput\n\u2551     ERROR  T+ 4.04s Unexpected error reading input files. Check config file\n\u2551   WARNING  T+ 4.11s exportmapfiles is not a known key\n\u2551     ERROR  T+ 4.11s Unexpected error reading (debug) parameters. Check config file\n\u2551      INFO  T+ 4.13s \n\u2551      INFO  T+ 4.15s ================================================================================\n\u2551      INFO  T+ 4.16s FM2PROF version 2.3.2\n\u2551      INFO  T+ 4.18s Documentation: https://deltares.github.io/Fm2Prof/\n\u2551      INFO  T+ 4.20s Authors: Koen Berends, Asako Fujisaki, Carles Soriano Perez, Ilia Awakimjan\n\u2551      INFO  T+ 4.21s Contact: koen.berends@deltares.nl\n\u2551      INFO  T+ 4.23s License:   LPGL license. For more info see LICENSE.txt\n\u2551      INFO  T+ 4.23s Copyright 2016-2020, University of Twente &amp; Deltares\n\u2551      INFO  T+ 4.25s ================================================================================\n\u2551      INFO  T+ 4.26s \n\u2551      INFO  T+ 4.27s [input]\n2DMapOutput                   =           # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\nRegionPolygonFile             =           # User defined polygons in json format\nSectionPolygonFile            =           # User defined polygons in json format\n\n[parameters]\nCaseName                      =           # Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used\nMaximumPointsInProfile        = 20        # Number of points which are used to generate cross-sections\nConveyanceDetectionMethod     = 1         # [0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)\nAbsoluteVelocityThreshold     = 0.01      # Absolute velocity threshold in m/s. Used to determine storage\nRelativeVelocityThreshold     = 0.03      # Relative velocity threshold (percentage). Used to determine storage\nMinimumDepthThreshold         = 0.02      # Minimum depth (m) for storage identification\nBedlevelCriterium             = 0.05      # Ignore the lowest percentage of bed level points\nLakeTimesteps                 = 10        # Number of timesteps that are used for identifying lakes\nExtrapolateStorage            = True      # Add storage to water level independent cross-section section\nSDCorrection                  = True      # Use summerdike volume correction\nSDFloodplainBase              = 0.5       # minimum distance between floodplain base level and crest level in meters\nSDTransitionHeight            = 0.5       # Transition height at the summer dike (m)\nSDOptimisationMethod          = 0         # [0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both\nFrictionWeighingMethod        = 0         # Options. [0] arithmetric mean, [1] Weighted average\nSkipMaps                      = 0         # number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. \nClassificationMethod          = 0         # How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell\nMinimumTotalWidth             = 0.5       # Minimum width in meters. Zero width may lead to numerical instability in 1D solvers\n\n[debug]\nExportCSSData                 = False     # If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.\nExportMapFiles                = False     # Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.\nCssSelection                  =           # provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections\n\n[output]\nOutputDirectory               = output    # Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory\n\n\n\u2551      INFO  T+ 4.28s Starting new task: Loading configuration file\n\u2551     DEBUG  T+ 4.30s Received ini file: ..\\..\\tests\\test_data\\compare1d2d\\cases\\case2\\fm2prof.ini\n\u2551     ERROR  T+ 4.31s Could not find input file: 2DMapOutput\n\u2551     ERROR  T+ 4.33s Unexpected error reading input files. Check config file\n\u2551   WARNING  T+ 4.36s exportmapfiles is not a known key\n\u2551     ERROR  T+ 4.38s Unexpected error reading (debug) parameters. Check config file\n\u2551      INFO  T+ 4.38s \n\u2551      INFO  T+ 4.39s ================================================================================\n\u2551      INFO  T+ 4.40s FM2PROF version 2.3.2\n\u2551      INFO  T+ 4.41s Documentation: https://deltares.github.io/Fm2Prof/\n\u2551      INFO  T+ 4.42s Authors: Koen Berends, Asako Fujisaki, Carles Soriano Perez, Ilia Awakimjan\n\u2551      INFO  T+ 4.42s Contact: koen.berends@deltares.nl\n\u2551      INFO  T+ 4.43s License:   LPGL license. For more info see LICENSE.txt\n\u2551      INFO  T+ 4.44s Copyright 2016-2020, University of Twente &amp; Deltares\n\u2551      INFO  T+ 4.45s ================================================================================\n\u2551      INFO  T+ 4.46s \n\u2551      INFO  T+ 4.47s [input]\n2DMapOutput                   =           # Output file from FM2D model (.net file)\nCrossSectionLocationFile      =           # .csv or .txt file (, as delimiter) that contains four columns: X_coordinate,Y_coordinate,BranchName,Length,Chainage.\nRegionPolygonFile             =           # User defined polygons in json format\nSectionPolygonFile            =           # User defined polygons in json format\n\n[parameters]\nCaseName                      =           # Subdirectory name under OutputDir (no space); if not specified, 'CaseXX' (01, 02..) are used\nMaximumPointsInProfile        = 20        # Number of points which are used to generate cross-sections\nConveyanceDetectionMethod     = 1         # [0] method based on mean flow velocity, [1] method based on maximum flow velocity (default)\nAbsoluteVelocityThreshold     = 0.01      # Absolute velocity threshold in m/s. Used to determine storage\nRelativeVelocityThreshold     = 0.03      # Relative velocity threshold (percentage). Used to determine storage\nMinimumDepthThreshold         = 0.02      # Minimum depth (m) for storage identification\nBedlevelCriterium             = 0.05      # Ignore the lowest percentage of bed level points\nLakeTimesteps                 = 10        # Number of timesteps that are used for identifying lakes\nExtrapolateStorage            = True      # Add storage to water level independent cross-section section\nSDCorrection                  = True      # Use summerdike volume correction\nSDFloodplainBase              = 0.5       # minimum distance between floodplain base level and crest level in meters\nSDTransitionHeight            = 0.5       # Transition height at the summer dike (m)\nSDOptimisationMethod          = 0         # [0] Optimise on Total volume, [1] optimise  on flow volume, [2] optimise on both\nFrictionWeighingMethod        = 0         # Options. [0] arithmetric mean, [1] Weighted average\nSkipMaps                      = 0         # number of timesteps to skip at begin of 2D output. Use to skip problems related to initial conditions. \nClassificationMethod          = 0         # How to classify 2D output using Section and Region polygons. Options: [0] Do not classify regions or sections. [1] Use DeltaShell\nMinimumTotalWidth             = 0.5       # Minimum width in meters. Zero width may lead to numerical instability in 1D solvers\n\n[debug]\nExportCSSData                 = False     # If True, exports pickled (1) input data for cross-section object, (2) flow mask for conveyance/storage.\nExportMapFiles                = False     # Export detailed map output. Only use for small models or limited number of cross-sections b/c output can be huge.\nCssSelection                  =           # provide comma separated list of ints; e.g. 38, 39, 40. Leave empty to generate all cross-sections\n\n[output]\nOutputDirectory               = output    # Output files are saved in OutputDir/CaseName; if not specified, subdirectory is created in the current directory\n\n\n\u2551     DEBUG  T+ 4.48s 1D netCDF file does not exist or is not provided. Input provided: None.\n\u2551     DEBUG  T+ 4.49s 2D netCDF file does not exist or is not provided. Input provided: None.\n\u2551      INFO  T+ 5.07s Using existing flow1d csv files\n\u2551      INFO  T+ 5.08s using existing 1d-2d map\n\u2551      INFO  T+ 5.40s Using existing flow2d csv files\n\u2551      INFO  T+ 5.40s Using existing digitized file for 1d\n\u2551      INFO  T+ 5.43s Using existing digitized file for 2d\n\u2551     DEBUG  T+ 5.48s 1D netCDF file does not exist or is not provided. Input provided: None.\n\u2551     DEBUG  T+ 5.48s 2D netCDF file does not exist or is not provided. Input provided: None.\n\u2551      INFO  T+ 5.88s Using existing flow1d csv files\n\u2551      INFO  T+ 5.88s using existing 1d-2d map\n\u2551      INFO  T+ 6.17s Using existing flow2d csv files\n\u2551      INFO  T+ 6.18s Using existing digitized file for 1d\n\u2551      INFO  T+ 6.21s Using existing digitized file for 2d\n\u2551   WARNING  T+ 6.65s skipped labelling BR_863.9_R_LMW-H_Lobith-haven because too close to previous station\n\u2551   WARNING  T+ 6.65s skipped labelling PK_871.8_L_LMW-H_Pannerden because too close to previous station\n\u2551   WARNING  T+ 6.66s skipped labelling PK_878.5_R_LMW-H_IJsselkop because too close to previous station\n\u2551   WARNING  T+ 6.67s skipped labelling IJ_879.6_R_LMW-H_Hondsbroeksche-Pleij-IJssel because too close to previous station\n\u2551   WARNING  T+ 6.67s skipped labelling IJ_881.1_R_LMW-H_Westervoort-IJsseldijkerwaard because too close to previous station\n\u2551   WARNING  T+ 6.68s skipped labelling IJ_931.2_R_LMW-H_Eefde-beneden because too close to previous station\n</pre> Out[4]: <pre>FigureOutput(fig=&lt;Figure size 1200x1200 with 2 Axes&gt;, axes=array([&lt;Axes: title={'center': 'route: BR-PK-IJ'}, xlabel='Rivierkilometers', ylabel='Waterstand [m+NAP]'&gt;,\n       &lt;Axes: xlabel='Rivierkilometers', ylabel='Verschil 1D-2D [m]'&gt;],\n      dtype=object), legend=&lt;matplotlib.legend.Legend object at 0x000002A235EE17D0&gt;)</pre> In\u00a0[5]: Copied! <pre>plotter.figure_at_station(\"WL_900.00\", savefig=False)\n</pre> plotter.figure_at_station(\"WL_900.00\", savefig=False) Out[5]: <pre>FigureOutput(fig=&lt;Figure size 1200x500 with 2 Axes&gt;, axes=&lt;Axes: title={'center': 'WL_900.00\\nTijdreeks'}, ylabel='Waterstand [m+NAP]'&gt;, legend=&lt;matplotlib.legend.Legend object at 0x000002A235789390&gt;)</pre> <p>If you are not sure what stations are available, use the <code>stations</code> method to list all stations. The code below returns all stations that contain the abbreviation \"WL\"</p> In\u00a0[6]: Copied! <pre>[station for station in plotter.stations() if \"WL\" in station]\n</pre> [station for station in plotter.stations() if \"WL\" in station] Out[6]: <pre>['WL_914.00',\n 'WL_915.00',\n 'WL_916.00',\n 'WL_917.00',\n 'WL_918.00',\n 'WL_919.00',\n 'WL_920.00',\n 'WL_921.00',\n 'WL_922.00',\n 'WL_923.00',\n 'WL_924.00',\n 'WL_925.00',\n 'WL_926.00',\n 'WL_927.00',\n 'WL_928.00',\n 'WL_929.00',\n 'WL_930.00',\n 'WL_931.00',\n 'WL_932.00',\n 'WL_933.00',\n 'WL_934.00',\n 'WL_935.00',\n 'WL_936.00',\n 'WL_937.00',\n 'WL_938.00',\n 'WL_939.00',\n 'WL_940.00',\n 'WL_941.00',\n 'WL_942.00',\n 'WL_943.00',\n 'WL_944.00',\n 'WL_945.00',\n 'WL_946.00',\n 'WL_947.00',\n 'WL_948.00',\n 'WL_949.00',\n 'WL_950.00',\n 'WL_951.00',\n 'WL_952.00',\n 'WL_926.1_L_LMW-H_Sint-Andries-Waal-g6',\n 'WL_934.8_L_LMW-H_Zaltbommel',\n 'WL_951.8_R_LMW-H_Vuren',\n 'WL_867.00',\n 'WL_913.3_R_LMW-H_Tiel-Waal',\n 'WL_868.00',\n 'WL_869.00',\n 'WL_870.00',\n 'WL_871.00',\n 'WL_872.00',\n 'WL_873.00',\n 'WL_874.00',\n 'WL_875.00',\n 'WL_876.00',\n 'WL_877.00',\n 'WL_878.00',\n 'WL_879.00',\n 'WL_880.00',\n 'WL_881.00',\n 'WL_882.00',\n 'WL_883.00',\n 'WL_884.00',\n 'WL_885.00',\n 'WL_886.00',\n 'WL_887.00',\n 'WL_888.00',\n 'WL_889.00',\n 'WL_890.00',\n 'WL_891.00',\n 'WL_892.00',\n 'WL_893.00',\n 'WL_894.00',\n 'WL_895.00',\n 'WL_896.00',\n 'WL_897.00',\n 'WL_898.00',\n 'WL_899.00',\n 'WL_900.00',\n 'WL_901.00',\n 'WL_902.00',\n 'WL_903.00',\n 'WL_904.00',\n 'WL_905.00',\n 'WL_906.00',\n 'WL_907.00',\n 'WL_908.00',\n 'WL_909.00',\n 'WL_910.00',\n 'WL_911.00',\n 'WL_912.00',\n 'WL_913.00',\n 'WL_884.9_L_LMW-H_Nijmegen-haven',\n 'WL_901.4_R_LMW-H_Dodewaard']</pre> In\u00a0[7]: Copied! <pre>plotter.figure_compare_discharge_at_stations(stations=['WL_869.00', 'PK_869.00'], \n                                             title=\"Pannerdensche Kop\",\n                                            savefig=False)\n</pre> plotter.figure_compare_discharge_at_stations(stations=['WL_869.00', 'PK_869.00'],                                               title=\"Pannerdensche Kop\",                                             savefig=False) Out[7]: <pre>FigureOutput(fig=&lt;Figure size 1200x1000 with 3 Axes&gt;, axes=array([&lt;Axes: title={'center': 'tijdserie'}, ylabel='afvoer [m$^3$/s]'&gt;,\n       &lt;Axes: title={'center': 'afvoerverdeling'}, xlabel='afvoer bovenstrooms [m$^3$/s]', ylabel='percentage t.o.v. totaal'&gt;],\n      dtype=object), legend=&lt;matplotlib.legend.Legend object at 0x000002A235673410&gt;)</pre>"},{"location":"notebooks/compare1d2d/#compare-1d-and-2d-model-output","title":"Compare 1D and 2D model output\u00b6","text":"<p>This notebook show examples of how to use the <code>Compare1D2D</code> utility to produce figures and tables.</p>"},{"location":"notebooks/compare1d2d/#reading-1d-and-2d-output","title":"Reading 1D and 2D output\u00b6","text":"<p>Model output can be quite large, so we only want to read output once. In this notebook, we assume the utility has already initialised and <code>1D_H.csv</code>, <code>2D_H.csv</code> files are already generated. However, see the commented-out code on how to generate these csv files from netCDF model output.</p>"},{"location":"notebooks/compare1d2d/#showing-results-along-a-route","title":"Showing results along a route\u00b6","text":"<p>The example data contains results for the Rijn river. A route along the Rhine we might inspect is the Bovenrijn (BR) to Waal (WL). Below, we set <code>savefig=False</code>, so that the figure renders in the notebook. If you set <code>savefig=True</code>, it will save as a png to the <code>project</code> output folder.</p>"},{"location":"notebooks/compare1d2d/#combining-multiple-simulations-in-a-single-graph","title":"Combining multiple simulations in a single graph\u00b6","text":"<p>To show the results of multiple simulations, it makes sense to plot a single line per simulation. Two available stats are implemented: <code>max13</code> plots the average of the 13 highest values for each location, which makes sense for a Dynamic standard simulation. The <code>last25</code> shows the average of the last 25 output, which makes most sense for a steady simulation.</p>"},{"location":"notebooks/compare1d2d/#showing-results-for-a-single-station","title":"Showing results for a single station\u00b6","text":"<p>To compare results at a single station, use the following method</p>"},{"location":"notebooks/compare1d2d/#compare-discharge-distribution","title":"Compare discharge distribution\u00b6","text":"<p>To plot discharge distribution between two stations, use the following code</p>"},{"location":"notebooks/cross_section_data/","title":"Inspecting cross-sections","text":"In\u00a0[1]: Copied! <pre>import pickle\n\n# Cross-sections test cases\ncases = [\"waal_1_40147.826\", \"reevediep_2888.800\", \"veessenwapenveld_3519.948\", \"ketelmeer02_0.000\", \"twentekanaal_941.714\", \"nederrijn_20011.855\"]\n\ncase = cases[5]\n\nwith open(fr\"../../tests/test_data/cross_sections/{case}.pickle\", \"rb\") as f:\n    data = pickle.load(f)\n</pre> import pickle  # Cross-sections test cases cases = [\"waal_1_40147.826\", \"reevediep_2888.800\", \"veessenwapenveld_3519.948\", \"ketelmeer02_0.000\", \"twentekanaal_941.714\", \"nederrijn_20011.855\"]  case = cases[5]  with open(fr\"../../tests/test_data/cross_sections/{case}.pickle\", \"rb\") as f:     data = pickle.load(f) In\u00a0[2]: Copied! <pre>import matplotlib.pyplot as plt\n\nvariable = 'bedlevel'  # other variables to plot: bedlevel, section, region, area\nx = data.get('fm_data').get('x')\ny = data.get('fm_data').get('y')\nz = data.get('fm_data').get(variable)\n\nfig, ax = plt.subplots(1)\nsc = ax.scatter(x/1000, y/1000, c=z)\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(variable)\n</pre> import matplotlib.pyplot as plt  variable = 'bedlevel'  # other variables to plot: bedlevel, section, region, area x = data.get('fm_data').get('x') y = data.get('fm_data').get('y') z = data.get('fm_data').get(variable)  fig, ax = plt.subplots(1) sc = ax.scatter(x/1000, y/1000, c=z) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(variable)  In\u00a0[6]: Copied! <pre>%matplotlib widget\nfrom ipywidgets import *\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\nvariable = 'velocity' # try also: waterlevel, waterdepth\n\nz = data.get('fm_data').get(variable)\nfig, ax = plt.subplots(1)\n\nsc = ax.scatter(x/1000, y/1000, c=z.iloc[6])\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(variable)\nplt.show(fig)\n\ndef update(i):\n    plt.gca()\n    zi = z.iloc[i]\n    ax.scatter(x/1000, y/1000, c=zi)\n    fig.canvas.draw()\n\ninteract(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))\n</pre> %matplotlib widget from ipywidgets import * import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap  variable = 'velocity' # try also: waterlevel, waterdepth  z = data.get('fm_data').get(variable) fig, ax = plt.subplots(1)  sc = ax.scatter(x/1000, y/1000, c=z.iloc[6]) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(variable) plt.show(fig)  def update(i):     plt.gca()     zi = z.iloc[i]     ax.scatter(x/1000, y/1000, c=zi)     fig.canvas.draw()  interact(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))                      Figure                  <pre>interactive(children=(IntSlider(value=6, description='i', max=46), Output()), _dom_classes=('widget-interact',\u2026</pre> Out[6]: <pre>&lt;function __main__.update(i)&gt;</pre> In\u00a0[7]: Copied! <pre>with open(fr\"../../tests/test_data/cross_sections/{case}_flowmask.pickle\", \"rb\") as f:\n    flowmask = pickle.load(f)\n</pre> with open(fr\"../../tests/test_data/cross_sections/{case}_flowmask.pickle\", \"rb\") as f:     flowmask = pickle.load(f) <p>The code below visualises how this criterium is met during the 2D simulation. You'll see that as you progress in time, more cells will mee the criterium.</p> In\u00a0[8]: Copied! <pre>%matplotlib widget\nfrom ipywidgets import *\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\nfig, ax = plt.subplots(1)\nfm = flowmask.T.iloc[0]\nsc = ax.scatter(x/1000, y/1000, c=fm)\nax.set_aspect('equal', adjustable='box')\nax.set_title(case)\ncb = plt.colorbar(sc)\ncb.set_label(\"meets conveyance criterium\")\nplt.show(fig)\n\ndef update(i):\n    plt.gca()\n    fm = flowmask.T.iloc[i]\n    ax.scatter(x/1000, y/1000, c=fm)\n    fig.canvas.draw()\n\ninteract(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))\n</pre> %matplotlib widget from ipywidgets import * import numpy as np import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap  fig, ax = plt.subplots(1) fm = flowmask.T.iloc[0] sc = ax.scatter(x/1000, y/1000, c=fm) ax.set_aspect('equal', adjustable='box') ax.set_title(case) cb = plt.colorbar(sc) cb.set_label(\"meets conveyance criterium\") plt.show(fig)  def update(i):     plt.gca()     fm = flowmask.T.iloc[i]     ax.scatter(x/1000, y/1000, c=fm)     fig.canvas.draw()  interact(update, i=widgets.IntSlider(min=0, max=46, step=1, value=6))                      Figure                  <pre>interactive(children=(IntSlider(value=6, description='i', max=46), Output()), _dom_classes=('widget-interact',\u2026</pre> Out[8]: <pre>&lt;function __main__.update(i)&gt;</pre>"},{"location":"notebooks/cross_section_data/#inspecting-cross-sections","title":"Inspecting cross-sections\u00b6","text":"<p>If deeper analysis of cross-section is required, you can enable the option <code>ExportCSSData</code> in the fm2prof project configuration file. This notebooks shows some techniques to visualise this data.</p>"},{"location":"notebooks/cross_section_data/#loading-the-data","title":"Loading the data\u00b6","text":"<p>Example output is provided in the tests directory of the fm2prof repository. This is pickled data, so we'll use <code>pickle</code> to read it.</p>"},{"location":"notebooks/cross_section_data/#visualise-the-cross-section-input-data","title":"Visualise the cross-section input data\u00b6","text":"<p>When unpickled, this data is a <code>dict</code> of pandas DataFrames. The variable <code>data</code> holds all information that the <code>fm2prof.CrossSection</code> class uses to build a 1D cross-section. Let's visualise this data:</p>"},{"location":"notebooks/cross_section_data/#visualising-velocity","title":"Visualising velocity\u00b6","text":""},{"location":"notebooks/cross_section_data/#visualising-conveyance","title":"Visualising conveyance\u00b6","text":"<p>Another provided data file is the <code>flowmask.pickle</code> file. This file contains information generated during the cross-section production. The <code>flowmask</code> encodes information on which cells meet the conveyance criterium (stroomvoeringscriterium).</p>"}]}